<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>2 Transformations and dimension reduction | Multivariate Statistics and Machine Learning</title>
<meta name="author" content="Korbinian Strimmer">
<meta name="generator" content="bookdown 0.24 with bs4_book()">
<meta property="og:title" content="2 Transformations and dimension reduction | Multivariate Statistics and Machine Learning">
<meta property="og:type" content="book">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="2 Transformations and dimension reduction | Multivariate Statistics and Machine Learning">
<!-- JS --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script><script src="libs/header-attrs-2.11/header-attrs.js"></script><script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet">
<script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script><script src="libs/bs3compat-0.3.1/transition.js"></script><script src="libs/bs3compat-0.3.1/tabs.js"></script><script src="libs/bs3compat-0.3.1/bs3compat.js"></script><link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet">
<script src="libs/bs4_book-1.0.0/bs4_book.js"></script><script src="libs/accessible-code-block-0.0.1/empty-anchor.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- CSS --><meta name="description" content="Motivation: In the following we study transformations of random vectors and their distributions. These transformation are very important since they either transform simple distributions into more...">
<meta property="og:description" content="Motivation: In the following we study transformations of random vectors and their distributions. These transformation are very important since they either transform simple distributions into more...">
<meta name="twitter:description" content="Motivation: In the following we study transformations of random vectors and their distributions. These transformation are very important since they either transform simple distributions into more...">
</head>
<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book"><a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h1>
        <a href="index.html" title="">Multivariate Statistics and Machine Learning</a>
      </h1>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
</form>

      <nav aria-label="Table of contents"><h2>Table of contents</h2>
        <ul class="book-toc list-unstyled">
<li><a class="" href="index.html">Welcome</a></li>
<li><a class="" href="preface.html">Preface</a></li>
<li><a class="" href="multivariate-random-variables.html"><span class="header-section-number">1</span> Multivariate random variables</a></li>
<li><a class="active" href="transformations-and-dimension-reduction.html"><span class="header-section-number">2</span> Transformations and dimension reduction</a></li>
<li><a class="" href="unsupervised-learning-and-clustering.html"><span class="header-section-number">3</span> Unsupervised learning and clustering</a></li>
<li><a class="" href="supervised-learning-and-classification.html"><span class="header-section-number">4</span> Supervised learning and classification</a></li>
<li><a class="" href="multivariate-dependencies.html"><span class="header-section-number">5</span> Multivariate dependencies</a></li>
<li><a class="" href="nonlinear-and-nonparametric-models.html"><span class="header-section-number">6</span> Nonlinear and nonparametric models</a></li>
<li class="book-part">Appendix</li>
<li><a class="" href="brief-refresher-on-matrices.html"><span class="header-section-number">A</span> Brief refresher on matrices</a></li>
<li><a class="" href="further-study.html"><span class="header-section-number">B</span> Further study</a></li>
<li><a class="" href="bibliography.html">Bibliography</a></li>
</ul>

        <div class="book-extra">
          
        </div>
      </nav>
</div>
  </header><main class="col-sm-12 col-md-9 col-lg-7" id="content"><div id="transformations-and-dimension-reduction" class="section level1" number="2">
<h1>
<span class="header-section-number">2</span> Transformations and dimension reduction<a class="anchor" aria-label="anchor" href="#transformations-and-dimension-reduction"><i class="fas fa-link"></i></a>
</h1>
<p>Motivation:
In the following we study transformations of random vectors and their distributions.
These transformation are very important
since they either transform simple distributions into more complex distributions or allow to simplify
complex models. In machine learning invertible mappings of transformations
for probability distributions are known as “normalising flows”.</p>
<div id="linear-transformations" class="section level2" number="2.1">
<h2>
<span class="header-section-number">2.1</span> Linear Transformations<a class="anchor" aria-label="anchor" href="#linear-transformations"><i class="fas fa-link"></i></a>
</h2>
<div id="location-scale-transformation" class="section level3" number="2.1.1">
<h3>
<span class="header-section-number">2.1.1</span> Location-scale transformation<a class="anchor" aria-label="anchor" href="#location-scale-transformation"><i class="fas fa-link"></i></a>
</h3>
<p>Also known as affine transformation.</p>
<p><span class="math display">\[\boldsymbol y= \underbrace{\boldsymbol a}_{\text{location parameter}}+\underbrace{\boldsymbol B}_{\text{scale parameter}} \boldsymbol x\space\]</span>
<span class="math display">\[\boldsymbol y: m \times 1 \text{ random vector}\]</span>
<span class="math display">\[\boldsymbol a: m \times 1 \text{ vector, location parameter}\]</span>
<span class="math display">\[\boldsymbol B: m \times d \text{ matrix, scale parameter },  m \geq 1\]</span>
<span class="math display">\[\boldsymbol x: d \times 1 \text{ random vector}\]</span></p>
<p>Mean and variance of the original vector <span class="math inline">\(\boldsymbol x\)</span>:</p>
<p><span class="math display">\[\text{E}(\boldsymbol x)=\boldsymbol \mu\]</span>
<span class="math display">\[\text{Var}(\boldsymbol x)=\boldsymbol \Sigma\]</span></p>
<p>Mean and variance of the transformed random vector <span class="math inline">\(\boldsymbol y\)</span>:</p>
<p><span class="math display">\[\text{E}(\boldsymbol y)=\boldsymbol a+ \boldsymbol B\boldsymbol \mu\]</span>
<span class="math display">\[\text{Var}(\boldsymbol y)= \boldsymbol B\boldsymbol \Sigma\boldsymbol B^T\]</span></p>
<p>Cross-covariance <span class="math inline">\(\boldsymbol \Phi= \Sigma_{\boldsymbol y\boldsymbol x}\)</span> between <span class="math inline">\(\boldsymbol y\)</span> and <span class="math inline">\(\boldsymbol x\)</span>:
<span class="math display">\[
\boldsymbol \Phi= \text{Cov}(\boldsymbol y,\boldsymbol x) = \text{Cov}(\boldsymbol B\boldsymbol x,\boldsymbol x) = \boldsymbol B\boldsymbol \Sigma
\]</span></p>
<p>Cross-correlation <span class="math inline">\(\boldsymbol \Psi= \boldsymbol P_{\boldsymbol y\boldsymbol x}\)</span> between <span class="math inline">\(\boldsymbol y\)</span> and <span class="math inline">\(\boldsymbol x\)</span>:
<span class="math display">\[
\boldsymbol \Psi= \text{Cor}(\boldsymbol y,\boldsymbol x) = \boldsymbol V_{\boldsymbol y}^{-1/2} \boldsymbol \Phi\boldsymbol V_{\boldsymbol x}^{-1/2}
\]</span>
where <span class="math inline">\(\boldsymbol V_{\boldsymbol x} = \text{Diag}(\boldsymbol \Sigma)\)</span> and <span class="math inline">\(\boldsymbol V_{\boldsymbol y} = \text{Diag}(\boldsymbol B\boldsymbol \Sigma\boldsymbol B^T)\)</span></p>
<p>Special cases/examples:</p>
<div class="example">
<p><span id="exm:univartrans" class="example"><strong>Example 2.1  </strong></span>Univariate case (<span class="math inline">\(d=1, m=1\)</span>): <span class="math inline">\(y=a + b x\)</span></p>
<ul>
<li><span class="math inline">\(\text{E}(y)=a+b\mu\)</span></li>
<li><span class="math inline">\(\text{Var}(y)=b^2\sigma^2\)</span></li>
<li><span class="math inline">\(\text{Cov}(y, x) = b\sigma^2\)</span></li>
<li><span class="math inline">\(\text{Cor}(y, x) = \frac{b \sigma^2}{\sqrt{b^2\sigma^2} \sqrt{\sigma^2} } =1\)</span></li>
</ul>
</div>
<div class="example">
<p><span id="exm:sumunivariate" class="example"><strong>Example 2.2  </strong></span>Sum of two random univariate variables:
<span class="math inline">\(y = x_1 + x_2\)</span>, i.e. <span class="math inline">\(a=0\)</span> and <span class="math inline">\(\boldsymbol B=(1,1)\)</span></p>
<ul>
<li><span class="math inline">\(\text{E}(y) = \text{E}(x_1+x_2)=\mu_1+\mu_2\)</span></li>
<li><span class="math inline">\(\text{Var}(y) = \text{Var}(x_1+x_2) = (1,1)\begin{pmatrix} \sigma^2_1 &amp; \sigma_{12}\\ \sigma_{12} &amp; \sigma^2_2 \end{pmatrix} \begin{pmatrix} 1\\ 1 \end{pmatrix} = \sigma^2_1+\sigma^2_2+2\sigma_{12} = \text{Var}(x_1)+\text{Var}(x_2)+2\text{Cov}(x_1,x_2)\)</span></li>
</ul>
</div>
<div class="example">
<p><span id="exm:transformcov" class="example"><strong>Example 2.3  </strong></span><span class="math inline">\(y_1=a_1+b_1 x_1\)</span> and <span class="math inline">\(y_2=a_2+b_2 x_2\)</span>,
i.e. <span class="math inline">\(\boldsymbol a= \begin{pmatrix} a_1\\ a_2 \end{pmatrix}\)</span> and<br><span class="math inline">\(\boldsymbol B= \begin{pmatrix}b_1 &amp; 0\\ 0 &amp; b_2\end{pmatrix}\)</span></p>
<ul>
<li>
<span class="math inline">\(\text{E}(\boldsymbol y)=\begin{pmatrix} a_1+b_1 \mu_1\\ a_2+b_2 \mu_2 \end{pmatrix}\)</span><br>
</li>
<li>
<span class="math inline">\(\text{Var}(\boldsymbol y) = \begin{pmatrix} b_1 &amp; 0\\ 0 &amp; b_2 \end{pmatrix}  \begin{pmatrix} \sigma^2_1 &amp; \sigma_{12}\\ \sigma_{12} &amp; \sigma^2_2 \end{pmatrix} \begin{pmatrix} b_1 &amp; 0\\ 0 &amp; b_2 \end{pmatrix} = \begin{pmatrix} b^2_1\sigma^2_1 &amp; b_1b_2\sigma_{12}\\ b_1b_2\sigma_{12} &amp; b^2_2\sigma^2_2 \end{pmatrix}\)</span><br>
note that <span class="math inline">\(\text{Cov}(y_1, y_2) = b_1 b_2\text{Cov}(x_1,x_2)\)</span>
</li>
</ul>
</div>
</div>
<div id="squared-multiple-correlation" class="section level3" number="2.1.2">
<h3>
<span class="header-section-number">2.1.2</span> Squared multiple correlation<a class="anchor" aria-label="anchor" href="#squared-multiple-correlation"><i class="fas fa-link"></i></a>
</h3>
<p><strong>Definition of squared multiple correlation</strong></p>
<p>Squared multiple correlation is a measure summarising the linear association between a scalar response variable <span class="math inline">\(y\)</span>
and a set of predictors <span class="math inline">\(\boldsymbol x= (x_1, \ldots, x_d)^T\)</span>. It is given by
<span class="math display">\[
\begin{split}
\text{Cor}(y, \boldsymbol x)^2 &amp;= \boldsymbol \Sigma_{y \boldsymbol x} \boldsymbol \Sigma_{\boldsymbol x}^{-1} \boldsymbol \Sigma_{\boldsymbol xy} / \sigma^2_y\\
 &amp;=\boldsymbol P_{y \boldsymbol x} \boldsymbol P_{ \boldsymbol x}^{-1} \boldsymbol P_{\boldsymbol xy}\\
\end{split}
\]</span>
If <span class="math inline">\(y\)</span> can be perfectly linearly predicted by <span class="math inline">\(\boldsymbol x\)</span> then <span class="math inline">\(\text{Cor}(y, \boldsymbol x)^2 = 1\)</span>.</p>
<p>The empirical estimate of <span class="math inline">\(\text{Cor}(y, \boldsymbol x)^2\)</span> is the <span class="math inline">\(R^2\)</span> coefficient that you will find in any software for linear regression.</p>
<p>See the corresponding section in <a href="https://strimmerlab.github.io/publications/lecture-notes/MATH20802/squared-multiple-correlation-and-variance-decomposition-in-linear-regression.html">MATH20802 Statistical Methods</a>.</p>
<p><strong>Squared multiple correlation for affine transformation</strong></p>
<p>Since we linearly transform <span class="math inline">\(\boldsymbol x\)</span> into <span class="math inline">\(\boldsymbol y\)</span> with no additional error involved we expect
that for each component <span class="math inline">\(y_i\)</span> in <span class="math inline">\(\boldsymbol y\)</span> we have <span class="math inline">\(\text{Cor}(y_i, \boldsymbol x)^2=1\)</span>.
This can be shown directly by computing
<span class="math display">\[
\begin{split}
\left(\text{Cor}(y_1, \boldsymbol x)^2, \ldots, \text{Cor}(y_m, \boldsymbol x)^2 \right)^T
&amp;=\text{Diag}\left(\boldsymbol \Sigma_{\boldsymbol y\boldsymbol x} \boldsymbol \Sigma_{\boldsymbol x}^{-1} \boldsymbol \Sigma_{\boldsymbol x\boldsymbol y}  \right) / \text{Diag}\left( \boldsymbol \Sigma_{\boldsymbol y} \right) \\
&amp;= \text{Diag}\left(\boldsymbol \Phi\boldsymbol \Sigma_{\boldsymbol x}^{-1} \boldsymbol \Phi^T  \right) / \text{Diag}\left( \boldsymbol B\boldsymbol \Sigma_{\boldsymbol x} \boldsymbol B^T \right) \\
&amp;= \text{Diag}\left(\boldsymbol B\boldsymbol \Sigma_{\boldsymbol x} \boldsymbol \Sigma_{\boldsymbol x}^{-1} \boldsymbol \Sigma_{\boldsymbol x} \boldsymbol B^T \right) / \text{Diag}\left( \boldsymbol B\boldsymbol \Sigma_{\boldsymbol x} \boldsymbol B^T \right) \\
&amp;= \text{Diag}\left(\boldsymbol B\boldsymbol \Sigma_{\boldsymbol x} \boldsymbol B^T \right) / \text{Diag}\left( \boldsymbol B\boldsymbol \Sigma_{\boldsymbol x} \boldsymbol B^T \right) \\
&amp;=\text{Diag}\left(1, \ldots, 1 \right)^T\\
\end{split}
\]</span></p>
</div>
<div id="invertible-location-scale-transformation" class="section level3" number="2.1.3">
<h3>
<span class="header-section-number">2.1.3</span> Invertible location-scale transformation<a class="anchor" aria-label="anchor" href="#invertible-location-scale-transformation"><i class="fas fa-link"></i></a>
</h3>
<p>If <span class="math inline">\(m=d\)</span> (square <span class="math inline">\(\boldsymbol B\)</span>) and <span class="math inline">\(\det(\boldsymbol B) \neq 0\)</span> then the affine transformation is <strong>invertible</strong>.</p>
<p>Forward transformation:
<span class="math display">\[\boldsymbol y= \boldsymbol a+ \boldsymbol B\boldsymbol x\]</span></p>
<p>Back transformation:
<span class="math display">\[\boldsymbol x= \boldsymbol B^{-1}(\boldsymbol y-\boldsymbol a)\]</span></p>
<p>Invertible transformations thus provide a one-to-one map between <span class="math inline">\(\boldsymbol x\)</span> and <span class="math inline">\(\boldsymbol y\)</span>.</p>
<div class="example">
<p><span id="exm:mahatrans" class="example"><strong>Example 2.4  </strong></span><strong>Mahalanobis transform</strong></p>
</div>
<p>We assume a positive definite and thus invertible <span class="math inline">\(\boldsymbol \Sigma\)</span>, so
that the inverse principal matrix square root <span class="math inline">\(\boldsymbol \Sigma^{-1/2}\)</span> can be computed,
and the transformation itself is invertible.</p>
<p>The Mahalanobis transformation is then given by
<span class="math display">\[
\boldsymbol y=\boldsymbol \Sigma^{-1/2}(\boldsymbol x-\boldsymbol \mu)
\]</span>
This corresponds to an affine transformation with
<span class="math inline">\(\boldsymbol a= - \boldsymbol \Sigma^{-1/2} \boldsymbol \mu\)</span> and <span class="math inline">\(\boldsymbol B= \boldsymbol \Sigma^{-1/2}\)</span>.</p>
<p>Starting with <span class="math inline">\(\text{E}(\boldsymbol x)=\boldsymbol \mu\)</span> and <span class="math inline">\(\text{Var}(\boldsymbol x)=\boldsymbol \Sigma\)</span>
we arrive at
<span class="math display">\[
\text{E}(\boldsymbol y) = \boldsymbol 0\]</span>
and
<span class="math display">\[\text{Var}(\boldsymbol y) = \boldsymbol I_d\]</span>.</p>
<p>The Mahalanobis transforms performs three functions:</p>
<ol style="list-style-type: decimal">
<li>Centering (<span class="math inline">\(-\boldsymbol \mu\)</span>)</li>
<li>Standardisation <span class="math inline">\(\text{Var}(y_i)=1\)</span>
</li>
<li>Decorrelation <span class="math inline">\(\text{Cor}(y_i,y_j)=0\)</span> for <span class="math inline">\(i \neq j\)</span>
</li>
</ol>
<p>In the <strong>univariate case (<span class="math inline">\(d=1\)</span>)</strong> the coefficients reduce to
<span class="math inline">\(a = - \frac{\mu}{\sigma}\)</span> and <span class="math inline">\(B = \frac{1}{\sigma}\)</span> and the Mahalanobis transform
becomes
<span class="math display">\[y = \frac{x-\mu}{\sigma}\]</span>
i.e. it applies centering + standardisation.</p>
<p>The <strong>Mahalanobis transformation</strong> appears implicitly in many places in multivariate statistics,
e.g. in the multivariate normal density. It is a particular example of a whitening transformation (of which there
are infinitely many, see later in the course).</p>
<div class="example">
<p><span id="exm:coltrans" class="example"><strong>Example 2.5  </strong></span><strong>Inverse Mahalanobis transformation</strong></p>
</div>
<p>The inverse of the Mahalanobis transform is given by
<span class="math display">\[
\boldsymbol y= \boldsymbol \mu+\boldsymbol \Sigma^{1/2} \boldsymbol x
\]</span>
As the Mahalanobis transform is a whitening transform the inverse Mahalonobis
transform is sometimes called the Mahalanobis colouring transformation.
The coefficients in the affine transformation are
<span class="math inline">\(\boldsymbol a=\boldsymbol \mu\)</span> and <span class="math inline">\(\boldsymbol B=\boldsymbol \Sigma^{1/2}\)</span>.</p>
<p>Starting with <span class="math inline">\(\text{E}(\boldsymbol x)=\boldsymbol 0\)</span> and <span class="math inline">\(\text{Var}(\boldsymbol x)=\boldsymbol I_d\)</span> the
mean and variance of the transformed variable are
<span class="math display">\[\text{E}(\boldsymbol y) = \boldsymbol \mu
\]</span>
and
<span class="math display">\[\text{Var}(\boldsymbol y) = \boldsymbol \Sigma
\]</span></p>
</div>
<div id="transformation-of-a-density-under-an-invertible-location-scale-transformation" class="section level3" number="2.1.4">
<h3>
<span class="header-section-number">2.1.4</span> Transformation of a density under an invertible location-scale transformation:<a class="anchor" aria-label="anchor" href="#transformation-of-a-density-under-an-invertible-location-scale-transformation"><i class="fas fa-link"></i></a>
</h3>
<p>Assume <span class="math inline">\(\boldsymbol x\sim F_{\boldsymbol x}\)</span> with density <span class="math inline">\(f_{\boldsymbol x}(\boldsymbol x)\)</span>.</p>
<p>After linear transformation <span class="math inline">\(\boldsymbol y= \boldsymbol a+ \boldsymbol B\boldsymbol x\)</span> we get <span class="math inline">\(\boldsymbol y\sim F_{\boldsymbol y}\)</span> with density
<span class="math display">\[f_{\boldsymbol y}(\boldsymbol y)=|\det(\boldsymbol B)|^{-1} f_{\boldsymbol x} \left( \boldsymbol B^{-1}(\boldsymbol y-\boldsymbol a)\right)\]</span></p>
<div class="example">
<p><span id="exm:invmahanorm" class="example"><strong>Example 2.6  </strong></span>Transformation of standard normal with inverse Mahalanobis transform</p>
</div>
<p>Assume <span class="math inline">\(\boldsymbol x\)</span> is multivariate standard normal <span class="math inline">\(\boldsymbol x\sim N_d(\boldsymbol 0,\boldsymbol I_d)\)</span> with density
<span class="math display">\[f_{\boldsymbol x}(\boldsymbol x) = (2\pi)^{-d/2}\exp\left( -\frac{1}{2} \boldsymbol x^T \boldsymbol x\right)\]</span>
Then the density after applying the inverse Mahalanobis transform<br><span class="math inline">\(\boldsymbol y= \boldsymbol \mu+\boldsymbol \Sigma^{1/2} \boldsymbol x\)</span> is
<span class="math display">\[
\begin{split}
f_{\boldsymbol y}(\boldsymbol y) &amp;= |\det(\boldsymbol \Sigma^{1/2})|^{-1} (2\pi)^{-d/2} \exp\left(-\frac{1}{2}(\boldsymbol y-\boldsymbol \mu)^T\boldsymbol \Sigma^{-1/2} \,\boldsymbol \Sigma^{-1/2}(\boldsymbol y-\boldsymbol \mu)\right)\\
&amp; = (2\pi)^{-d/2} \det(\boldsymbol \Sigma)^{-1/2} \exp\left(-\frac{1}{2}(\boldsymbol y-\boldsymbol \mu)^T\boldsymbol \Sigma^{-1}(\boldsymbol y-\boldsymbol \mu)\right) \\
\end{split}
\]</span>
<span class="math inline">\(\Longrightarrow\)</span> <span class="math inline">\(\boldsymbol y\)</span> has multivariate normal density!!</p>
<p><em>Application:</em> e.g. random number generation: draw from <span class="math inline">\(N_d(\boldsymbol 0,\boldsymbol I_d)\)</span> (easy!) then convert to multivariate normal by tranformation
(see Worksheet 3).</p>
</div>
</div>
<div id="nonlinear-transformations" class="section level2" number="2.2">
<h2>
<span class="header-section-number">2.2</span> Nonlinear transformations<a class="anchor" aria-label="anchor" href="#nonlinear-transformations"><i class="fas fa-link"></i></a>
</h2>
<div id="general-transformation" class="section level3" number="2.2.1">
<h3>
<span class="header-section-number">2.2.1</span> General transformation<a class="anchor" aria-label="anchor" href="#general-transformation"><i class="fas fa-link"></i></a>
</h3>
<p><span class="math display">\[\boldsymbol y= \boldsymbol h(\boldsymbol x)\]</span>
with <span class="math inline">\(\boldsymbol h\)</span> an arbitrary vector-valued function</p>
<ul>
<li>linear case: <span class="math inline">\(\boldsymbol h(\boldsymbol x) = \boldsymbol a+\boldsymbol B\boldsymbol x\)</span>
</li>
</ul>
</div>
<div id="delta-method" class="section level3" number="2.2.2">
<h3>
<span class="header-section-number">2.2.2</span> Delta method<a class="anchor" aria-label="anchor" href="#delta-method"><i class="fas fa-link"></i></a>
</h3>
<p>Assume that we know the mean <span class="math inline">\(\text{E}(\boldsymbol x)=\boldsymbol \mu\)</span> and variance <span class="math inline">\(\text{Var}(\boldsymbol x)=\boldsymbol \Sigma\)</span> of <span class="math inline">\(\boldsymbol x\)</span>.
Is it possible to say something about the mean and variance of the transformed
random variable <span class="math inline">\(\boldsymbol y\)</span>?
<span class="math display">\[
\text{E}(\boldsymbol y)= \text{E}(\boldsymbol h(\boldsymbol x))= ?
\]</span>
<span class="math display">\[
\text{Var}(\boldsymbol y) = \text{Var}(\boldsymbol h(\boldsymbol x))= ? \\
\]</span></p>
<p>In general, for a transformation <span class="math inline">\(\boldsymbol h(\boldsymbol x)\)</span> the exact mean and variance of the transformed variable cannot be obtained analytically.</p>
<p>However, we can find a <strong>linear approximation</strong> and then compute its mean and variance.
This approximation is called the “Delta Method”, or the “law of propagation of errors”, and is credited to Gauss.<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;Gorroochurn, P. 2020. Who Invented the Delta Method, Really? The Mathematical Intelligencer &lt;strong&gt;42&lt;/strong&gt;:46–49. &lt;a href="https://doi.org/10.1007/s00283-020-09982-0" class="uri"&gt;https://doi.org/10.1007/s00283-020-09982-0&lt;/a&gt;&lt;/p&gt;'><sup>2</sup></a></p>
<p>Linearisation of <span class="math inline">\(\boldsymbol h(\boldsymbol x)\)</span> is achieved by a Taylor series approximation of first order
of <span class="math inline">\(\boldsymbol h(\boldsymbol x)\)</span> around <span class="math inline">\(\boldsymbol x_0\)</span>:
<span class="math display">\[\boldsymbol h(\boldsymbol x) \approx \boldsymbol h(\boldsymbol x_0) + \underbrace{D\boldsymbol h(\boldsymbol x_0)}_{\text{Jacobian matrix}}(\boldsymbol x-\boldsymbol x_0)  = 
\underbrace{\boldsymbol h(\boldsymbol x_0) - D\boldsymbol h(\boldsymbol x_0)\, \boldsymbol x_0}_{\boldsymbol a} + \underbrace{D\boldsymbol h(\boldsymbol x_0)}_{\boldsymbol B} \boldsymbol x\]</span></p>
<p><span class="math inline">\(\nabla\)</span>, the nabla operator, is the row vector <span class="math inline">\((\frac{\partial}{\partial x_1},...,\frac{\partial}{\partial x_d})\)</span>, which when applied to univariate <span class="math inline">\(h\)</span> gives the gradient:</p>
<p><span class="math display">\[\nabla h(\boldsymbol x) = \left(\frac{\partial h}{\partial x_1},...,\frac{\partial h}{\partial x_d}\right)\]</span></p>
<p>The <strong>Jacobian matrix</strong> is the <strong>generalisation of the gradient</strong> if <span class="math inline">\(\boldsymbol h\)</span> is vector-valued:</p>
<p><span class="math display">\[D\boldsymbol h(\boldsymbol x) = \begin{pmatrix}\nabla h_1(\boldsymbol x)\\ \nabla h_2(\boldsymbol x) \\ \vdots \\ \nabla h_m(\boldsymbol x) \end{pmatrix} = \begin{pmatrix}
    \frac{\partial h_1}{\partial x_1} &amp; \dots &amp; \frac{\partial h_1}{\partial x_d}\\
    \vdots &amp; \ddots &amp; \vdots \\
    \frac{\partial h_m}{\partial x_1} &amp; \dots &amp; \frac{\partial h_m}{\partial x_d}
    \end{pmatrix}\]</span></p>
<p>First order approximation of <span class="math inline">\(\boldsymbol h(\boldsymbol x)\)</span> around <span class="math inline">\(\boldsymbol x_0=\boldsymbol \mu\)</span> yields
<span class="math inline">\(\boldsymbol a= \boldsymbol h(\boldsymbol \mu) - D\boldsymbol h(\boldsymbol \mu)\, \boldsymbol \mu\)</span> and
<span class="math inline">\(\boldsymbol B= D\boldsymbol h(\boldsymbol \mu)\)</span> and leads directly to the <strong>multivariate Delta method</strong>:</p>
<p><span class="math display">\[\text{E}(\boldsymbol y)\approx\boldsymbol h(\boldsymbol \mu)\]</span>
<span class="math display">\[\text{Var}(\boldsymbol y)\approx D\boldsymbol h(\boldsymbol \mu) \, \boldsymbol \Sigma\, (D\boldsymbol h(\boldsymbol \mu))^T\]</span></p>
<p>The <strong>univariate Delta method</strong> is a special case:
<span class="math display">\[\text{E}(y) \approx h(\mu)\]</span>
<span class="math display">\[\text{Var}(y)\approx \sigma^2 h'(\mu)^2\]</span></p>
<p>Note that the Delta approximation breaks down if <span class="math inline">\(\text{Var}(\boldsymbol y)\)</span> is singular,
for example if the first derivative (or gradient or Jacobian matrix) at <span class="math inline">\(\boldsymbol \mu\)</span> is zero.</p>
<div class="example">
<p><span id="exm:varoddsration" class="example"><strong>Example 2.7  </strong></span><strong>Variance of the odds ratio</strong></p>
<p>The proportion <span class="math inline">\(\hat{p} = \frac{n_1}{n}\)</span> resulting from
<span class="math inline">\(n\)</span> repeats of a Bernoulli experiment has expectation <span class="math inline">\(\text{E}(\hat{p})=p\)</span>
and variance <span class="math inline">\(\text{Var}(\hat{p}) = \frac{p (1-p)}{n}\)</span>.
What are the (approximate) mean and the variance of the corresponding odds ratio <span class="math inline">\(\widehat{OR}=\frac{\hat{p}}{1-\hat{p}}\)</span>?</p>
<p>With <span class="math inline">\(h(x) = \frac{x}{1-x}\)</span>,
<span class="math inline">\(\widehat{OR} = h(\hat{p})\)</span> and <span class="math inline">\(h'(x) = \frac{1}{(1-x)^2}\)</span> we get using the
Delta method
<span class="math inline">\(\text{E}( \widehat{OR} ) \approx h(p) = \frac{p}{1-p}\)</span> and
<span class="math inline">\(\text{Var}( \widehat{OR} )\approx h'(p)^2 \text{Var}( \hat{p} ) = \frac{p}{n (1-p)^3}\)</span>.</p>
</div>
<div class="example">
<p><span id="exm:logtransform" class="example"><strong>Example 2.8  </strong></span><strong>Log-transform as variance stabilisation</strong></p>
<p>Assume <span class="math inline">\(x\)</span> has some mean <span class="math inline">\(\text{E}(x)=\mu\)</span> and variance <span class="math inline">\(\text{Var}(x) = \sigma^2 \mu^2\)</span>,
i.e. the standard deviation <span class="math inline">\(\text{SD}(x)\)</span> is proportional to the mean <span class="math inline">\(\mu\)</span>.
What are the (approximate) mean and the variance of the log-transformed variable <span class="math inline">\(\log(x)\)</span>?</p>
<p>With <span class="math inline">\(h(x) = \log(x)\)</span> and <span class="math inline">\(h'(x) = \frac{1}{x}\)</span> we get using the
Delta method
<span class="math inline">\(\text{E}( \log(x) ) \approx h(\mu) = \log(\mu)\)</span> and
<span class="math inline">\(\text{Var}( \log(x) )\approx h'(\mu)^2 \text{Var}( x ) = \left(\frac{1}{\mu} \right)^2 \sigma^2 \mu^2 = \sigma^2\)</span>. Thus, after applying the log-transform the variance does not depend any more on the mean!</p>
</div>
</div>
<div id="transformation-of-a-probability-density-function-under-a-general-invertible-transformation" class="section level3" number="2.2.3">
<h3>
<span class="header-section-number">2.2.3</span> Transformation of a probability density function under a general invertible transformation<a class="anchor" aria-label="anchor" href="#transformation-of-a-probability-density-function-under-a-general-invertible-transformation"><i class="fas fa-link"></i></a>
</h3>
<p>Assume <span class="math inline">\(\boldsymbol h(\boldsymbol x) = \boldsymbol y(\boldsymbol x)\)</span> is invertible: <span class="math inline">\(\boldsymbol h^{-1}(\boldsymbol y)=\boldsymbol x(\boldsymbol y)\)</span></p>
<p><span class="math inline">\(\boldsymbol x\sim F_{\boldsymbol x}\)</span> with probability density function <span class="math inline">\(f_{\boldsymbol x}(\boldsymbol x)\)</span></p>
<p>The density <span class="math inline">\(f_{\boldsymbol y}(\boldsymbol y)\)</span> of the transformed random vector <span class="math inline">\(\boldsymbol y\)</span> is then given by<br><span class="math display">\[f_{\boldsymbol y}(\boldsymbol y) = |\det\left( D\boldsymbol x(\boldsymbol y) \right)| \,\,\,  f_{\boldsymbol x}\left( \boldsymbol x(\boldsymbol y) \right)\]</span></p>
<p>where <span class="math inline">\(D\boldsymbol x(\boldsymbol y)\)</span> is the Jacobian matrix of the inverse transformation.</p>
<p>Special cases:</p>
<ul>
<li>Univariate version: <span class="math inline">\(f_y(y) = |\frac{dx(y)}{dy}| \, f_x\left(x(y)\right)\)</span>
</li>
<li>Linear transformation <span class="math inline">\(\boldsymbol h(\boldsymbol x) = \boldsymbol a+ \boldsymbol B\boldsymbol x\)</span>, with <span class="math inline">\(\boldsymbol x(\boldsymbol y) = \boldsymbol B^{-1}(\boldsymbol y-\boldsymbol a)\)</span>
and <span class="math inline">\(D\boldsymbol x(\boldsymbol y) = \boldsymbol B^{-1}\)</span>:
<span class="math display">\[f_{\boldsymbol y}(\boldsymbol y)=|\det(\boldsymbol B)|^{-1} f_{\boldsymbol x} \left( \boldsymbol B^{-1}(\boldsymbol y-\boldsymbol a)\right)\]</span>
</li>
</ul>
</div>
<div id="normalising-flows" class="section level3" number="2.2.4">
<h3>
<span class="header-section-number">2.2.4</span> Normalising flows<a class="anchor" aria-label="anchor" href="#normalising-flows"><i class="fas fa-link"></i></a>
</h3>
<p>In this module we will focus mostly on linear transformations as these underpin
much of classical multivariate statistics, but it is important to keep in mind for later study
the importance of nonlinear transformations</p>
<p>In machine learning (sequences of) invertible nonlinear transformations are known as “normalising flows”. They are used both in a generative way (building complex models from
simple models) and for simplification and dimension reduction.</p>
<p>If you are interested in normalising flows then a good start to learn more are the review papers
by Kobyzev et al (2021 )<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;Kobyzev et al. 2021. &lt;em&gt;Normalizing Flows: Introduction and Ideas&lt;/em&gt;.
&lt;a href="https://doi.org/10.1109/TPAMI.2020.2992934"&gt;IEEE Trans. Pattern Anal. Mach. Intell. &lt;strong&gt;43&lt;/strong&gt;:3964-3979&lt;/a&gt;&lt;/p&gt;'><sup>3</sup></a> and Papamakarios et al. (2021).<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;Papamakarios et al. 2021. &lt;em&gt;Normalizing Flows for Probabilistic Modeling and Inference&lt;/em&gt;.&lt;br&gt;&lt;a href="https://jmlr.csail.mit.edu/papers/v22/19-1028.html"&gt;JMLR &lt;strong&gt;22&lt;/strong&gt;:1-64&lt;/a&gt;&lt;/p&gt;'><sup>4</sup></a></p>
</div>
</div>
<div id="whitening-transformations" class="section level2" number="2.3">
<h2>
<span class="header-section-number">2.3</span> Whitening transformations<a class="anchor" aria-label="anchor" href="#whitening-transformations"><i class="fas fa-link"></i></a>
</h2>
<div id="overview" class="section level3" number="2.3.1">
<h3>
<span class="header-section-number">2.3.1</span> Overview<a class="anchor" aria-label="anchor" href="#overview"><i class="fas fa-link"></i></a>
</h3>
<p>The <em>Mahalanobis</em> transform (also know as “zero-phase component analysis” or short ZCA transform in machine learning) is a specific example of a <strong>whitening transformation</strong>. These constitute an important and widely used class of invertible location-scale transformations.</p>
<p><em>Terminology:</em> whitening refers to the fact that after the transformation the covariance matrix is spherical, isotrop, white (<span class="math inline">\(\boldsymbol I_d\)</span>)</p>
<p>Whitening is <strong>useful in preprocessing</strong>, to <strong>turn multivariate problems into simple univariate models</strong> and some <strong>reduce the dimension in an optimal way</strong>.</p>
<p>In so-called latent variable models whitening procedures link observed and latent variables (which usually are uncorrelated and standardised random variables):</p>
<p><span class="math display">\[\begin{align*}
\begin{array}{cl}
\text{Whitening} \\
\downarrow
\end{array}
\begin{array}{ll}
\boldsymbol x\\
\uparrow \\
\boldsymbol z\\
\end{array}
\begin{array}{ll}
\text{Observed variable (can be measured)} \\
\text{external, typically correlated} \\
\space \\
\text{Unobserved "latent" variable (cannot be directly measured)} \\
\text{internal, typically chosen to be uncorrelated} \\
\end{array}
\end{align*}\]</span></p>
</div>
<div id="general-whitening-transformation" class="section level3" number="2.3.2">
<h3>
<span class="header-section-number">2.3.2</span> General whitening transformation<a class="anchor" aria-label="anchor" href="#general-whitening-transformation"><i class="fas fa-link"></i></a>
</h3>
<p><strong>Starting point:</strong></p>
<p>Random vector <span class="math inline">\(\boldsymbol x\sim F_{\boldsymbol x}\)</span> (not necessarily from multivariate normal).</p>
<p>The random variance <span class="math inline">\(\boldsymbol x\)</span> has some mean <span class="math inline">\(\text{E}(\boldsymbol z)=\boldsymbol \mu\)</span> and a positive definite (invertible) covariance matrix <span class="math inline">\(\text{Var}(\boldsymbol x) = \boldsymbol \Sigma\)</span>.
The covariance can be split into positive variances <span class="math inline">\(\boldsymbol V\)</span> and a
positive definite invertible correlation matrix <span class="math inline">\(\boldsymbol P\)</span> so that <span class="math inline">\(\boldsymbol \Sigma= \boldsymbol V^{1/2} \boldsymbol P\boldsymbol V^{1/2}\)</span>.</p>
<p><strong>Whitening transformation:</strong></p>
<p><span class="math display">\[\underbrace{\boldsymbol z}_{d \times 1 \text{ vector }} = \underbrace{\boldsymbol W}_{d \times d \text{ whitening matrix }} \underbrace{\boldsymbol x}_{d \times 1 \text{ vector }}\]</span>
<strong>Objective</strong>: choose <span class="math inline">\(\boldsymbol W\)</span> so that <span class="math inline">\(\text{Var}(\boldsymbol z)=\boldsymbol I_d\)</span></p>
<p>For Mahalanobis/ZCA whitening we already know that <span class="math inline">\(\boldsymbol W^{\text{ZCA}}=\boldsymbol \Sigma^{-1/2}\)</span>.</p>
<p>In general, the whitening matrix <span class="math inline">\(\boldsymbol W\)</span> needs to satisfy a constraint:
<span class="math display">\[
\begin{array}{lll}
                &amp; \text{Var}(\boldsymbol z) &amp; = \boldsymbol I_d \\
\Longrightarrow &amp; \text{Var}(\boldsymbol W\boldsymbol x) &amp;= \boldsymbol W\boldsymbol \Sigma\boldsymbol W^T = \boldsymbol I_d \\
\Longrightarrow &amp;  \boldsymbol W\, \boldsymbol \Sigma\, \boldsymbol W^T \boldsymbol W= \boldsymbol W&amp; \\
\end{array}
\]</span>
<span class="math display">\[\Longrightarrow \text{constraint on whitening matrix: } \boldsymbol W^T \boldsymbol W= \boldsymbol \Sigma^{-1}\]</span></p>
<p>Clearly, the ZCA whitening matrix satisfies this constraint: <span class="math inline">\((\boldsymbol W^{ZCA})^T \boldsymbol W^{ZCA} = \boldsymbol \Sigma^{-1/2}\boldsymbol \Sigma^{-1/2}=\boldsymbol \Sigma^{-1}\)</span></p>
<p><strong>Covariance-based parameterisation of whitening matrix:</strong></p>
<p>A general way to specify a valid whitening matrix is
<span class="math display">\[
\boldsymbol W= \boldsymbol Q_1 \boldsymbol \Sigma^{-1/2}
\]</span>
where <span class="math inline">\(\boldsymbol Q_1\)</span> is an orthogonal matrix.<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;In this Chapter we will make frequent use of orthogonal matrices. Please check Appendix A on matrices to review their most importantant properties!&lt;/p&gt;"><sup>5</sup></a></p>
<p>Recall that an orthogonal matrix <span class="math inline">\(\boldsymbol Q\)</span> has the property that <span class="math inline">\(\boldsymbol Q^{-1} = \boldsymbol Q^T\)</span> and
and as a consequence <span class="math inline">\(\boldsymbol Q^T \boldsymbol Q= \boldsymbol Q\boldsymbol Q^T = \boldsymbol I\)</span>.</p>
<p>As a result, the above <span class="math inline">\(\boldsymbol W\)</span> satisfies the whitening constraint:</p>
<p><span class="math display">\[\boldsymbol W^T \boldsymbol W= \boldsymbol \Sigma^{-1/2}\underbrace{\boldsymbol Q_1^T \boldsymbol Q_1}_{\boldsymbol I}\boldsymbol \Sigma^{-1/2}=\boldsymbol \Sigma^{-1}\]</span></p>
<p>Note the converse is also true: any whitening whitening matrix, i.e. any <span class="math inline">\(\boldsymbol W\)</span> satisfying the whitening constraint, can be written in the above form as
<span class="math inline">\(\boldsymbol Q_1 = \boldsymbol W\boldsymbol \Sigma^{1/2}\)</span> is orthogonal by construction.</p>
<p><span class="math inline">\(\Longrightarrow\)</span> instead of choosing <span class="math inline">\(\boldsymbol W\)</span>, <strong>we choose the orthogonal matrix</strong> <span class="math inline">\(\boldsymbol Q_1\)</span>!</p>
<ul>
<li>recall that orthogonal matrices geometrically represent rotations (plus reflections).</li>
<li>it is now clear that there are infinitely many whitening procedures, because there are infinitely many rotations! This also means we need to find ways to choose/select among whitening procedures.</li>
<li>for the Mahalanobis/ZCA transformation <span class="math inline">\(\boldsymbol Q_1^{\text{ZCA}}=\boldsymbol I\)</span>
</li>
<li>
<strong>whitening</strong> can be interpreted as <strong>Mahalanobis transform</strong> followed by <strong>rotation</strong>
</li>
</ul>
<p><strong>Correlation-based parameterisation of whitening matrix:</strong></p>
<p>Instead of working with the covariance matrix <span class="math inline">\(\boldsymbol \Sigma\)</span>, we can express <span class="math inline">\(\boldsymbol W\)</span> also in terms of the corresponding correlation matrix <span class="math inline">\(\boldsymbol P= (\rho_{ij}) = \boldsymbol V^{-1/2} \boldsymbol \Sigma\boldsymbol V^{-1/2}\)</span>
where <span class="math inline">\(\boldsymbol V^{1/2}\)</span> is the diagonal matrix containing the variances.</p>
<p>Specifically we can specify the whitening matrix as
<span class="math display">\[\boldsymbol W= \boldsymbol Q_2 \boldsymbol P^{-1/2} \boldsymbol V^{-1/2}\]</span></p>
<p>It is easy to verify that this <span class="math inline">\(\boldsymbol W\)</span> also satisfies the whitening constraint:
<span class="math display">\[
\begin{split}
\boldsymbol W^T \boldsymbol W&amp; = \boldsymbol V^{-1/2}\boldsymbol P^{-1/2}\underbrace{\boldsymbol Q_2^T \boldsymbol Q_2}_{\boldsymbol I}\boldsymbol P^{-1/2} \boldsymbol V^{-1/2} \\
&amp; = \boldsymbol V^{-1/2} \boldsymbol P^{-1} \boldsymbol V^{-1/2} = \boldsymbol \Sigma^{-1} \\
\end{split}
\]</span>
Conversely, any whitening matrix <span class="math inline">\(\boldsymbol W\)</span> can also be written in this form as
<span class="math inline">\(\boldsymbol Q_2 = \boldsymbol W\boldsymbol V^{1/2} \boldsymbol P^{1/2}\)</span> is orthogonal by construction.</p>
<ul>
<li>
<strong>Another interpretation of whitening</strong>: first <strong>standardising</strong> (<span class="math inline">\(\boldsymbol V^{-1/2}\)</span>), then <strong>decorrelation</strong> (<span class="math inline">\(\boldsymbol P^{-1/2}\)</span>), followed by <strong>rotation</strong> (<span class="math inline">\(\boldsymbol Q_2\)</span>)</li>
<li>for Mahalanobis/ZCA transformation <span class="math inline">\(\boldsymbol Q_2^{\text{ZCA}} = \boldsymbol \Sigma^{-1/2} \boldsymbol V^{1/2} \boldsymbol P^{1/2}\)</span>
</li>
</ul>
<p><strong>Both forms to write <span class="math inline">\(\boldsymbol W\)</span> using <span class="math inline">\(\boldsymbol Q_1\)</span> and <span class="math inline">\(\boldsymbol Q_2\)</span> are equally valid (and interchangeable).</strong></p>
<p>Note that for the same <span class="math inline">\(\boldsymbol W\)</span>
<span class="math display">\[\boldsymbol Q_1\neq\boldsymbol Q_2 \text{  Two different orthogonal matrices!}\]</span>
and also
<span class="math display">\[\underbrace{\boldsymbol \Sigma^{-1/2}}_{\text{Symmetric}}\neq\underbrace{\boldsymbol P^{-1/2}\boldsymbol V^{-1/2}}_{\text{Not Symmetric}}\]</span>
even though<br><span class="math display">\[\boldsymbol \Sigma^{-1/2}\boldsymbol \Sigma^{-1/2}=\boldsymbol \Sigma^{-1} = \boldsymbol V^{-1/2}\boldsymbol P^{-1/2}\boldsymbol P^{-1/2}\boldsymbol V^{-1/2}\]</span></p>
</div>
<div id="cross-covariance-and-cross-correlation-for-whitening-transformations" class="section level3" number="2.3.3">
<h3>
<span class="header-section-number">2.3.3</span> Cross-covariance and cross-correlation for whitening transformations<a class="anchor" aria-label="anchor" href="#cross-covariance-and-cross-correlation-for-whitening-transformations"><i class="fas fa-link"></i></a>
</h3>
<p>A useful criterion to characterise and to distinguish among whitening transformations is the
cross-covariance and cross-correlation matrix between the whitened variable <span class="math inline">\(\boldsymbol z\)</span> and
the original variable <span class="math inline">\(\boldsymbol x\)</span>:</p>
<ol style="list-style-type: lower-alpha">
<li>
<p><strong>Cross-covariance</strong> <span class="math inline">\(\boldsymbol \Phi= \Sigma_{\boldsymbol z\boldsymbol x}\)</span> between <span class="math inline">\(\boldsymbol z\)</span> and <span class="math inline">\(\boldsymbol x\)</span>:
<span class="math display">\[
\begin{split}
\boldsymbol \Phi= \text{Cov}(\boldsymbol z,\boldsymbol x) &amp; = \text{Cov}(\boldsymbol W\boldsymbol x,\boldsymbol x)\\
&amp; = \boldsymbol W\boldsymbol \Sigma\\
&amp;= \boldsymbol Q_1 \boldsymbol \Sigma^{-1/2} \boldsymbol \Sigma\\
&amp;= \boldsymbol Q_1\boldsymbol \Sigma^{1/2} \\
\end{split}
\]</span>
In component notation we write <span class="math inline">\(\boldsymbol \Phi= (\phi_{ij})\)</span> where the row index <span class="math inline">\(i\)</span>
refers to <span class="math inline">\(\boldsymbol z\)</span> and the column index <span class="math inline">\(j\)</span> to <span class="math inline">\(\boldsymbol x\)</span>.</p>
<p><strong>Cross-covariance is linked with</strong> <span class="math inline">\(\boldsymbol Q_1\)</span>!
Thus, choosing cross-covariance determines <span class="math inline">\(\boldsymbol Q_1\)</span> (and vice versa).</p>
<p>Note that the above cross-covariance matrix <span class="math inline">\(\boldsymbol \Phi\)</span> satisfies the condition
<span class="math inline">\(\boldsymbol \Phi^T \boldsymbol \Phi= \boldsymbol \Sigma\)</span>, which is reminiscent of the condition for <span class="math inline">\(\boldsymbol W\)</span>,
only that now the covariance is used rather than the inverse covariance.</p>
<p>The whitening matrix expressed in terms of cross-covariance is <span class="math inline">\(\boldsymbol W= \boldsymbol \Phi\boldsymbol \Sigma^{-1}\)</span>, so as required <span class="math inline">\(\boldsymbol W^T \boldsymbol W= \boldsymbol \Sigma^{-1} \boldsymbol \Phi^T \boldsymbol \Phi\boldsymbol \Sigma^{-1} =\boldsymbol \Sigma^{-1}\)</span>.
Furthermore, the transpose of <span class="math inline">\(\boldsymbol \Phi\)</span> is
the <em>inverse</em> of the whitening matrix,
as <span class="math inline">\(\boldsymbol W^{-1} = \left(\boldsymbol Q_1 \boldsymbol \Sigma^{-1/2} \right)^{-1} = \boldsymbol \Sigma^{1/2} \boldsymbol Q_1^{-1} = \boldsymbol \Sigma^{1/2} \boldsymbol Q_1^{T} = \left( \boldsymbol Q_1 \boldsymbol \Sigma^{1/2} \right)^{T} = \boldsymbol \Phi^T\)</span>.</p>
</li>
<li>
<p><strong>Cross-correlation</strong> <span class="math inline">\(\boldsymbol \Psi= \boldsymbol P_{\boldsymbol z\boldsymbol x}\)</span> between <span class="math inline">\(\boldsymbol z\)</span> and <span class="math inline">\(\boldsymbol x\)</span>:
<span class="math display">\[
\begin{split}
\boldsymbol \Psi= \text{Cor}(\boldsymbol z,\boldsymbol x) &amp; = \boldsymbol \Phi\boldsymbol V^{-1/2}\\
&amp; = \boldsymbol W\boldsymbol \Sigma\boldsymbol V^{-1/2}\\
&amp;=\boldsymbol Q_2 \boldsymbol P^{-1/2} \boldsymbol V^{-1/2} \boldsymbol \Sigma\boldsymbol V^{-1/2} \\
&amp; =  \boldsymbol Q_2\boldsymbol P^{1/2}\\
\end{split}
\]</span></p>
<p>In component notation we write <span class="math inline">\(\boldsymbol \Psi= (\psi_{ij})\)</span> where the row index <span class="math inline">\(i\)</span>
refers to <span class="math inline">\(\boldsymbol z\)</span> and the column index <span class="math inline">\(j\)</span> to <span class="math inline">\(\boldsymbol x\)</span>.</p>
<p><strong>Cross-correlation is linked with</strong> <span class="math inline">\(\boldsymbol Q_2\)</span>!
Hence, choosing cross-correlation determines <span class="math inline">\(\boldsymbol Q_2\)</span> (and vice versa). The whitening
matrix expressed in terms of cross-correlation is
<span class="math inline">\(\boldsymbol W= \boldsymbol \Psi\boldsymbol P^{-1} \boldsymbol V^{-1/2}\)</span>.</p>
</li>
</ol>
<p>Note that the factorisation of the cross-covariance <span class="math inline">\(\boldsymbol \Phi=\boldsymbol Q_1\boldsymbol \Sigma^{1/2}\)</span> and
the cross-correlation <span class="math inline">\(\boldsymbol \Psi=\boldsymbol Q_2\boldsymbol P^{1/2}\)</span> into the product of an orthogonal matrix
and a positive semi-definite symmetric matrix are examples of a <strong>polar decomposition</strong>.</p>
</div>
<div id="inverse-whitening-transformation-and-loadings" class="section level3" number="2.3.4">
<h3>
<span class="header-section-number">2.3.4</span> Inverse whitening transformation and loadings<a class="anchor" aria-label="anchor" href="#inverse-whitening-transformation-and-loadings"><i class="fas fa-link"></i></a>
</h3>
<p><strong>Inverse transformation:</strong></p>
<p>Recall that <span class="math inline">\(\boldsymbol z= \boldsymbol W\boldsymbol x\)</span>. Therefore, the reverse transformation going from the whitened
to the original variable is <span class="math inline">\(\boldsymbol x= \boldsymbol W^{-1} \boldsymbol z\)</span>.
This can be expressed also in terms of cross-covariance and cross-correlation.
With <span class="math inline">\(\boldsymbol W^{-1} = \boldsymbol \Phi^T\)</span> we get
<span class="math display">\[
\boldsymbol x= \boldsymbol \Phi^T \boldsymbol z\, .
\]</span>
Furthermore, since <span class="math inline">\(\boldsymbol \Psi= \boldsymbol \Phi\boldsymbol V^{-1/2}\)</span> we have
<span class="math inline">\(\boldsymbol W^{-1} = \boldsymbol V^{1/2} \boldsymbol \Psi^T\)</span> and
<span class="math display">\[
\boldsymbol V^{-1/2} \boldsymbol x=   \boldsymbol \Psi^T \boldsymbol z\, .
\]</span></p>
<p>The reverse whitening transformation is also known as colouring transformation
(the previously discussed inverse Mahalanobis transform is one example).</p>
<p><strong>Definition of loadings:</strong></p>
<p><em>Loadings</em> are the coefficients of the linear transformation from the latent variable back to the observed variable. If the variables are standardised to unit variance then the loadings are also called <em>correlation loadings</em>.</p>
<p>Hence, the cross-covariance matrix plays the role of <em>loadings</em> linking the latent variable <span class="math inline">\(\boldsymbol z\)</span>
with the original <span class="math inline">\(\boldsymbol x\)</span>. Similarly, the cross-correlation matrix are the <em>correlation loadings</em>
linking the (already standardised) latent variable <span class="math inline">\(\boldsymbol z\)</span> with the standardised <span class="math inline">\(\boldsymbol x\)</span>.</p>
<p><strong>Multiple correlation coefficients from <span class="math inline">\(\boldsymbol z\)</span> back to <span class="math inline">\(\boldsymbol x\)</span>:</strong></p>
<p>Consider the backtransformation from the whitened variable <span class="math inline">\(\boldsymbol z\)</span> to the original variables <span class="math inline">\(\boldsymbol x\)</span>.
Note in particular that the components of <span class="math inline">\(\boldsymbol z\)</span> are all uncorrelated. Therefore, we can compute the squared multiple correlation coefficient between each <span class="math inline">\(x_j\)</span> and <span class="math inline">\(\boldsymbol z\)</span>
simply as the sum of the squared correlations
<span class="math inline">\(\text{Cor}(z_i, x_j)^2\)</span>:
<span class="math display">\[
\text{Cor}(\boldsymbol z, x_j)^2 = \sum_{i=1}^d  \text{Cor}(z_i, x_j)^2    = \sum_{i=1}^d \psi_{ij}^2
\]</span>
In vector notation with <span class="math inline">\(\boldsymbol \Psi= (\psi_{ij})\)</span> we get
<span class="math display">\[
\begin{split}
\left(\text{Cor}(\boldsymbol z, x_1)^2, \ldots, \text{Cor}(\boldsymbol z, x_d)^2 \right)^T &amp;= \text{Diag}\left(\boldsymbol \Psi^T \boldsymbol \Psi\right) \\
&amp;= \text{Diag}\left(\boldsymbol P^{1/2} \boldsymbol Q_2^T \boldsymbol Q_2\boldsymbol P^{1/2}\right) \\
&amp;= \text{Diag}(\boldsymbol P) \\
&amp;= (1, \ldots, 1)^T\\
\end{split}
\]</span>
Therefore, for a whitening transformation, the column sums of the matrix <span class="math inline">\((\psi_{ij}^2)\)</span> are all 1 regardless of the choice of <span class="math inline">\(\boldsymbol Q_2\)</span>:
<span class="math display">\[
\sum_{i=1}^d \psi_{ij}^2 = 1 \text{ for all } j
\]</span></p>
</div>
<div id="summaries-of-cross-covariance-boldsymbol-phi-and-cross-correlation-boldsymbol-psi-resulting-from-whitening-transformations" class="section level3" number="2.3.5">
<h3>
<span class="header-section-number">2.3.5</span> Summaries of cross-covariance <span class="math inline">\(\boldsymbol \Phi\)</span> and cross-correlation <span class="math inline">\(\boldsymbol \Psi\)</span> resulting from whitening transformations<a class="anchor" aria-label="anchor" href="#summaries-of-cross-covariance-boldsymbol-phi-and-cross-correlation-boldsymbol-psi-resulting-from-whitening-transformations"><i class="fas fa-link"></i></a>
</h3>
<p><strong>Matrix trace:</strong></p>
<p>A simply summary of a matrix is its trace. For the cross-covariance matrix <span class="math inline">\(\boldsymbol \Phi\)</span> the trace is
the sum of all covariances between corresponding elements in <span class="math inline">\(\boldsymbol z\)</span> and <span class="math inline">\(\boldsymbol x\)</span>:
<span class="math display">\[
\text{Tr}(\boldsymbol \Phi) =  \sum_{i=1}^d \text{Cov}(z_i, x_i) =  \sum_{i=1}^d  \phi_{ii} = \text{Tr}\left(\boldsymbol Q_1\boldsymbol \Sigma^{1/2}\right)
\]</span>
Likewise, for the cross-correlation matrix <span class="math inline">\(\boldsymbol \Psi\)</span> the trace is
the sum of all correlations between corresponding elements in <span class="math inline">\(\boldsymbol z\)</span> and <span class="math inline">\(\boldsymbol x\)</span>:
<span class="math display">\[
\text{Tr}(\boldsymbol \Psi) =  \sum_{i=1}^d \text{Cor}(z_i, x_i) =  \sum_{i=1}^d  \psi_{ii} = \text{Tr}\left(\boldsymbol Q_2\boldsymbol P^{1/2}\right)
\]</span></p>
<p>In both cases the value of the trace depends on <span class="math inline">\(\boldsymbol Q_1\)</span> and <span class="math inline">\(\boldsymbol Q_2\)</span>.
Interestingly, there is unique choice of these orthogonal matrices such that the trace is maximised.</p>
<p>Specifically, to maximise <span class="math inline">\(\text{Tr}(\boldsymbol \Phi)\)</span> we conduct the following steps:</p>
<ol style="list-style-type: lower-roman">
<li>Apply eigendecomposition to <span class="math inline">\(\boldsymbol \Sigma= \boldsymbol U\boldsymbol \Lambda\boldsymbol U^T\)</span>. Note that <span class="math inline">\(\boldsymbol \Lambda\)</span> is diagonal with positive eigenvalues <span class="math inline">\(\lambda_i &gt; 0\)</span> as <span class="math inline">\(\boldsymbol \Sigma\)</span> is positive definite and <span class="math inline">\(\boldsymbol U\)</span> is an orthogonal matrix.</li>
<li>The objective function becomes
<span class="math display">\[
\begin{split}
\text{Tr}(\boldsymbol \Phi) &amp;= \text{Tr}\left(\boldsymbol Q_1\boldsymbol \Sigma^{1/2}\right)\\
&amp;= \text{Tr}\left(\boldsymbol Q_1 \boldsymbol U\boldsymbol \Lambda^{1/2} \boldsymbol U^T  \right) \\
&amp;= \text{Tr}\left(\boldsymbol \Lambda^{1/2} \, \boldsymbol U^T \boldsymbol Q_1 \boldsymbol U\right) \\
&amp; = \text{Tr}\left(\boldsymbol \Lambda^{1/2} \, \boldsymbol B\right) \\
&amp; = \sum_{i=1}^d \lambda_i^{1/2} b_{ii}.
\end{split} 
\]</span>
Note that the product of two orthogonal matrices is itself an orthogonal matrix.
Therefore, <span class="math inline">\(\boldsymbol B= \boldsymbol U^T \boldsymbol Q_1 \boldsymbol U\)</span> is an orthogonal matrix and
<span class="math inline">\(\boldsymbol Q_1 = \boldsymbol U\boldsymbol B\boldsymbol U^T\)</span>.</li>
<li>As <span class="math inline">\(\lambda_i &gt; 0\)</span> and all <span class="math inline">\(b_{ii} \in [-1, 1]\)</span> the objective function is maximised
for <span class="math inline">\(b_{ii}=1\)</span>, i.e. for <span class="math inline">\(\boldsymbol B=\boldsymbol I\)</span>.</li>
<li>In turn this implies that <span class="math inline">\(\text{Tr}(\boldsymbol \Phi)\)</span> is maximised for <span class="math inline">\(\boldsymbol Q_1=\boldsymbol I\)</span>.</li>
</ol>
<p>Similary, to maximise <span class="math inline">\(\text{Tr}(\boldsymbol \Psi)\)</span> we</p>
<ul>
<li>decompose <span class="math inline">\(\boldsymbol P= \boldsymbol G\boldsymbol \Theta\boldsymbol G^T\)</span> and then, following the above,<br>
</li>
<li>find that <span class="math inline">\(\text{Tr}(\boldsymbol \Psi) = \text{Tr}\left(\boldsymbol \Theta^{1/2} \, \boldsymbol G^T \boldsymbol Q_2 \boldsymbol G\right)\)</span> is maximised for <span class="math inline">\(\boldsymbol Q_2=\boldsymbol I\)</span>.</li>
</ul>
<p><strong>Frobenius norm and total variation:</strong></p>
<p>Another way to summarise and dissect the association between <span class="math inline">\(\boldsymbol x\)</span> and the corresponding whitened <span class="math inline">\(\boldsymbol z\)</span>
is the Frobenius norm and the total variation based on <span class="math inline">\(\boldsymbol \Phi\)</span> and <span class="math inline">\(\boldsymbol \Psi\)</span>.</p>
<p>The Frobenius norm (Euclidean) norm is the sum of squared elements of a matrix.</p>
<p>If we consider the Frobenius norm of the cross-covariance matrix, i.e. the sum of squared covariances between
<span class="math inline">\(\boldsymbol z\)</span> and <span class="math inline">\(\boldsymbol x\)</span>,
<span class="math display">\[
|| \boldsymbol \Phi||_F = \sum_{i=1}^d \sum_{j=1}^d \phi_{ij}^2 =  \text{Tr}(\boldsymbol \Phi\boldsymbol \Phi^T) = \text{Tr}( \boldsymbol \Sigma)
\]</span>
we find that this equals the <strong>total variation</strong> of <span class="math inline">\(\boldsymbol \Sigma\)</span> and that it does not depend on <span class="math inline">\(\boldsymbol Q_1\)</span>.
Likewise, computing the Frobenius norm of the cross-correlation matrix, i.e. the sum of squared correlations between
<span class="math inline">\(\boldsymbol z\)</span> and <span class="math inline">\(\boldsymbol x\)</span>,
<span class="math display">\[
|| \boldsymbol \Psi||_F  = \sum_{i=1}^d \sum_{j=1}^d \psi_{ij}^2= \text{Tr}(\boldsymbol \Psi\boldsymbol \Psi^T) =\text{Tr}( \boldsymbol P) = d
\]</span>
yields the total variation of <span class="math inline">\(\boldsymbol P\)</span> which also does not depend on <span class="math inline">\(\boldsymbol Q_2\)</span>.
Note this is because the Frobenius norm is invariant against rotations and reflections.</p>
<p><strong>Proportion of total variation:</strong></p>
<p>We can now compute the
relative contribution of each whitened component <span class="math inline">\(z_i\)</span> to the total variation.
The sum of squared covariances of <span class="math inline">\(z_i\)</span> with <span class="math inline">\(x_1, \ldots, x_d\)</span> is
<span class="math display">\[
h_i = \sum^d_{j=1}\text{Cov}(z_i,x_j)^2 = \sum^d_{j=1} \phi_{ij}^2
\]</span>
In vector notation this is written
<span class="math display">\[
\boldsymbol h= (h_1,...,h_d)^T = \text{Diag}(\boldsymbol \Phi\boldsymbol \Phi^T) = \text{Diag}\left(\boldsymbol Q_1\boldsymbol \Sigma\boldsymbol Q_1^T\right)
\]</span>
which also highlights that <span class="math inline">\(\boldsymbol h\)</span> is a function of <span class="math inline">\(\boldsymbol Q_1\)</span>.
Then
<span class="math display">\[
\frac{ h_i }{\text{Tr}( \boldsymbol \Sigma)}
\]</span>
gives the relative contribution of <span class="math inline">\(z_i\)</span> of the total variation of <span class="math inline">\(\boldsymbol \Sigma\)</span>.</p>
<p>Similarly, the sum of squared correlations of <span class="math inline">\(z_i\)</span> with <span class="math inline">\(x_1, \ldots, x_d\)</span> is
<span class="math display">\[
k_i = \sum^d_{j=1}\text{Cor}(z_i,x_j)^2 = \sum^d_{j=1} \psi_{ij}^2
\]</span>
and in vector notation
<span class="math display">\[
\boldsymbol k= (k_1,...,k_d)^T = \text{Diag}\left(\boldsymbol \Psi\boldsymbol \Psi^T\right)=\text{Diag}\left(\boldsymbol Q_2\boldsymbol P\boldsymbol Q_2^T\right)
\]</span>
yields
<span class="math display">\[
\frac{ k_i  }{\text{Tr}( \boldsymbol P)} = \frac{ k_i  }{d}
\]</span>
as relative contribution of <span class="math inline">\(z_i\)</span> to the total variation of the correlation <span class="math inline">\(\boldsymbol P\)</span>.</p>
<p>Note that in contrast to the total variation itself, the relative contributions <span class="math inline">\(h_i\)</span> and <span class="math inline">\(k_i\)</span> depend on <span class="math inline">\(\boldsymbol Q_1\)</span> and <span class="math inline">\(\boldsymbol Q_2\)</span>, respectively.</p>
<p><strong>Maximising the proportion of total variation:</strong></p>
<p>Crucially, each <span class="math inline">\(h_i\)</span> and <span class="math inline">\(k_i\)</span> is a quadratic form <span class="math inline">\(q(\boldsymbol v) = \boldsymbol v^T \boldsymbol A\boldsymbol v\)</span>
where <span class="math inline">\(\boldsymbol A\)</span> is a symmetric, real positive definite matrix and <span class="math inline">\(\boldsymbol v\)</span> is a unit length vector.
A general result from <strong>constrained optimisation of a quadratic form</strong> is that the maximum value it can take on is equal to largest eigenvalue of <span class="math inline">\(\boldsymbol A\)</span>, and conversely its smallest value is equal to the smallest eigenvalue of <span class="math inline">\(\boldsymbol A\)</span>.</p>
<p>More, generally, one can choose a set of orthonormal vectors such that
<span class="math inline">\(h_1\)</span> is maximised, then <span class="math inline">\(h_2\)</span> is maximised, and so on, with final values ordered
<span class="math inline">\(h_1 \geq h_2 \geq \ldots \geq h_d\)</span> (similary for <span class="math inline">\(k_1, k_2, \ldots, k_d\)</span>).
The optimal solution to this maximisation problem is obtained by computing
the eigendecompositions <span class="math inline">\(\boldsymbol \Sigma= \boldsymbol U\boldsymbol \Lambda\boldsymbol U^T\)</span> and <span class="math inline">\(\boldsymbol P= \boldsymbol G\boldsymbol \Theta\boldsymbol G^T\)</span>
and setting <span class="math inline">\(\boldsymbol Q_1= \boldsymbol U^T\)</span> and <span class="math inline">\(\boldsymbol Q_2= \boldsymbol G^T\)</span>, respectively. This yields
<span class="math display">\[
\boldsymbol h= (h_1,...,h_d)^T = (\lambda_1, \ldots, \lambda_d)^T
\]</span>
and
<span class="math display">\[
\boldsymbol k= (k_1,...,k_d)^T = (\theta_1, \ldots, \theta_d)^T
\]</span>
Recall that the sign (direction) of an eigenvector is undetermined. Thus, the columns signs in <span class="math inline">\(\boldsymbol U\)</span> and <span class="math inline">\(\boldsymbol G\)</span> can be freely chosen, and so there are multiple sets of orthormal
vectors that solve the maximisation problem.</p>
</div>
</div>
<div id="natural-whitening-procedures" class="section level2" number="2.4">
<h2>
<span class="header-section-number">2.4</span> Natural whitening procedures<a class="anchor" aria-label="anchor" href="#natural-whitening-procedures"><i class="fas fa-link"></i></a>
</h2>
<p>Now we discuss several strategies (maximise correlation between individual components, maximise compression, etc.) to arrive at optimal whitening transformation.</p>
<p>This leads to the following “natural” whitening transformations:</p>
<ul>
<li>
<strong>Mahalanobis</strong> whitening, also known as <strong>ZCA</strong> (zero-phase component analysis) whitening in machine learning (based on covariance)</li>
<li>
<strong>ZCA-cor</strong> whitening (based on correlation)</li>
<li>
<strong>PCA</strong> whitening (based on covariance)</li>
<li>
<strong>PCA-cor</strong> whitening (based on correlation)</li>
<li>
<strong>Cholesky</strong> whitening (based on precision or covariance matrix)</li>
</ul>
<p>Note that there are three main types (ZCA, PCA, Cholesky) with two variations each.</p>
<p>In the following <span class="math inline">\(\boldsymbol x_c = \boldsymbol x-\boldsymbol \mu_{\boldsymbol x}\)</span> and <span class="math inline">\(\boldsymbol z_c = \boldsymbol z-\boldsymbol \mu_{\boldsymbol z}\)</span> denote the mean-centered variables.</p>
<div id="zca-whitening" class="section level3" number="2.4.1">
<h3>
<span class="header-section-number">2.4.1</span> ZCA whitening<a class="anchor" aria-label="anchor" href="#zca-whitening"><i class="fas fa-link"></i></a>
</h3>
<p><em>Aim</em>: remove correlations but otherwise make sure that after whitening <span class="math inline">\(\boldsymbol z\)</span> does not differ too much from <span class="math inline">\(\boldsymbol x\)</span>. Specifically, each element <span class="math inline">\(z_i\)</span> should be as close as as possible to the corresponding element <span class="math inline">\(x_i\)</span>:
<span class="math display">\[
\begin{array}{cc}
z_1\leftrightarrow x_1 \\
z_2\leftrightarrow x_2\\
z_3\leftrightarrow x_3 \\
\vdots
\end{array}
\]</span>
One possible way to implement this is to compute the expected squared difference between the two centered random vectors <span class="math inline">\(\boldsymbol z_c\)</span> and <span class="math inline">\(\boldsymbol x_c\)</span>.</p>
<p><em>ZCA objective function</em>: minimise <span class="math inline">\(\text{E}\left((\boldsymbol z_c-\boldsymbol x_c)^T(\boldsymbol z_c-\boldsymbol x_c)\right)\)</span> to find an optimal whitening procedure.</p>
<p>The ZCA objective function can be simplified as follows:
<span class="math display">\[
\begin{split}
&amp; = \text{E}( \boldsymbol z_c^T \boldsymbol z_c ) - 2 \text{E}( \boldsymbol x_c^T \boldsymbol z_c ) + \text{E}(\boldsymbol x_c^T \boldsymbol x_c)  \\
&amp; = \text{E}( \text{Tr}( \boldsymbol z_c \boldsymbol z_c^T ) ) - 2 \text{E}( \text{Tr}( \boldsymbol z_c \boldsymbol x_c^T ) ) +
 \text{E}(  \text{Tr}( \boldsymbol x_c \boldsymbol x_c^T ) )  \\
&amp; = \text{Tr}( \text{E}( \boldsymbol z_c \boldsymbol z_c^T ) ) - 2 \text{Tr}( \text{E}(  \boldsymbol z_c \boldsymbol x_c^T ) ) +
 \text{Tr}(  \text{E}( \boldsymbol x_c \boldsymbol x_c^T ) )  \\
&amp; = \text{Tr}( \text{Var}(\boldsymbol z) ) - 2 \text{Tr}( \text{Cov}(\boldsymbol z, \boldsymbol x) ) + \text{Tr}( \text{Var}(\boldsymbol x) )   \\
&amp; = d - 2\text{Tr}(\boldsymbol \Phi)+\text{Tr}(\boldsymbol V) \\
\end{split}
\]</span>
The only term that depends on the whitening transformation is <span class="math inline">\(-2 \text{Tr}(\boldsymbol \Phi)\)</span> as it is a function
of <span class="math inline">\(\boldsymbol Q_1\)</span>. Therefore we can use the following
alternative objective:</p>
<p><em>ZCA equivalent objective</em>: maximise <span class="math inline">\(\text{Tr}(\boldsymbol \Phi) = \text{Tr}(\boldsymbol Q_1\boldsymbol \Sigma^{1/2})\)</span> to find the optimal <span class="math inline">\(\boldsymbol Q_1\)</span></p>
<p><em>Solution</em>:</p>
<p>From the previous discussion we know that the optimal matrix is
<span class="math display">\[
\boldsymbol Q_1^{\text{ZCA}}=\boldsymbol I
\]</span>
The corresponding whitening matrix for ZCA is therefore
<span class="math display">\[
\boldsymbol W^{\text{ZCA}} = \boldsymbol \Sigma^{-1/2}
\]</span>
and the cross-covariance matrix is
<span class="math display">\[
\boldsymbol \Phi^{\text{ZCA}} = \boldsymbol \Sigma^{1/2}
\]</span>
and the cross-correlation matrix
<span class="math display">\[
\boldsymbol \Psi^{\text{ZCA}} = \boldsymbol \Sigma^{1/2} \boldsymbol V^{-1/2}
\]</span></p>
<p>Note that <span class="math inline">\(\boldsymbol \Sigma^{1/2}\)</span> is a symmetric positive definite matrix,
hence its diagonal elements are all positive. As a result,
the diagonals of <span class="math inline">\(\boldsymbol \Phi^{\text{ZCA}}\)</span> and <span class="math inline">\(\boldsymbol \Psi^{\text{ZCA}}\)</span> are positive,
i.e. <span class="math inline">\(\text{Cov}(z_i, x_i) &gt; 0\)</span> and <span class="math inline">\(\text{Cor}(z_i, x_i) &gt; 0\)</span>.
Hence, for ZCA two corresponding components <span class="math inline">\(z_i\)</span> and <span class="math inline">\(x_i\)</span> are always positively correlated!</p>
<p><em>Proportion of total variation</em>:</p>
<p>For ZCA with <span class="math inline">\(\boldsymbol Q_1=\boldsymbol I\)</span> we find that <span class="math inline">\(\boldsymbol h=\text{Diag}(\boldsymbol \Sigma)\)</span> with <span class="math inline">\(h_i=\text{Var}(x_i)\)</span> hence for ZCA the proportion of total variation contributed by the
ZCA component <span class="math inline">\(z_i\)</span> is the ratio of the variance of the
corresponding <span class="math inline">\(x_i\)</span> and the total variation <span class="math inline">\(\text{Tr}(\boldsymbol \Sigma)\)</span>.</p>
<p><em>Summary</em>:</p>
<ul>
<li>ZCA/Mahalanobis transform is the unique transformation that minimises the expected total squared component-wise difference between <span class="math inline">\(\boldsymbol x_c\)</span> and <span class="math inline">\(\boldsymbol z_c\)</span>.</li>
<li>In ZCA corresponding components in the whitened and original variables are always positively correlated. This facilitates the interpretation of the whitened variables.</li>
<li>Use ZCA aka Mahalanobis whitening if you want to “just” remove correlations.</li>
</ul>
</div>
<div id="zca-cor-whitening" class="section level3" number="2.4.2">
<h3>
<span class="header-section-number">2.4.2</span> ZCA-Cor whitening<a class="anchor" aria-label="anchor" href="#zca-cor-whitening"><i class="fas fa-link"></i></a>
</h3>
<p><em>Aim</em>: same as above but remove scale in <span class="math inline">\(\boldsymbol x\)</span> first before comparing to <span class="math inline">\(\boldsymbol z\)</span></p>
<p><em>ZCA-cor objective function</em>: minimise <span class="math inline">\(\text{E}\left((\boldsymbol z_c-\boldsymbol V^{-1/2}\boldsymbol x_c)^T(\boldsymbol z_c-\boldsymbol V^{-1/2}\boldsymbol x_c)\right)\)</span> to find an optimal whitening procedure.</p>
<p>This can be simplified as follows:
<span class="math display">\[
\begin{split}
&amp; = \text{E}( \boldsymbol z_c^T \boldsymbol z_c ) - 2 \text{E}( \boldsymbol x_c^T \boldsymbol V^{-1/2} \boldsymbol z_c ) + \text{E}(\boldsymbol x_c^T \boldsymbol V^{-1} \boldsymbol x_c)  \\
&amp; = \text{Tr}( \text{Var}(\boldsymbol z) ) - 2 \text{Tr}( \text{Cor}(\boldsymbol z, \boldsymbol x) ) + \text{Tr}(  \text{Cor}(\boldsymbol x, \boldsymbol x) )   \\
&amp; = d - 2\text{Tr}(\boldsymbol \Psi)+ d \\
&amp; = 2d - 2\text{Tr}(\boldsymbol \Psi)
\end{split}
\]</span>
The only term that depends on the whitening transformation via <span class="math inline">\(\boldsymbol Q_2\)</span> is <span class="math inline">\(-2 \text{Tr}(\boldsymbol \Psi)\)</span> so we can use the following alternative objective instead:</p>
<p><em>ZCA-cor equivalent objective</em>: maximise <span class="math inline">\(\text{Tr}(\boldsymbol \Psi)=\text{Tr}(\boldsymbol Q_2\boldsymbol P^{1/2})\)</span> to find optimal <span class="math inline">\(\boldsymbol Q_2\)</span></p>
<p><em>Solution</em>: same as above for ZCA but using correlation instead of covariance:</p>
<p>From the previous discussion we know that the optimal matrix is
<span class="math display">\[
\boldsymbol Q_2^{\text{ZCA-Cor}}=\boldsymbol I
\]</span>
The corresponding whitening matrix for ZCA-cor is therefore
<span class="math display">\[
\boldsymbol W^{\text{ZCA-Cor}} = \boldsymbol P^{-1/2}\boldsymbol V^{-1/2}
\]</span>
and the cross-covariance matrix is
<span class="math display">\[
\boldsymbol \Phi^{\text{ZCA-Cor}} = \boldsymbol P^{1/2} \boldsymbol V^{1/2}
\]</span>
and the cross-correlation matrix is
<span class="math display">\[
\boldsymbol \Psi^{\text{ZCA-Cor}} = \boldsymbol P^{1/2}
\]</span></p>
<p>For the ZCA-cor transformation we also have
<span class="math inline">\(\text{Cov}(z_i, x_i) &gt; 0\)</span> and <span class="math inline">\(\text{Cor}(z_i, x_i) &gt; 0\)</span>
so that two corresponding components <span class="math inline">\(z_i\)</span> and <span class="math inline">\(x_i\)</span> are always positively correlated!</p>
<p><em>Proportion of total variation</em>:</p>
<p>For ZCA-cor with <span class="math inline">\(\boldsymbol Q_2=\boldsymbol I\)</span> we find that <span class="math inline">\(\boldsymbol k=\text{Diag}(\boldsymbol P)\)</span> with all <span class="math inline">\(k_i =1\)</span>.
Thus, in ZCA-cor each whitened component <span class="math inline">\(z_i\)</span> contributes equally to the total variation <span class="math inline">\(\text{Tr}(\boldsymbol P) =d\)</span>.</p>
<p><em>Summary</em>:</p>
<ul>
<li>ZCA-cor whitening is the unique whitening transformation maximising the
total correlation between corresponding elements in <span class="math inline">\(\boldsymbol x\)</span> and <span class="math inline">\(\boldsymbol z\)</span>.</li>
<li>ZCA-cor leads to interpretable <span class="math inline">\(\boldsymbol z\)</span> because each individual element in <span class="math inline">\(\boldsymbol z\)</span>
is (typically strongly) positively correlated with the corresponding element in the original <span class="math inline">\(\boldsymbol x\)</span>.</li>
<li>As ZCA-cor is explicitly constructed to maximise the total
pairwise correlations it achieves the higher correlation than ZCA.</li>
<li>If <span class="math inline">\(\boldsymbol x\)</span> is standardised to <span class="math inline">\(\text{Var}(x_i)=1\)</span> then ZCA and ZCA-cor are identical.</li>
</ul>
</div>
<div id="pca-whitening" class="section level3" number="2.4.3">
<h3>
<span class="header-section-number">2.4.3</span> PCA whitening<a class="anchor" aria-label="anchor" href="#pca-whitening"><i class="fas fa-link"></i></a>
</h3>
<p><em>Aim</em>: remove correlations and at the same compress information into a few latent variables.
Specifically, we would like that the first latent component <span class="math inline">\(z_1\)</span> is
maximally linked with all variables in <span class="math inline">\(\boldsymbol x\)</span>, followed by
the second component <span class="math inline">\(z_2\)</span> and so on:
<span class="math display">\[
\begin{array}{ccccccc}
z_1 &amp; \leftarrow x_1 &amp; &amp; z_2 &amp; \leftarrow x_1  &amp;&amp; \ldots \\
z_1 &amp; \leftarrow x_2 &amp; &amp; z_2 &amp; \leftarrow x_2  \\
\vdots\\
z_1 &amp; \leftarrow x_d &amp; &amp; z_2 &amp; \leftarrow x_d  \\
\end{array}
\]</span>
One way to measure the total association of the latent component <span class="math inline">\(z_i\)</span> with all
the observed <span class="math inline">\(x_1, \ldots, x_d\)</span> is the sum of the
corresponding squared covariances
<span class="math display">\[
h_i = \sum^d_{j=1}\text{Cov}(z_i,x_j)^2 = \sum^d_{j=1} \phi_{ij}^2
\]</span>
or equivalently
<span class="math display">\[
\boldsymbol h= (h_1,...,h_d)^T = \text{Diag}(\boldsymbol \Phi\boldsymbol \Phi^T) = \text{Diag}\left(\boldsymbol Q_1\boldsymbol \Sigma\boldsymbol Q_1^T\right)
\]</span>
which highlights that <span class="math inline">\(\boldsymbol h\)</span> is a function of <span class="math inline">\(\boldsymbol Q_1\)</span>. Each <span class="math inline">\(h_i\)</span> is the contribution
of <span class="math inline">\(z_i\)</span> to <span class="math inline">\(\sum_{i=1}^d h_i = \text{Tr}\left( \boldsymbol Q_1 \boldsymbol \Sigma\boldsymbol Q_1^T \right)= \text{Tr}(\boldsymbol \Sigma)\)</span>
i.e. the total variation based on <span class="math inline">\(\boldsymbol \Sigma\)</span>.
As <span class="math inline">\(\text{Tr}(\boldsymbol \Sigma)\)</span> is constant this implies that there are only <span class="math inline">\(d-1\)</span> independent <span class="math inline">\(h_i\)</span>.</p>
<p>In PCA-whitening we wish to concentrate most of the contributions to the total variation based
on <span class="math inline">\(\boldsymbol \Sigma\)</span> in a small number
of latent components.</p>
<p><em>PCA whitening objective function</em>: maximise <span class="math inline">\(h_1, \ldots, h_{d-1}\)</span> in <span class="math inline">\(\boldsymbol h= \text{Diag}\left(\boldsymbol Q_1\boldsymbol \Sigma\boldsymbol Q_1^T\right)\)</span> such that <span class="math inline">\(h_1 \geq h_2 \geq \dots \geq h_d\)</span>
to find an optimal optimal <span class="math inline">\(\boldsymbol Q_1\)</span> and the corresponding whitening transformation.</p>
<p><em>Solution:</em></p>
<p>Following the previous discussion (Frobenius norm on <span class="math inline">\(\boldsymbol \Phi\)</span> and on constrained optimisation of quadratic forms) the optimal
solution is obtained through eigendecomposition <span class="math inline">\(\boldsymbol \Sigma= \boldsymbol U\boldsymbol \Lambda\boldsymbol U^T\)</span>.
Hence, the optimal value for the <span class="math inline">\(\boldsymbol Q_1\)</span> matrix is
<span class="math display">\[
\boldsymbol Q_1^{\text{PCA}}=\boldsymbol U^T
\]</span>
However, recall that <span class="math inline">\(\boldsymbol U\)</span> is not uniquely defined — you are free to change the columns signs.
The corresponding whitening matrix is
<span class="math display">\[
\boldsymbol W^{\text{PCA}} = \boldsymbol U^T\boldsymbol \Sigma^{-1/2}=\boldsymbol \Lambda^{-1/2}\boldsymbol U^T
\]</span><br>
and the cross-covariance matrix is
<span class="math display">\[
\boldsymbol \Phi^{\text{PCA}} = \boldsymbol \Lambda^{1/2} \boldsymbol U^T
\]</span>
and the cross-correlation matrix is
<span class="math display">\[
\boldsymbol \Psi^{\text{PCA}} = \boldsymbol \Lambda^{1/2} \boldsymbol U^T \boldsymbol V^{-1/2}
\]</span></p>
<p><em>Identifiability:</em></p>
<p>Note that all of the above (i.e. <span class="math inline">\(\boldsymbol Q_1^{\text{PCA}}, \boldsymbol W^{\text{PCA}}, \boldsymbol \Phi^{\text{PCA}}, \boldsymbol \Psi^{\text{PCA}}\)</span>) is not unique
due to the sign ambiguity in the columns
of <span class="math inline">\(\boldsymbol U\)</span>.</p>
<p>Therefore, for identifiability reasons we need to impose a further constraint on <span class="math inline">\(\boldsymbol Q_1^{\text{PCA}}\)</span>.
A useful condition is to require a positive
diagonal, i.e. <span class="math inline">\(\text{Diag}(\boldsymbol Q_1^{\text{PCA}}) &gt; 0\)</span> and also <span class="math inline">\(\text{Diag}(\boldsymbol U) &gt; 0\)</span>.
As a result, <span class="math inline">\(\text{Diag}(\boldsymbol \Phi^{\text{PCA}}) &gt; 0\)</span> and <span class="math inline">\(\text{Diag}(\boldsymbol \Psi^{\text{PCA}}) &gt; 0\)</span>. With
this constraint in place all pairs of <span class="math inline">\(x_i\)</span> and <span class="math inline">\(z_i\)</span> are positively correlated.</p>
<p>It is particularly important to pay attention to the sign ambiguity
if different computer implementations of PCA whitening (and the related PCA approach)
are used.</p>
<p><em>Proportion of total variation:</em></p>
<p>In PCA whitening the contribution <span class="math inline">\(h_i^{\text{PCA}}\)</span> of each latent component
to the total variation based on the covariance <span class="math inline">\(\text{Tr}{\boldsymbol \Sigma} = \sum_{i=1}^d \lambda_i\)</span> is
<span class="math inline">\(h_i^{\text{PCA}} = \lambda_i\)</span>.
The fraction <span class="math inline">\(\frac{\lambda_i}{\sum^d_{j=1}\lambda_j}\)</span> is the proportional
contribution of each element in <span class="math inline">\(\boldsymbol z\)</span> to explain the total variation.</p>
<p>Thus, low ranking components <span class="math inline">\(z_i\)</span> with small <span class="math inline">\(h_i^{\text{PCA}}=\lambda_i\)</span> may be discarded.
In this way PCA whitening achieve compressions and a corresponding
reduction in dimension.</p>
<p><em>Summary:</em></p>
<ul>
<li>PCA whitening is a whitening transformation that maximises compression with the sum of squared cross-covariances as underlying optimality criterion.</li>
<li>There are sign ambiguities in the PCA whitened variables which are inherited from the sign ambiguities in eigenvectors.</li>
<li>If a positive-diagonal condition on the orthogonal matrices is imposed then these sign ambiguities are fully resolved and corresponding components <span class="math inline">\(z_i\)</span> and <span class="math inline">\(x_i\)</span> are always positively correlated.</li>
</ul>
</div>
<div id="pca-cor-whitening" class="section level3" number="2.4.4">
<h3>
<span class="header-section-number">2.4.4</span> PCA-cor whitening<a class="anchor" aria-label="anchor" href="#pca-cor-whitening"><i class="fas fa-link"></i></a>
</h3>
<p><em>Aim</em>: same as for PCA whitening but remove scale in <span class="math inline">\(\boldsymbol x\)</span> first. This means we use squared correlations rather than squared covariances to measure compression, i.e.<br><span class="math display">\[
k_i = \sum^d_{j=1}\text{Cor}(z_i, x_j)^2 = \sum^d_{j=1} \psi_{ij}^2
\]</span>
or in vector notation
<span class="math display">\[
\boldsymbol k= (k_1,...,k_d)^T = \text{Diag}\left(\boldsymbol \Psi\boldsymbol \Psi^T\right)=\text{Diag}\left(\boldsymbol Q_2\boldsymbol P\boldsymbol Q_2^T\right)
\]</span>
Each <span class="math inline">\(k_i\)</span> is the contribution
of <span class="math inline">\(z_i\)</span> to <span class="math inline">\(\sum_{i=1}^d k_i = \text{Tr}\left( \boldsymbol Q_2 \boldsymbol P\boldsymbol Q_2^T \right)= \text{Tr}(\boldsymbol P) = d\)</span>
i.e. the total variation based on <span class="math inline">\(\boldsymbol P\)</span>.
As <span class="math inline">\(\text{Tr}(\boldsymbol P)=d\)</span> is constant this implies that there are only <span class="math inline">\(d-1\)</span> independent <span class="math inline">\(k_i\)</span>.</p>
<p>In PCA-cor-whitening we wish to concentrate most of the contributions to the total variation based
on <span class="math inline">\(\boldsymbol P\)</span> in a small number
of latent components.</p>
<p><em>PCA-cor whitening objective function:</em>
maximise <span class="math inline">\(k_1, \ldots, k_{d-1}\)</span> in <span class="math inline">\(\boldsymbol k= \text{Diag}\left(\boldsymbol Q_2\boldsymbol P\boldsymbol Q_2^T\right)\)</span> such that <span class="math inline">\(k_1 \geq k_2 \geq \dots \geq k_d\)</span>
to find an optimal optimal <span class="math inline">\(\boldsymbol Q_2\)</span> and the corresponding whitening transformation.</p>
<p><em>Solution:</em></p>
<p>Following the above the optimal
solution is obtained through eigendecomposition <span class="math inline">\(\boldsymbol P= \boldsymbol G\boldsymbol \Theta\boldsymbol G^T\)</span>.
Hence, the optimal value for the <span class="math inline">\(\boldsymbol Q_2\)</span> matrix is
<span class="math display">\[
\boldsymbol Q_2^{\text{PCA-Cor}}=\boldsymbol G^T
\]</span>
Again <span class="math inline">\(\boldsymbol G\)</span> is not uniquely defined — you are free to change signs of the columns.
The corresponding whitening matrix is
<span class="math display">\[
\boldsymbol Q_2^{\text{PCA-Cor}}=\boldsymbol G^T
\]</span>
The corresponding whitening matrix is<br><span class="math display">\[
\boldsymbol W^{\text{PCA-Cor}} = \boldsymbol \Theta^{-1/2} \boldsymbol G^T \boldsymbol V^{-1/2}
\]</span><br>
and the cross-covariance matrix is
<span class="math display">\[
\boldsymbol \Phi^{\text{PCA-Cor}} = \boldsymbol \Theta^{1/2} \boldsymbol G^T \boldsymbol V^{1/2}
\]</span>
and the cross-correlation matrix is
<span class="math display">\[
\boldsymbol \Psi^{\text{PCA-Cor}} = \boldsymbol \Theta^{1/2} \boldsymbol G^T
\]</span></p>
<p><em>Identifiability:</em></p>
<p>As with PCA whitening, there are sign ambiguities in the above because the column signs of <span class="math inline">\(\boldsymbol G\)</span>
can be freely chosen. For identifiability we choose to set <span class="math inline">\(\text{Diag}(\boldsymbol Q_2^{\text{PCA-Cor}}) &gt; 0\)</span> and also
<span class="math inline">\(\text{Diag}(\boldsymbol G) &gt; 0\)</span> so that <span class="math inline">\(\text{Diag}(\boldsymbol \Phi^{\text{PCA-Cor}}) &gt; 0\)</span> and <span class="math inline">\(\text{Diag}(\boldsymbol \Psi^{\text{PCA-Cor}}) &gt; 0\)</span>.</p>
<p><em>Proportion of total variation:</em></p>
<p>In PCA-cor whitening the contribution <span class="math inline">\(k_i^{\text{PCA-Cor}}\)</span> of each latent component
to the total variation based on the correlation <span class="math inline">\(\text{Tr}{\boldsymbol P} = d\)</span> is
<span class="math inline">\(k_i^{\text{PCA-Cor}} = \theta_i\)</span>.
The fraction <span class="math inline">\(\frac{\theta_i}{d}\)</span> is the proportional
contribution of each element in <span class="math inline">\(\boldsymbol z\)</span> to explain the total variation.</p>
<p><em>Summary:</em></p>
<ul>
<li>PCA-cor whitening is a whitening transformation that maximises compression with the sum of squared cross-correlations as underlying optimality criterion.</li>
<li>There are sign ambiguities in the PCA-cor whitened variables which are inherited from the sign ambiguities in the eigenvectors.</li>
<li>If a positive-diagonal condition on the orthogonal matrices is imposed then these sign ambiguities are fully resolved and corresponding components <span class="math inline">\(z_i\)</span> and <span class="math inline">\(x_i\)</span> are always positively correlated.</li>
<li>If <span class="math inline">\(\boldsymbol x\)</span> is standardised to <span class="math inline">\(\text{Var}(x_i)=1\)</span>, then PCA and PCA-cor whitening are identical.</li>
</ul>
</div>
<div id="cholesky-whitening" class="section level3" number="2.4.5">
<h3>
<span class="header-section-number">2.4.5</span> Cholesky whitening<a class="anchor" aria-label="anchor" href="#cholesky-whitening"><i class="fas fa-link"></i></a>
</h3>
<p><strong>Cholesky matrix decomposition:</strong></p>
<p>The Cholesky decomposition of a square matrix <span class="math inline">\(\boldsymbol A= \boldsymbol L\boldsymbol L^T\)</span> requires a positive definite <span class="math inline">\(\boldsymbol A\)</span> and is unique.
<span class="math inline">\(\boldsymbol L\)</span> is a lower triangular matrix with positive diagonal elements.
Its inverse <span class="math inline">\(\boldsymbol L^{-1}\)</span> is also lower triangular with positive diagonal elements.
If <span class="math inline">\(\boldsymbol D\)</span> is a diagonal matrix with positive elements then <span class="math inline">\(\boldsymbol D\boldsymbol L\)</span> is also a lower triangular matrix with a positive
diagonal and the Cholesky factor for the matrix <span class="math inline">\(\boldsymbol D\boldsymbol A\boldsymbol D\)</span>.</p>
<p><strong>Aim in Cholesky whitening:</strong></p>
<p>Find a whitening transformation such that the cross-covariance <span class="math inline">\(\boldsymbol \Phi\)</span> and cross-correlation <span class="math inline">\(\boldsymbol \Psi\)</span> have triangular structure. This is a structural constraint that occurs for example in some models for time course data.</p>
<p>To obtain a whitening transformation we can apply the Cholesky decomposition
either to the precision matrix or to the covariance matrix. Furthermore, we can apply it to the inverse correlation or the correlation matrix.</p>
<p><em>Solution 1</em>: Apply a Cholesky decomposition to <span class="math inline">\(\boldsymbol \Sigma^{-1} = \boldsymbol L\boldsymbol L^T\)</span></p>
<p>The resulting whitening matrix is
<span class="math display">\[
\boldsymbol W^{\text{Chol}.1}=\boldsymbol L^T
\]</span><br>
By construction, <span class="math inline">\(\boldsymbol W^{\text{Chol}.1}\)</span> is an upper triangular matrix with positive
diagonal, and it clearly satisfies the whitening constraint since <span class="math inline">\((\boldsymbol W^{\text{Chol}.1})^T\boldsymbol W^{\text{Chol}.1} = \boldsymbol \Sigma^{-1}\)</span>.</p>
<p>The cross-covariance matrix is (with <span class="math inline">\(\boldsymbol \Sigma= (\boldsymbol L^{-1})^T \boldsymbol L^{-1}\)</span>)
<span class="math display">\[
\boldsymbol \Phi^{\text{Chol}.1} = \boldsymbol L^T\boldsymbol \Sigma=  \boldsymbol L^{-1}
\]</span>
and the cross-correlation matrix is
<span class="math display">\[
\boldsymbol \Psi^{\text{Chol}.1} = \boldsymbol L^T \boldsymbol \Sigma\boldsymbol V^{-1/2} =  \boldsymbol L^{-1} \boldsymbol V^{-1/2}
\]</span>
Note that both <span class="math inline">\(\boldsymbol \Phi^{\text{Chol}.1}\)</span> and
<span class="math inline">\(\boldsymbol \Psi^{\text{Chol}.1}\)</span> are
lower triangular matrices with positive diagonal elements.
Hence two corresponding components <span class="math inline">\(z_i\)</span> and <span class="math inline">\(x_i\)</span> are always positively correlated!</p>
<p>Finally, the corresponding orthogonal matrices are
<span class="math display">\[
\boldsymbol Q_1^{\text{Chol}.1} = \boldsymbol L^T \boldsymbol \Sigma^{1/2} = \boldsymbol L^{-1} \boldsymbol \Sigma^{-1/2}
\]</span>
and
<span class="math display">\[
\boldsymbol Q_2^{\text{Chol}.1} = \boldsymbol L^T \boldsymbol V^{1/2} \boldsymbol P^{1/2} = \boldsymbol L^{-1} \boldsymbol V^{-1/2} \boldsymbol P^{-1/2}
\]</span></p>
<p><em>Solution 2</em>: Apply a Cholesky decomposition to <span class="math inline">\(\boldsymbol \Sigma= \boldsymbol F\boldsymbol F^T\)</span></p>
<p>The resulting whitening matrix is
<span class="math display">\[
\boldsymbol W^{\text{Chol}.2}=\boldsymbol F^{-1}
\]</span><br>
By construction, <span class="math inline">\(\boldsymbol W^{\text{Chol}.2}\)</span> is a lower triangular matrix with positive
diagonal. The whitening constraint is satisfied as
<span class="math inline">\((\boldsymbol W^{\text{Chol}.2})^T\boldsymbol W^{\text{Chol}.2} = (\boldsymbol F^{-1})^T \boldsymbol F^{-1} = (\boldsymbol F^T)^{-1} \boldsymbol F^{-1} = (\boldsymbol F\boldsymbol F^T)^{-1} = \boldsymbol \Sigma^{-1}\)</span>.</p>
<p>The cross-covariance matrix is (recall that in general <span class="math inline">\(\boldsymbol W^{-1} = \boldsymbol \Phi^T\)</span>)
<span class="math display">\[
\boldsymbol \Phi^{\text{Chol}.2} = \boldsymbol F^T
\]</span>
and the cross-correlation matrix is
<span class="math display">\[
\boldsymbol \Psi^{\text{Chol}.2} =  \boldsymbol F^T  \boldsymbol V^{-1/2}
\]</span>
Both <span class="math inline">\(\boldsymbol \Phi^{\text{Chol}.2}\)</span> and
<span class="math inline">\(\boldsymbol \Psi^{\text{Chol}.2}\)</span> are
upper triangular matrices with positive diagonal elements.
Hence two corresponding components <span class="math inline">\(z_i\)</span> and <span class="math inline">\(x_i\)</span> are always positively correlated!</p>
<p>Finally, the corresponding orthogonal matrices are
<span class="math display">\[
\boldsymbol Q_1^{\text{Chol}.2}  = \boldsymbol F^T \boldsymbol \Sigma^{-1/2} = \boldsymbol F^{-1} \boldsymbol \Sigma^{1/2}
\]</span>
and
<span class="math display">\[
\boldsymbol Q_2^{\text{Chol}.2} = \boldsymbol F^T \boldsymbol V^{-1/2} \boldsymbol P^{-1/2} = \boldsymbol F^{-1} \boldsymbol V^{1/2} \boldsymbol P^{1/2}
\]</span></p>
<p>Note that the two Cholesky whitening procedures are different with in general
<span class="math inline">\(\boldsymbol W^{\text{Chol}.1} \neq \boldsymbol W^{\text{Chol}.2}\)</span>.</p>
<p><em>Application to correlation instead of covariance</em>:</p>
<p>We may also wish to apply Cholesky decomposition to the (inverse) correlation rather than the (inverse) covariance matrix. Intriguingly, this does <em>not</em> lead to different whitening transforms (unlike for ZCA and PCA).</p>
<p>For example, the Cholesky factor for <span class="math inline">\(\boldsymbol P^{-1} = \boldsymbol V^{1/2} \boldsymbol \Sigma^{-1} \boldsymbol V^{1/2}\)</span> is <span class="math inline">\(\boldsymbol V^{1/2} \boldsymbol L\)</span>.
The corresponding whitening matrix is <span class="math inline">\((\boldsymbol V^{1/2} \boldsymbol L)^T \boldsymbol V^{-1/2} =\boldsymbol L^T = \boldsymbol W^{\text{Chol}.1}\)</span>.</p>
<p>Similarly, the Cholesky factor for <span class="math inline">\(\boldsymbol P= \boldsymbol V^{-1/2} \boldsymbol \Sigma\boldsymbol V^{-1/2}\)</span> is <span class="math inline">\(\boldsymbol V^{-1/2} \boldsymbol F\)</span>.
The corresponding whitening matrix is <span class="math inline">\((\boldsymbol V^{-1/2} \boldsymbol F)^{-1} \boldsymbol V^{-1/2} =\boldsymbol F^{-1} = \boldsymbol W^{\text{Chol}.2}\)</span>.</p>
</div>
<div id="comparison-of-zca-pca-and-cholesky-whitening" class="section level3" number="2.4.6">
<h3>
<span class="header-section-number">2.4.6</span> Comparison of ZCA, PCA and Cholesky whitening<a class="anchor" aria-label="anchor" href="#comparison-of-zca-pca-and-cholesky-whitening"><i class="fas fa-link"></i></a>
</h3>
<p>For comparison, here are the results of ZCA, PCA and Cholesky whitening (precision matrix) applied to a simulated bivariate normal data set with correlation <span class="math inline">\(\rho=0.8\)</span>.</p>
<div class="inline-figure"><img src="2-transformations_files/figure-html/fig1-1.png" width="672"></div>
<p>In column 1 you can see the simulated data as scatter plot.</p>
<p>Column 2 shows the scatter plots of the whitened data — as expect all three methods removed correlation produce isotropic covariance.</p>
<p>The three approached differ differ in the cross-correlations. Columns 3 and 4 show the cross-correlations between the first two corresponding components (<span class="math inline">\(x_1\)</span> and <span class="math inline">\(z_1\)</span>, and <span class="math inline">\(x_2\)</span> and <span class="math inline">\(z_2\)</span>) for ZCA, PCA and Cholesky whitening. As expected, in ZCA both pairs show strong correlation, but this is not the case for PCA and Cholesky whitening.</p>
</div>
<div id="recap" class="section level3" number="2.4.7">
<h3>
<span class="header-section-number">2.4.7</span> Recap<a class="anchor" aria-label="anchor" href="#recap"><i class="fas fa-link"></i></a>
</h3>
<div class="inline-table"><table class="table table-sm">
<colgroup>
<col width="31%">
<col width="68%">
</colgroup>
<thead><tr class="header">
<th>Method</th>
<th>Type of usage</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>ZCA, ZCA-cor:</td>
<td>pure decorrelate, maintain similarity to original data set, interpretability</td>
</tr>
<tr class="even">
<td>PCA, PCA-cor:</td>
<td>compression, find effective dimension, reduce dimensionality, feature identification</td>
</tr>
<tr class="odd">
<td>Cholesky</td>
<td>time course data, triangular <span class="math inline">\(W\)</span>, <span class="math inline">\(\boldsymbol \Phi\)</span> and <span class="math inline">\(\boldsymbol \Psi\)</span>
</td>
</tr>
</tbody>
</table></div>
<p><strong>Related models not discussed in this course:</strong></p>
<ul>
<li><p>Factor models: essentially whitening plus an additional error term, factors have rotational
freedom just like in whitening</p></li>
<li><p>PLS: similar to PCA but in regression setting (with the choice of
latent variables depending on the response)</p></li>
</ul>
</div>
</div>
<div id="principal-component-analysis-pca" class="section level2" number="2.5">
<h2>
<span class="header-section-number">2.5</span> Principal Component Analysis (PCA)<a class="anchor" aria-label="anchor" href="#principal-component-analysis-pca"><i class="fas fa-link"></i></a>
</h2>
<div id="pca-transformation" class="section level3" number="2.5.1">
<h3>
<span class="header-section-number">2.5.1</span> PCA transformation<a class="anchor" aria-label="anchor" href="#pca-transformation"><i class="fas fa-link"></i></a>
</h3>
<p>Principal component analysis was proposed in 1933 by Harald Hotelling<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;Hotelling, H. 1933. Analysis of a complex of statistical variables into principal components.
Journal of Educational Psychology &lt;strong&gt;24&lt;/strong&gt;:417–441 (Part 1) and &lt;strong&gt;24&lt;/strong&gt;:498–520 (Part 2).
&lt;a href="https://doi.org/10.1037/h0071325" class="uri"&gt;https://doi.org/10.1037/h0071325&lt;/a&gt; and &lt;a href="https://doi.org/10.1037/h0070888" class="uri"&gt;https://doi.org/10.1037/h0070888&lt;/a&gt;&lt;/p&gt;'><sup>6</sup></a> and is very closely related to <strong>PCA whitening</strong>. The underlying mathematics was developed earlier in 1901 by Karl Pearson<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;Pearson, K. 1901. On lines and planes of closest fit to systems of
points in space. Philosophical Magazine &lt;strong&gt;2&lt;/strong&gt;:559–572.&lt;/p&gt;"><sup>7</sup></a> for the problem of orthogonal regression.</p>
<p>Assume random vector <span class="math inline">\(\boldsymbol x\)</span> with <span class="math inline">\(\text{Var}(\boldsymbol x) = \boldsymbol \Sigma= \boldsymbol U\boldsymbol \Lambda\boldsymbol U^T\)</span>.
PCA is a particular orthogonal transformation of the original <span class="math inline">\(\boldsymbol x\)</span>
such that the resulting components are orthogonal:
<span class="math display">\[
\underbrace{\boldsymbol t^{\text{PCA}}}_{\text{Principal components}} = \underbrace{\boldsymbol U^T}_{\text{Orthogonal matrix}}   \boldsymbol x
\]</span>
<span class="math display">\[\text{Var}(\boldsymbol t^{\text{PCA}}) = \boldsymbol \Lambda= \begin{pmatrix} \lambda_1 &amp; \dots &amp; 0 \\ \vdots &amp; \ddots &amp; \vdots \\ 0 &amp; \dots &amp; \lambda_d\end{pmatrix}\]</span>
Note that while principal components are <em>orthogonal</em> they do <em>not</em> have unit variance but the variance of principal components <span class="math inline">\(t_i\)</span> equals the eigenvalues <span class="math inline">\(\lambda_i\)</span>.</p>
<p>Thus PCA itself is <em>not</em> a whitening procedure. However, you arrive at PCA whitening by simply by standardising the PCA components: <span class="math inline">\(\boldsymbol z^{\text{PCA}} = \boldsymbol \Lambda^{-1/2} \boldsymbol t^{\text{PCA}}\)</span></p>
<p><strong>Compression properties:</strong></p>
<p>The total variation is <span class="math inline">\(\text{Tr}(\text{Var}(\boldsymbol t^{\text{PCA}})) = \text{Tr}( \boldsymbol \Lambda) = \sum^d_{j=1}\lambda_j\)</span>.
With principle components the fraction <span class="math inline">\(\frac{\lambda_i}{\sum^d_{j=1}\lambda_j}\)</span> can be interpreted as the proportion of variation contributed by
each component in <span class="math inline">\(\boldsymbol t^{\text{PCA}}\)</span> to the total variation. Thus, low ranking components in <span class="math inline">\(\boldsymbol t^{\text{PCA}}\)</span> with low variation may be discarded, thus leading to a reduction in dimension.</p>
</div>
<div id="application-to-data" class="section level3" number="2.5.2">
<h3>
<span class="header-section-number">2.5.2</span> Application to data<a class="anchor" aria-label="anchor" href="#application-to-data"><i class="fas fa-link"></i></a>
</h3>
<p>Written in terms of a data matrix <span class="math inline">\(\boldsymbol X\)</span> instead of a random vector <span class="math inline">\(\boldsymbol x\)</span> PCA becomes:
<span class="math display">\[\underbrace{\boldsymbol T}_{\text{Sample version of principal components}}=\underbrace{\boldsymbol X}_{\text{Data matrix}}\boldsymbol U\]</span>
There are now two ways to obtain <span class="math inline">\(\boldsymbol U\)</span>:</p>
<ol style="list-style-type: decimal">
<li><p>Estimate the covariance matrix, e.g. by <span class="math inline">\(\hat{\boldsymbol \Sigma} = \frac{1}{n}\boldsymbol X_c^T\boldsymbol X_c\)</span> where <span class="math inline">\(\boldsymbol X_c\)</span> is the column-centred data matrix; then apply the eigenvalue decomposition on <span class="math inline">\(\hat{\boldsymbol \Sigma}\)</span> to get <span class="math inline">\(\boldsymbol U\)</span>.</p></li>
<li><p>Compute the singular value decomposition of <span class="math inline">\(\boldsymbol X_c = \boldsymbol V\boldsymbol D\boldsymbol U^T\)</span>. As <span class="math inline">\(\hat{\boldsymbol \Sigma} = \frac{1}{n}\boldsymbol X_c^T\boldsymbol X_c = \boldsymbol U(\frac{1}{n}\boldsymbol D^2)\boldsymbol U^T\)</span> you can just use <span class="math inline">\(\boldsymbol U\)</span> from the SVD of <span class="math inline">\(\boldsymbol X_c\)</span> and there is no need to compute the covariance.</p></li>
</ol>
</div>
<div id="iris-data-example" class="section level3" number="2.5.3">
<h3>
<span class="header-section-number">2.5.3</span> Iris data example<a class="anchor" aria-label="anchor" href="#iris-data-example"><i class="fas fa-link"></i></a>
</h3>
<p>As an example we consider the famous <a href="https://en.wikipedia.org/wiki/Iris_flower_data_set">iris flower data set</a>. It consists of data for for botanical variables (sepal length, sepal width,
petal length and petal width) measured on 150 flowers from
three iris species (setosa, versicolr, virginica). Thus for this data set <span class="math inline">\(d=4\)</span> and <span class="math inline">\(n=150\)</span>.</p>
<p>We first standardise the data, then compute PCA components and plot the proportion of total variation contributed by each component.
This shows that only two PCA components are needed to achieve 95% of the total variation:</p>
<div class="inline-figure"><img src="2-transformations_files/figure-html/fig2-1.png" width="432"></div>
<p>A scatter plot plot of the the first two principal components is also informative:</p>
<div class="inline-figure"><img src="2-transformations_files/figure-html/fig3-1.png" width="432"></div>
<p>This shows that there groupings among the
150 flowers, corresponding to the species, and that these groups can be characterised
by the the principal components.</p>
</div>
</div>
<div id="correlation-loadings-plot-to-interpret-pca-components" class="section level2" number="2.6">
<h2>
<span class="header-section-number">2.6</span> Correlation loadings plot to interpret PCA components<a class="anchor" aria-label="anchor" href="#correlation-loadings-plot-to-interpret-pca-components"><i class="fas fa-link"></i></a>
</h2>
<div id="pca-correlation-loadings" class="section level3" number="2.6.1">
<h3>
<span class="header-section-number">2.6.1</span> PCA correlation loadings<a class="anchor" aria-label="anchor" href="#pca-correlation-loadings"><i class="fas fa-link"></i></a>
</h3>
<p>In an earlier section we have learned that for a general whitening transformation the cross-correlations <span class="math inline">\(\boldsymbol \Psi=\text{Cor}(\boldsymbol z, \boldsymbol x)\)</span> play the role of correlation loadings in the inverse transformation:
<span class="math display">\[
\boldsymbol V^{-1/2} \boldsymbol x= \boldsymbol \Psi^T  \boldsymbol z\, , 
\]</span>
i.e. they are the coefficients linking the whitened variable <span class="math inline">\(\boldsymbol z\)</span> with the standardised original variable <span class="math inline">\(\boldsymbol x\)</span>.
This relationship holds therefore also for PCA-whitening
with <span class="math inline">\(\boldsymbol z^{\text{PCA}}= \boldsymbol \Lambda^{-1/2} \boldsymbol U^T \boldsymbol x\)</span> and <span class="math inline">\(\boldsymbol \Psi^{\text{PCA}} = \boldsymbol \Lambda^{1/2} \boldsymbol U^T \boldsymbol V^{-1/2}\)</span>.</p>
<p>The classical PCA is not a whitening approach because <span class="math inline">\(\text{Var}(\boldsymbol t^{\text{PCA}}) \neq \boldsymbol I\)</span>. However, we can still compute cross-correlations between the principal components <span class="math inline">\(\boldsymbol t^{\text{PCA}}\)</span> and <span class="math inline">\(\boldsymbol x\)</span>, resulting in
<span class="math display">\[
\text{Cor}(\boldsymbol t^{\text{PCA}}, \boldsymbol x) = \boldsymbol \Lambda^{1/2} \boldsymbol U^T \boldsymbol V^{-1/2} = \boldsymbol \Psi^{\text{PCA}}
\]</span>
Note these are the same as the cross-correlations for PCA-whitening since
<span class="math inline">\(\boldsymbol t^{\text{PCA}}\)</span> and <span class="math inline">\(\boldsymbol z^{\text{PCA}}\)</span> only differ in scale.</p>
<p>The inverse PCA transformation is
<span class="math display">\[
\boldsymbol x= \boldsymbol U\boldsymbol t^{\text{PCA}}
\]</span>
In terms of standardised PCA components and standardised original components it becomes
<span class="math display">\[
\boldsymbol V^{-1/2} \boldsymbol x= \boldsymbol \Psi^T  \boldsymbol \Lambda^{-1/2} \boldsymbol t^{\text{PCA}}
\]</span>
Thus the cross-correlation matrix <span class="math inline">\(\boldsymbol \Psi\)</span> plays the role of <em>correlation loadings</em>
also in classical PCA, i.e. they are the
coefficients linking the standardised PCA components with the standardised original components.</p>
</div>
<div id="pca-correlation-loadings-plot" class="section level3" number="2.6.2">
<h3>
<span class="header-section-number">2.6.2</span> PCA correlation loadings plot<a class="anchor" aria-label="anchor" href="#pca-correlation-loadings-plot"><i class="fas fa-link"></i></a>
</h3>
<p>In PCA and PCA-cor whitening as well as in classical PCA the aim is compression, i.e.
to find latent variables such that most of the total variation is contributed by
a small number of components.</p>
<p>In order to be able to better interpret the top ranking PCA component we can use a visual device called <em>correlation loadings plot</em>. For this we compute the correlation between the PCA components 1 and 2 (<span class="math inline">\(t_1^{\text{PCA}}\)</span> and <span class="math inline">\(t_2^{\text{PCA}})\)</span> with all original variables <span class="math inline">\(x_1, \ldots, x_d\)</span>.</p>
<p>For each original variable <span class="math inline">\(x_j\)</span> we therefore have two numbers between -1 and 1, the correlation
<span class="math inline">\(\text{Cor}(t_1^{\text{PCA}}, x_j)\)</span> and <span class="math inline">\(\text{Cor}(t_2^{\text{PCA}}, x_j)\)</span> that we use as coordinates to draw a point in a plane. By construction, all points
have to lie within a unit circle around the origin. As the sum of the squared correlation loadings from all latent component to one specific original variable sum up to one, the sum of the squared loadings from just the first two components is also at most 1.
The original variables most strongly influenced
by the two latent variables will have strong correlation and thus lie near the outer circle, whereas variables that are not influenced by the two latent variables will lie near the origin.</p>
<p>As an example, here is the correlation loadings plot showing the cross-correlation between the first two
PCA components and all four variables of the iris flower data set discussed earlier.</p>
<div class="inline-figure"><img src="2-transformations_files/figure-html/fig4-1.png" width="432"></div>
<p>The interpretation of this plot is discussed in Worksheet 4.</p>
</div>
</div>
<div id="cca-whitening-canonical-correlation-analysis" class="section level2" number="2.7">
<h2>
<span class="header-section-number">2.7</span> CCA whitening (Canonical Correlation Analysis)<a class="anchor" aria-label="anchor" href="#cca-whitening-canonical-correlation-analysis"><i class="fas fa-link"></i></a>
</h2>
<p>Canonical correlation analysis was invented by Harald Hotelling in 1936.<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;Hotelling, H. 1936. Relations between two sets of variates.
Biometrika &lt;strong&gt;28&lt;/strong&gt;:321–377.&lt;/p&gt;"><sup>8</sup></a></p>
<p>So far, we have looked only into whitening as a <strong>single</strong> vector <span class="math inline">\(\boldsymbol x\)</span>. In CCA whitening we consider <strong>two vectors</strong> <span class="math inline">\(\boldsymbol x\)</span> and <span class="math inline">\(\boldsymbol y\)</span> simultaneously:</p>
<p><span class="math display">\[\begin{align*}
\begin{array}{ll}
\boldsymbol x= \begin{pmatrix} x_1 \\ \vdots \\ x_p \end{pmatrix} \\
\text{Dimension } p
\end{array}
\begin{array}{ll}
\boldsymbol y= \begin{pmatrix} y_1 \\ \vdots \\ y_q \end{pmatrix} \\
\text{Dimension } q
\end{array}
\begin{array}{ll}
\text{Var}(\boldsymbol x) = \boldsymbol \Sigma_{\boldsymbol x} = \boldsymbol V_{\boldsymbol x}^{1/2}\boldsymbol P_{\boldsymbol x}\boldsymbol V_{\boldsymbol x}^{1/2} \\
\text{Var}(\boldsymbol y) = \boldsymbol \Sigma_{\boldsymbol y} = \boldsymbol V_{\boldsymbol y}^{1/2}\boldsymbol P_{\boldsymbol y}\boldsymbol V_{\boldsymbol y}^{1/2} \\
\end{array}
\end{align*}\]</span></p>
<p><span class="math display">\[\begin{align*}
\begin{array}{cc}
\text{Whitening of } \boldsymbol x\text{:} \\
\text{Whitening of } \boldsymbol y\text{:}
\end{array}
\begin{array}{cc}
\boldsymbol z_{\boldsymbol x} = \boldsymbol W_{\boldsymbol x}\boldsymbol x=\boldsymbol Q_{\boldsymbol x}\boldsymbol P_{\boldsymbol x}^{-1/2}\boldsymbol V_{\boldsymbol x}^{-1/2}\boldsymbol x\\
\boldsymbol z_{\boldsymbol y} = \boldsymbol W_{\boldsymbol y}\boldsymbol y=\boldsymbol Q_{\boldsymbol y}\boldsymbol P_{\boldsymbol y}^{-1/2}\boldsymbol V_{\boldsymbol y}^{-1/2}\boldsymbol y
\end{array}
\end{align*}\]</span>
(note we use the correlation-based form of <span class="math inline">\(\boldsymbol W\)</span>)</p>
<p>Cross-correlation between <span class="math inline">\(\boldsymbol z_{\boldsymbol y}\)</span> and <span class="math inline">\(\boldsymbol z_{\boldsymbol y}\)</span>:</p>
<p><span class="math display">\[\text{Cor}(\boldsymbol z_{\boldsymbol x},\boldsymbol z_{\boldsymbol y})=\boldsymbol Q_{\boldsymbol x}\boldsymbol K\boldsymbol Q_{\boldsymbol y}^T\]</span></p>
<p>with <span class="math inline">\(\boldsymbol K= \boldsymbol P_{\boldsymbol x}^{-1/2}\boldsymbol P_{\boldsymbol x\boldsymbol y}\boldsymbol P_{\boldsymbol y}^{-1/2}\)</span>.</p>
<p><strong>Idea</strong>: we can choose suitable orthogonal matrices <span class="math inline">\(\boldsymbol Q_{\boldsymbol x}\)</span> and <span class="math inline">\(\boldsymbol Q_{\boldsymbol y}\)</span> by putting constraints on the cross-correlation.</p>
<p><strong>CCA</strong>: we aim for a <em>diagonal</em> <span class="math inline">\(\text{Cor}(\boldsymbol z_{\boldsymbol x},\boldsymbol z_{\boldsymbol y})\)</span> so that each component in <span class="math inline">\(\boldsymbol z_{\boldsymbol x}\)</span> only influences one (the corresponding) component in <span class="math inline">\(\boldsymbol z_{\boldsymbol y}\)</span>.</p>
<p><strong>Motivation</strong>: pairs of “modules” represented by components of <span class="math inline">\(\boldsymbol z_{\boldsymbol x}\)</span>
and <span class="math inline">\(\boldsymbol z_{\boldsymbol y}\)</span> influencing each other (and not anyone other module).</p>
<p><span class="math display">\[
\begin{array}{ll}
\boldsymbol z_{\boldsymbol x} = \begin{pmatrix} z^x_1 \\ z^x_2 \\ \vdots \\ z^x_p \end{pmatrix} &amp;
\boldsymbol z_{\boldsymbol y} = \begin{pmatrix} z^y_1 \\ z^y_2 \\ \vdots \\ z^y_q \end{pmatrix} \\
\end{array}
\]</span></p>
<p><span class="math display">\[\text{Cor}(\boldsymbol z_{\boldsymbol x},\boldsymbol z_{\boldsymbol y}) = \begin{pmatrix} d_1 &amp; \dots &amp; 0 \\ \vdots &amp;  \vdots \\ 0 &amp; \dots &amp; d_m \end{pmatrix}\]</span></p>
<p>where <span class="math inline">\(d_i\)</span> are the <em>canonical correlations</em> and <span class="math inline">\(m=\min(p,q)\)</span>.</p>
<div id="how-to-make-cross-correlation-matrix-textcorboldsymbol-z_boldsymbol-xboldsymbol-z_boldsymbol-y-diagonal" class="section level3" number="2.7.1">
<h3>
<span class="header-section-number">2.7.1</span> How to make cross-correlation matrix <span class="math inline">\(\text{Cor}(\boldsymbol z_{\boldsymbol x},\boldsymbol z_{\boldsymbol y})\)</span> diagonal?<a class="anchor" aria-label="anchor" href="#how-to-make-cross-correlation-matrix-textcorboldsymbol-z_boldsymbol-xboldsymbol-z_boldsymbol-y-diagonal"><i class="fas fa-link"></i></a>
</h3>
<ul>
<li>Use Singular Value Decomposition (SVD) of matrix <span class="math inline">\(\boldsymbol K\)</span>:<br><span class="math display">\[\boldsymbol K= (\boldsymbol Q_{\boldsymbol x}^{\text{CCA}})^T  \boldsymbol D\boldsymbol Q_{\boldsymbol y}^{\text{CCA}}\]</span>
where <span class="math inline">\(\boldsymbol D\)</span> is the diagonal matrix containing the singular values of <span class="math inline">\(\boldsymbol K\)</span>
</li>
<li>This yields orthogonal matrices <span class="math inline">\(\boldsymbol Q_{\boldsymbol x}^{\text{CCA}}\)</span> and <span class="math inline">\(\boldsymbol Q_{\boldsymbol y}^{\text{CCA}}\)</span> and thus the desired whitened matrices <span class="math inline">\(\boldsymbol W_{\boldsymbol x}^{\text{CCA}}\)</span> and <span class="math inline">\(\boldsymbol W_{\boldsymbol y}^{\text{CCA}}\)</span>
</li>
<li>As a result <span class="math inline">\(\text{Cor}(\boldsymbol z_{\boldsymbol x},\boldsymbol z_{\boldsymbol y}) = \boldsymbol D\)</span> i.e. singular values of <span class="math inline">\(\boldsymbol K\)</span> are identical to canonical correlations <span class="math inline">\(d_i\)</span>!</li>
</ul>
<p><span class="math inline">\(\longrightarrow\)</span> <span class="math inline">\(\boldsymbol Q_{\boldsymbol x}^{\text{CCA}}\)</span> and <span class="math inline">\(\boldsymbol Q_{\boldsymbol y}^{\text{CCA}}\)</span> are determined by the diagonality constraint (and are different to the other previously discussed whitening methods).</p>
<p>Note that the signs of corresponding in columns in <span class="math inline">\(\boldsymbol Q_{\boldsymbol x}^{\text{CCA}}\)</span> and <span class="math inline">\(\boldsymbol Q_{\boldsymbol y}^{\text{CCA}}\)</span> are not identified. Traditionally, in an SVD the
signs are chosen such that the singular values are positive. However, if we
impose positive-diagonality on <span class="math inline">\(\boldsymbol Q_{\boldsymbol x}^{\text{CCA}}\)</span> and <span class="math inline">\(\boldsymbol Q_{\boldsymbol y}^{\text{CCA}}\)</span>,
and thus positive-diagonality on the cross-correlations <span class="math inline">\(\boldsymbol \Psi_{\boldsymbol x}\)</span> and
<span class="math inline">\(\boldsymbol \Psi_{\boldsymbol y}\)</span>, then the canonical correlations may take on both positive and
negative values.</p>
</div>
<div id="related-methods" class="section level3" number="2.7.2">
<h3>
<span class="header-section-number">2.7.2</span> Related methods<a class="anchor" aria-label="anchor" href="#related-methods"><i class="fas fa-link"></i></a>
</h3>
<ul>
<li><p>O2PLS: similar to CCA but using orthogonal projections
(thus in O2PLS the latent variables underlying <span class="math inline">\(\boldsymbol x\)</span> and <span class="math inline">\(\boldsymbol y\)</span> are not orthogonal)</p></li>
<li><p>Vector correlation: aggregates the squared canonical correlations into a single overall measure
of association between two random vectors <span class="math inline">\(\boldsymbol x\)</span> and <span class="math inline">\(\boldsymbol y\)</span> (see Chapter 5
on multivariate dependencies).</p></li>
</ul>
</div>
</div>
</div>

  <div class="chapter-nav">
<div class="prev"><a href="multivariate-random-variables.html"><span class="header-section-number">1</span> Multivariate random variables</a></div>
<div class="next"><a href="unsupervised-learning-and-clustering.html"><span class="header-section-number">3</span> Unsupervised learning and clustering</a></div>
</div></main><div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <nav id="toc" data-toggle="toc" aria-label="On this page"><h2>On this page</h2>
      <ul class="nav navbar-nav">
<li><a class="nav-link" href="#transformations-and-dimension-reduction"><span class="header-section-number">2</span> Transformations and dimension reduction</a></li>
<li>
<a class="nav-link" href="#linear-transformations"><span class="header-section-number">2.1</span> Linear Transformations</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#location-scale-transformation"><span class="header-section-number">2.1.1</span> Location-scale transformation</a></li>
<li><a class="nav-link" href="#squared-multiple-correlation"><span class="header-section-number">2.1.2</span> Squared multiple correlation</a></li>
<li><a class="nav-link" href="#invertible-location-scale-transformation"><span class="header-section-number">2.1.3</span> Invertible location-scale transformation</a></li>
<li><a class="nav-link" href="#transformation-of-a-density-under-an-invertible-location-scale-transformation"><span class="header-section-number">2.1.4</span> Transformation of a density under an invertible location-scale transformation:</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#nonlinear-transformations"><span class="header-section-number">2.2</span> Nonlinear transformations</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#general-transformation"><span class="header-section-number">2.2.1</span> General transformation</a></li>
<li><a class="nav-link" href="#delta-method"><span class="header-section-number">2.2.2</span> Delta method</a></li>
<li><a class="nav-link" href="#transformation-of-a-probability-density-function-under-a-general-invertible-transformation"><span class="header-section-number">2.2.3</span> Transformation of a probability density function under a general invertible transformation</a></li>
<li><a class="nav-link" href="#normalising-flows"><span class="header-section-number">2.2.4</span> Normalising flows</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#whitening-transformations"><span class="header-section-number">2.3</span> Whitening transformations</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#overview"><span class="header-section-number">2.3.1</span> Overview</a></li>
<li><a class="nav-link" href="#general-whitening-transformation"><span class="header-section-number">2.3.2</span> General whitening transformation</a></li>
<li><a class="nav-link" href="#cross-covariance-and-cross-correlation-for-whitening-transformations"><span class="header-section-number">2.3.3</span> Cross-covariance and cross-correlation for whitening transformations</a></li>
<li><a class="nav-link" href="#inverse-whitening-transformation-and-loadings"><span class="header-section-number">2.3.4</span> Inverse whitening transformation and loadings</a></li>
<li><a class="nav-link" href="#summaries-of-cross-covariance-boldsymbol-phi-and-cross-correlation-boldsymbol-psi-resulting-from-whitening-transformations"><span class="header-section-number">2.3.5</span> Summaries of cross-covariance \(\boldsymbol \Phi\) and cross-correlation \(\boldsymbol \Psi\) resulting from whitening transformations</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#natural-whitening-procedures"><span class="header-section-number">2.4</span> Natural whitening procedures</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#zca-whitening"><span class="header-section-number">2.4.1</span> ZCA whitening</a></li>
<li><a class="nav-link" href="#zca-cor-whitening"><span class="header-section-number">2.4.2</span> ZCA-Cor whitening</a></li>
<li><a class="nav-link" href="#pca-whitening"><span class="header-section-number">2.4.3</span> PCA whitening</a></li>
<li><a class="nav-link" href="#pca-cor-whitening"><span class="header-section-number">2.4.4</span> PCA-cor whitening</a></li>
<li><a class="nav-link" href="#cholesky-whitening"><span class="header-section-number">2.4.5</span> Cholesky whitening</a></li>
<li><a class="nav-link" href="#comparison-of-zca-pca-and-cholesky-whitening"><span class="header-section-number">2.4.6</span> Comparison of ZCA, PCA and Cholesky whitening</a></li>
<li><a class="nav-link" href="#recap"><span class="header-section-number">2.4.7</span> Recap</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#principal-component-analysis-pca"><span class="header-section-number">2.5</span> Principal Component Analysis (PCA)</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#pca-transformation"><span class="header-section-number">2.5.1</span> PCA transformation</a></li>
<li><a class="nav-link" href="#application-to-data"><span class="header-section-number">2.5.2</span> Application to data</a></li>
<li><a class="nav-link" href="#iris-data-example"><span class="header-section-number">2.5.3</span> Iris data example</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#correlation-loadings-plot-to-interpret-pca-components"><span class="header-section-number">2.6</span> Correlation loadings plot to interpret PCA components</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#pca-correlation-loadings"><span class="header-section-number">2.6.1</span> PCA correlation loadings</a></li>
<li><a class="nav-link" href="#pca-correlation-loadings-plot"><span class="header-section-number">2.6.2</span> PCA correlation loadings plot</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#cca-whitening-canonical-correlation-analysis"><span class="header-section-number">2.7</span> CCA whitening (Canonical Correlation Analysis)</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#how-to-make-cross-correlation-matrix-textcorboldsymbol-z_boldsymbol-xboldsymbol-z_boldsymbol-y-diagonal"><span class="header-section-number">2.7.1</span> How to make cross-correlation matrix \(\text{Cor}(\boldsymbol z_{\boldsymbol x},\boldsymbol z_{\boldsymbol y})\) diagonal?</a></li>
<li><a class="nav-link" href="#related-methods"><span class="header-section-number">2.7.2</span> Related methods</a></li>
</ul>
</li>
</ul>

      <div class="book-extra">
        <ul class="list-unstyled">
          
        </ul>
</div>
    </nav>
</div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5"><div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong>Multivariate Statistics and Machine Learning</strong>" was written by Korbinian Strimmer. It was last built on 14 November 2021.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>This book was built by the <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer><!-- dynamically load mathjax for compatibility with self-contained --><script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script><script type="text/x-mathjax-config">const popovers = document.querySelectorAll('a.footnote-ref[data-toggle="popover"]');
for (let popover of popovers) {
  const div = document.createElement('div');
  div.setAttribute('style', 'position: absolute; top: 0, left:0; width:0, height:0, overflow: hidden; visibility: hidden;');
  div.innerHTML = popover.getAttribute('data-content');

  var has_math = div.querySelector("span.math");
  if (has_math) {
    document.body.appendChild(div);
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, div]);
    MathJax.Hub.Queue(function() {
      popover.setAttribute('data-content', div.innerHTML);
      document.body.removeChild(div);
    })
  }
}
</script>
</body>
</html>
