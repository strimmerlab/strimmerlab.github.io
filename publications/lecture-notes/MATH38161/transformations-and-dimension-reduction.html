<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>2 Transformations and dimension reduction | Multivariate Statistics and Machine Learning</title>
<meta name="author" content="Korbinian Strimmer">
<meta name="generator" content="bookdown 0.26 with bs4_book()">
<meta property="og:title" content="2 Transformations and dimension reduction | Multivariate Statistics and Machine Learning">
<meta property="og:type" content="book">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="2 Transformations and dimension reduction | Multivariate Statistics and Machine Learning">
<!-- JS --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script><script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet">
<script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script><script src="libs/bs3compat-0.3.1/transition.js"></script><script src="libs/bs3compat-0.3.1/tabs.js"></script><script src="libs/bs3compat-0.3.1/bs3compat.js"></script><link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet">
<script src="libs/bs4_book-1.0.0/bs4_book.js"></script><script src="libs/accessible-code-block-0.0.1/empty-anchor.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- CSS --><style type="text/css">
    
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  </style>
<meta name="description" content="Motivation: In the following we study transformations of random vectors and their distributions. These transformation are very important since they either transform simple distributions into more...">
<meta property="og:description" content="Motivation: In the following we study transformations of random vectors and their distributions. These transformation are very important since they either transform simple distributions into more...">
<meta name="twitter:description" content="Motivation: In the following we study transformations of random vectors and their distributions. These transformation are very important since they either transform simple distributions into more...">
</head>
<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book"><a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h1>
        <a href="index.html" title="">Multivariate Statistics and Machine Learning</a>
      </h1>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
</form>

      <nav aria-label="Table of contents"><h2>Table of contents</h2>
        <ul class="book-toc list-unstyled">
<li><a class="" href="index.html">Welcome</a></li>
<li><a class="" href="preface.html">Preface</a></li>
<li><a class="" href="multivariate-random-variables.html"><span class="header-section-number">1</span> Multivariate random variables</a></li>
<li><a class="active" href="transformations-and-dimension-reduction.html"><span class="header-section-number">2</span> Transformations and dimension reduction</a></li>
<li><a class="" href="unsupervised-learning-and-clustering.html"><span class="header-section-number">3</span> Unsupervised learning and clustering</a></li>
<li><a class="" href="supervised-learning-and-classification.html"><span class="header-section-number">4</span> Supervised learning and classification</a></li>
<li><a class="" href="multivariate-dependencies.html"><span class="header-section-number">5</span> Multivariate dependencies</a></li>
<li><a class="" href="nonlinear-and-nonparametric-models.html"><span class="header-section-number">6</span> Nonlinear and nonparametric models</a></li>
<li class="book-part">Appendix</li>
<li><a class="" href="brief-refresher-on-matrices.html"><span class="header-section-number">A</span> Brief refresher on matrices</a></li>
<li><a class="" href="further-study.html"><span class="header-section-number">B</span> Further study</a></li>
<li><a class="" href="bibliography.html">Bibliography</a></li>
</ul>

        <div class="book-extra">
          
        </div>
      </nav>
</div>
  </header><main class="col-sm-12 col-md-9 col-lg-7" id="content"><div id="transformations-and-dimension-reduction" class="section level1" number="2">
<h1>
<span class="header-section-number">2</span> Transformations and dimension reduction<a class="anchor" aria-label="anchor" href="#transformations-and-dimension-reduction"><i class="fas fa-link"></i></a>
</h1>
<p>Motivation:
In the following we study transformations of random vectors and their distributions.
These transformation are very important
since they either transform simple distributions into more complex distributions or allow to simplify
complex models. In machine learning invertible mappings of transformations
for probability distributions are known as “normalising flows”.</p>
<div id="linear-transformations" class="section level2" number="2.1">
<h2>
<span class="header-section-number">2.1</span> Linear Transformations<a class="anchor" aria-label="anchor" href="#linear-transformations"><i class="fas fa-link"></i></a>
</h2>
<div id="location-scale-transformation" class="section level3" number="2.1.1">
<h3>
<span class="header-section-number">2.1.1</span> Location-scale transformation<a class="anchor" aria-label="anchor" href="#location-scale-transformation"><i class="fas fa-link"></i></a>
</h3>
<p>Also known as affine transformation.</p>
<p><span class="math display">\[\boldsymbol y= \underbrace{\boldsymbol a}_{\text{location parameter}}+\underbrace{\boldsymbol B}_{\text{scale parameter}} \boldsymbol x\space\]</span>
<span class="math display">\[\boldsymbol y: m \times 1 \text{ random vector}\]</span>
<span class="math display">\[\boldsymbol a: m \times 1 \text{ vector, location parameter}\]</span>
<span class="math display">\[\boldsymbol B: m \times d \text{ matrix, scale parameter },  m \geq 1\]</span>
<span class="math display">\[\boldsymbol x: d \times 1 \text{ random vector}\]</span></p>
<p>Mean and variance of the original vector <span class="math inline">\(\boldsymbol x\)</span>:</p>
<p><span class="math display">\[\text{E}(\boldsymbol x)=\boldsymbol \mu_{\boldsymbol x}\]</span>
<span class="math display">\[\text{Var}(\boldsymbol x)=\boldsymbol \Sigma_{\boldsymbol x}\]</span></p>
<p>Mean and variance of the transformed random vector <span class="math inline">\(\boldsymbol y\)</span>:</p>
<p><span class="math display">\[\text{E}(\boldsymbol y)=\boldsymbol a+ \boldsymbol B\boldsymbol \mu_{\boldsymbol x}\]</span>
<span class="math display">\[\text{Var}(\boldsymbol y)= \boldsymbol B\boldsymbol \Sigma_{\boldsymbol x} \boldsymbol B^T\]</span></p>
<p>Cross-covariance <span class="math inline">\(\boldsymbol \Phi= \Sigma_{\boldsymbol x\boldsymbol y}\)</span> between <span class="math inline">\(\boldsymbol x\)</span> and <span class="math inline">\(\boldsymbol y\)</span>:
<span class="math display">\[
\boldsymbol \Phi= \text{Cov}(\boldsymbol x, \boldsymbol y) = \text{Cov}(\boldsymbol x, \boldsymbol B\boldsymbol x) = \boldsymbol \Sigma_{\boldsymbol x}  \boldsymbol B^T 
\]</span></p>
<p>Cross-correlation <span class="math inline">\(\boldsymbol \Psi= \boldsymbol P_{\boldsymbol x\boldsymbol y}\)</span> between <span class="math inline">\(\boldsymbol x\)</span> and <span class="math inline">\(\boldsymbol y\)</span>:
<span class="math display">\[
\boldsymbol \Psi= \text{Cor}(\boldsymbol x, \boldsymbol y) = \boldsymbol V_{\boldsymbol x}^{-1/2}  \boldsymbol \Phi\boldsymbol V_{\boldsymbol y}^{-1/2} 
\]</span>
where <span class="math inline">\(\boldsymbol V_{\boldsymbol x} = \text{Diag}(\boldsymbol \Sigma_{\boldsymbol x})\)</span> and <span class="math inline">\(\boldsymbol V_{\boldsymbol y} = \text{Diag}(\boldsymbol B\boldsymbol \Sigma_{\boldsymbol x} \boldsymbol B^T)\)</span>
are diagonal matrices containing the variances for the components
of <span class="math inline">\(\boldsymbol x\)</span> and <span class="math inline">\(\boldsymbol y\)</span>.</p>
<p>Special cases/examples:</p>
<div class="example">
<p><span id="exm:univartrans" class="example"><strong>Example 2.1  </strong></span>Univariate case (<span class="math inline">\(d=1, m=1\)</span>): <span class="math inline">\(y=a + b x\)</span></p>
<ul>
<li><span class="math inline">\(\text{E}(y)=a+b\mu\)</span></li>
<li><span class="math inline">\(\text{Var}(y)=b^2\sigma^2\)</span></li>
<li><span class="math inline">\(\text{Cov}(y, x) = b\sigma^2\)</span></li>
<li><span class="math inline">\(\text{Cor}(y, x) = \frac{b \sigma^2}{\sqrt{b^2\sigma^2} \sqrt{\sigma^2} } =1\)</span></li>
</ul>
</div>
<div class="example">
<p><span id="exm:sumunivariate" class="example"><strong>Example 2.2  </strong></span>Sum of two random univariate variables:
<span class="math inline">\(y = x_1 + x_2\)</span>, i.e. <span class="math inline">\(a=0\)</span> and <span class="math inline">\(\boldsymbol B=(1,1)\)</span></p>
<ul>
<li><span class="math inline">\(\text{E}(y) = \text{E}(x_1+x_2)=\mu_1+\mu_2\)</span></li>
<li><span class="math inline">\(\text{Var}(y) = \text{Var}(x_1+x_2) = (1,1)\begin{pmatrix} \sigma^2_1 &amp; \sigma_{12}\\ \sigma_{12} &amp; \sigma^2_2 \end{pmatrix} \begin{pmatrix} 1\\ 1 \end{pmatrix} = \sigma^2_1+\sigma^2_2+2\sigma_{12} = \text{Var}(x_1)+\text{Var}(x_2)+2\,\text{Cov}(x_1,x_2)\)</span></li>
</ul>
</div>
<div class="example">
<p><span id="exm:transformcov" class="example"><strong>Example 2.3  </strong></span><span class="math inline">\(y_1=a_1+b_1 x_1\)</span> and <span class="math inline">\(y_2=a_2+b_2 x_2\)</span>,
i.e. <span class="math inline">\(\boldsymbol a= \begin{pmatrix} a_1\\ a_2 \end{pmatrix}\)</span> and<br><span class="math inline">\(\boldsymbol B= \begin{pmatrix}b_1 &amp; 0\\ 0 &amp; b_2\end{pmatrix}\)</span></p>
<ul>
<li>
<span class="math inline">\(\text{E}(\boldsymbol y)=\begin{pmatrix} a_1+b_1 \mu_1\\ a_2+b_2 \mu_2 \end{pmatrix}\)</span><br>
</li>
<li>
<span class="math inline">\(\text{Var}(\boldsymbol y) = \begin{pmatrix} b_1 &amp; 0\\ 0 &amp; b_2 \end{pmatrix}  \begin{pmatrix} \sigma^2_1 &amp; \sigma_{12}\\ \sigma_{12} &amp; \sigma^2_2 \end{pmatrix} \begin{pmatrix} b_1 &amp; 0\\ 0 &amp; b_2 \end{pmatrix} = \begin{pmatrix} b^2_1\sigma^2_1 &amp; b_1b_2\sigma_{12}\\ b_1b_2\sigma_{12} &amp; b^2_2\sigma^2_2 \end{pmatrix}\)</span><br>
note that <span class="math inline">\(\text{Cov}(y_1, y_2) = b_1 b_2\text{Cov}(x_1,x_2)\)</span>
</li>
</ul>
</div>
</div>
<div id="squared-multiple-correlation" class="section level3" number="2.1.2">
<h3>
<span class="header-section-number">2.1.2</span> Squared multiple correlation<a class="anchor" aria-label="anchor" href="#squared-multiple-correlation"><i class="fas fa-link"></i></a>
</h3>
<p><strong>Definition of squared multiple correlation</strong></p>
<p>Squared multiple correlation is a measure summarising the linear association between a scalar response variable <span class="math inline">\(y\)</span>
and a set of predictors <span class="math inline">\(\boldsymbol x= (x_1, \ldots, x_d)^T\)</span>. It is given by
<span class="math display">\[
\begin{split}
\text{Cor}(y, \boldsymbol x)^2 &amp;= \boldsymbol \Sigma_{y \boldsymbol x} \boldsymbol \Sigma_{\boldsymbol x}^{-1} \boldsymbol \Sigma_{\boldsymbol xy} / \sigma^2_y\\
 &amp;=\boldsymbol P_{y \boldsymbol x} \boldsymbol P_{ \boldsymbol x}^{-1} \boldsymbol P_{\boldsymbol xy}\\
\end{split}
\]</span>
If <span class="math inline">\(y\)</span> can be perfectly linearly predicted by <span class="math inline">\(\boldsymbol x\)</span> then <span class="math inline">\(\text{Cor}(y, \boldsymbol x)^2 = 1\)</span>.</p>
<p>The empirical estimate of <span class="math inline">\(\text{Cor}(y, \boldsymbol x)^2\)</span> is the <span class="math inline">\(R^2\)</span> coefficient that you will find in any software for linear regression.</p>
<p>See the corresponding section in <a href="https://strimmerlab.github.io/publications/lecture-notes/MATH20802/squared-multiple-correlation-and-variance-decomposition-in-linear-regression.html">MATH20802 Statistical Methods</a>.</p>
<p><strong>Squared multiple correlation for affine transformation</strong></p>
<p>Since we linearly transform <span class="math inline">\(\boldsymbol x\)</span> into <span class="math inline">\(\boldsymbol y\)</span> with no additional error involved we expect
that for each component <span class="math inline">\(y_i\)</span> in <span class="math inline">\(\boldsymbol y\)</span> we have <span class="math inline">\(\text{Cor}(y_i, \boldsymbol x)^2=1\)</span>.
This can be shown directly by computing
<span class="math display">\[
\begin{split}
\left(\text{Cor}(y_1, \boldsymbol x)^2, \ldots, \text{Cor}(y_m, \boldsymbol x)^2 \right)^T
&amp;=\text{Diag}\left(\boldsymbol \Sigma_{\boldsymbol y\boldsymbol x} \boldsymbol \Sigma_{\boldsymbol x}^{-1} \boldsymbol \Sigma_{\boldsymbol x\boldsymbol y}  \right) / \text{Diag}\left( \boldsymbol \Sigma_{\boldsymbol y} \right) \\
&amp;= \text{Diag}\left(\boldsymbol B\boldsymbol \Sigma_{\boldsymbol x} \boldsymbol \Sigma_{\boldsymbol x}^{-1} \boldsymbol \Sigma_{\boldsymbol x} \boldsymbol B^T \right) / \text{Diag}\left( \boldsymbol B\boldsymbol \Sigma_{\boldsymbol x} \boldsymbol B^T \right) \\
&amp;= \text{Diag}\left(\boldsymbol B\boldsymbol \Sigma_{\boldsymbol x} \boldsymbol B^T \right) / \text{Diag}\left( \boldsymbol B\boldsymbol \Sigma_{\boldsymbol x} \boldsymbol B^T \right) \\
&amp;=\left(1, \ldots, 1 \right)^T\\
\end{split}
\]</span></p>
</div>
<div id="invertible-location-scale-transformation" class="section level3" number="2.1.3">
<h3>
<span class="header-section-number">2.1.3</span> Invertible location-scale transformation<a class="anchor" aria-label="anchor" href="#invertible-location-scale-transformation"><i class="fas fa-link"></i></a>
</h3>
<p>If <span class="math inline">\(m=d\)</span> (square <span class="math inline">\(\boldsymbol B\)</span>) and <span class="math inline">\(\det(\boldsymbol B) \neq 0\)</span> then the affine transformation is <strong>invertible</strong>.</p>
<p>Forward transformation:
<span class="math display">\[\boldsymbol y= \boldsymbol a+ \boldsymbol B\boldsymbol x\]</span></p>
<p>Back transformation:
<span class="math display">\[\boldsymbol x= \boldsymbol B^{-1}(\boldsymbol y-\boldsymbol a)\]</span></p>
<p>Invertible transformations thus provide a one-to-one map between <span class="math inline">\(\boldsymbol x\)</span> and <span class="math inline">\(\boldsymbol y\)</span>.</p>
<div class="example">
<p><span id="exm:mahatrans" class="example"><strong>Example 2.4  </strong></span><strong>Mahalanobis transform</strong></p>
</div>
<p>We assume <span class="math inline">\(\text{E}(\boldsymbol x)=\boldsymbol \mu_{\boldsymbol x}\)</span> and a positive definite
covariance matrix <span class="math inline">\(\text{Var}(\boldsymbol x)=\boldsymbol \Sigma_{\boldsymbol x}\)</span> with <span class="math inline">\(\det(\boldsymbol \Sigma_{\boldsymbol x}) &gt; 0\)</span>.</p>
<p>The Mahalanobis transformation is given by
<span class="math display">\[
\boldsymbol y=\boldsymbol \Sigma^{-1/2}_{\boldsymbol x}(\boldsymbol x-\boldsymbol \mu_{\boldsymbol x})
\]</span>
This corresponds to an affine transformation with
<span class="math inline">\(\boldsymbol a= - \boldsymbol \Sigma^{-1/2}_{\boldsymbol x} \boldsymbol \mu_{\boldsymbol x}\)</span> and <span class="math inline">\(\boldsymbol B= \boldsymbol \Sigma^{-1/2}_{\boldsymbol x}\)</span>.</p>
<p>The inverse principal matrix square root <span class="math inline">\(\boldsymbol \Sigma^{-1/2}_{\boldsymbol x}\)</span> can be computed
by eigendecomposition (see Appendix).</p>
<p>The mean and the variance of <span class="math inline">\(\boldsymbol y\)</span> becomes
<span class="math display">\[
\text{E}(\boldsymbol y) = \boldsymbol 0\]</span>
and
<span class="math display">\[\text{Var}(\boldsymbol y) = \boldsymbol I_d\]</span>.</p>
<p>The Mahalanobis transforms performs three functions:</p>
<ol style="list-style-type: decimal">
<li>Centering (<span class="math inline">\(-\boldsymbol \mu\)</span>)</li>
<li>Standardisation <span class="math inline">\(\text{Var}(y_i)=1\)</span>
</li>
<li>Decorrelation <span class="math inline">\(\text{Cor}(y_i,y_j)=0\)</span> for <span class="math inline">\(i \neq j\)</span>
</li>
</ol>
<p>In the <strong>univariate case (<span class="math inline">\(d=1\)</span>)</strong> the coefficients reduce to
<span class="math inline">\(a = - \frac{\mu_x}{\sigma_x}\)</span> and <span class="math inline">\(B = \frac{1}{\sigma_x}\)</span> and the Mahalanobis transform
becomes
<span class="math display">\[y = \frac{x-\mu_x}{\sigma_x}\]</span>
i.e. it applies centering + standardisation.</p>
<p>The <strong>Mahalanobis transformation</strong> appears implicitly in many places in multivariate statistics,
e.g. in the multivariate normal density. It is a particular example of a whitening transformation (of which there
are infinitely many, see later in the course).</p>
<div class="example">
<p><span id="exm:coltrans" class="example"><strong>Example 2.5  </strong></span><strong>Inverse Mahalanobis transformation</strong></p>
</div>
<p>The inverse of the Mahalanobis transform is given by
<span class="math display">\[
\boldsymbol y= \boldsymbol \mu_{\boldsymbol y}+\boldsymbol \Sigma^{1/2}_{\boldsymbol y} \boldsymbol x
\]</span>
As the Mahalanobis transform is a whitening transform the inverse Mahalonobis
transform is sometimes called the Mahalanobis colouring transformation.
The coefficients in the affine transformation are
<span class="math inline">\(\boldsymbol a=\boldsymbol \mu_{\boldsymbol y}\)</span> and <span class="math inline">\(\boldsymbol B=\boldsymbol \Sigma^{1/2}_{\boldsymbol y}\)</span>.</p>
<p>Starting with <span class="math inline">\(\text{E}(\boldsymbol x)=\boldsymbol 0\)</span> and <span class="math inline">\(\text{Var}(\boldsymbol x)=\boldsymbol I_d\)</span> the
mean and variance of the transformed variable are
<span class="math display">\[\text{E}(\boldsymbol y) = \boldsymbol \mu_{\boldsymbol y}
\]</span>
and
<span class="math display">\[\text{Var}(\boldsymbol y) = \boldsymbol \Sigma_{\boldsymbol y}
\]</span></p>
</div>
<div id="transformation-of-a-density-under-an-invertible-location-scale-transformation" class="section level3" number="2.1.4">
<h3>
<span class="header-section-number">2.1.4</span> Transformation of a density under an invertible location-scale transformation:<a class="anchor" aria-label="anchor" href="#transformation-of-a-density-under-an-invertible-location-scale-transformation"><i class="fas fa-link"></i></a>
</h3>
<p>Assume <span class="math inline">\(\boldsymbol x\sim F_{\boldsymbol x}\)</span> with density <span class="math inline">\(f_{\boldsymbol x}(\boldsymbol x)\)</span>.</p>
<p>After linear transformation <span class="math inline">\(\boldsymbol y= \boldsymbol a+ \boldsymbol B\boldsymbol x\)</span> we get <span class="math inline">\(\boldsymbol y\sim F_{\boldsymbol y}\)</span> with density
<span class="math display">\[f_{\boldsymbol y}(\boldsymbol y)=|\det(\boldsymbol B)|^{-1} f_{\boldsymbol x} \left( \boldsymbol B^{-1}(\boldsymbol y-\boldsymbol a)\right)\]</span></p>
<div class="example">
<p><span id="exm:invmahanorm" class="example"><strong>Example 2.6  </strong></span>Transformation of standard normal with inverse Mahalanobis transform</p>
</div>
<p>Assume <span class="math inline">\(\boldsymbol x\)</span> is multivariate standard normal <span class="math inline">\(\boldsymbol x\sim N_d(\boldsymbol 0,\boldsymbol I_d)\)</span> with density
<span class="math display">\[f_{\boldsymbol x}(\boldsymbol x) = (2\pi)^{-d/2}\exp\left( -\frac{1}{2} \boldsymbol x^T \boldsymbol x\right)\]</span>
Then the density after applying the inverse Mahalanobis transform<br><span class="math inline">\(\boldsymbol y= \boldsymbol \mu_{\boldsymbol y}+\boldsymbol \Sigma^{1/2}_{\boldsymbol y} \boldsymbol x\)</span> is
<span class="math display">\[
\begin{split}
f_{\boldsymbol y}(\boldsymbol y) &amp;= |\det(\boldsymbol \Sigma^{1/2}_{\boldsymbol y})|^{-1} (2\pi)^{-d/2} \exp\left(-\frac{1}{2}(\boldsymbol y-\boldsymbol \mu_{\boldsymbol y})^T\boldsymbol \Sigma^{-1/2}_{\boldsymbol y} \,\boldsymbol \Sigma^{-1/2}_{\boldsymbol y}(\boldsymbol y-\boldsymbol \mu_{\boldsymbol y})\right)\\
&amp; = (2\pi)^{-d/2} \det(\boldsymbol \Sigma_{\boldsymbol y})^{-1/2} \exp\left(-\frac{1}{2}(\boldsymbol y-\boldsymbol \mu_{\boldsymbol y})^T\boldsymbol \Sigma^{-1}_{\boldsymbol y}(\boldsymbol y-\boldsymbol \mu_{\boldsymbol y})\right) \\
\end{split}
\]</span>
<span class="math inline">\(\Longrightarrow\)</span> <span class="math inline">\(\boldsymbol y\)</span> has multivariate normal density <span class="math inline">\(N_d(\boldsymbol \mu_{\boldsymbol y}, \boldsymbol \Sigma_{\boldsymbol y})\)</span></p>
<p><em>Application:</em> e.g. random number generation: draw from <span class="math inline">\(N_d(\boldsymbol 0,\boldsymbol I_d)\)</span> (easy!) then convert to multivariate normal by tranformation
(see Worksheet 3).</p>
</div>
</div>
<div id="nonlinear-transformations" class="section level2" number="2.2">
<h2>
<span class="header-section-number">2.2</span> Nonlinear transformations<a class="anchor" aria-label="anchor" href="#nonlinear-transformations"><i class="fas fa-link"></i></a>
</h2>
<div id="general-transformation" class="section level3" number="2.2.1">
<h3>
<span class="header-section-number">2.2.1</span> General transformation<a class="anchor" aria-label="anchor" href="#general-transformation"><i class="fas fa-link"></i></a>
</h3>
<p><span class="math display">\[\boldsymbol y= \boldsymbol h(\boldsymbol x)\]</span>
with <span class="math inline">\(\boldsymbol h\)</span> an arbitrary vector-valued function</p>
<ul>
<li>linear case: <span class="math inline">\(\boldsymbol h(\boldsymbol x) = \boldsymbol a+\boldsymbol B\boldsymbol x\)</span>
</li>
</ul>
</div>
<div id="delta-method" class="section level3" number="2.2.2">
<h3>
<span class="header-section-number">2.2.2</span> Delta method<a class="anchor" aria-label="anchor" href="#delta-method"><i class="fas fa-link"></i></a>
</h3>
<p>Assume that we know the mean <span class="math inline">\(\text{E}(\boldsymbol x)=\boldsymbol \mu_{\boldsymbol x}\)</span> and variance <span class="math inline">\(\text{Var}(\boldsymbol x)=\boldsymbol \Sigma_{\boldsymbol x}\)</span> of <span class="math inline">\(\boldsymbol x\)</span>.
Is it possible to say something about the mean and variance of the transformed
random variable <span class="math inline">\(\boldsymbol y\)</span>?
<span class="math display">\[
\text{E}(\boldsymbol y)= \text{E}(\boldsymbol h(\boldsymbol x))= ?
\]</span>
<span class="math display">\[
\text{Var}(\boldsymbol y) = \text{Var}(\boldsymbol h(\boldsymbol x))= ? \\
\]</span></p>
<p>In general, for a transformation <span class="math inline">\(\boldsymbol h(\boldsymbol x)\)</span> the exact mean and variance of the transformed variable cannot be obtained analytically.</p>
<p>However, we can find a <strong>linear approximation</strong> and then compute its mean and variance.
This approximation is called the “Delta Method”, or the “law of propagation of errors”, and is credited to Gauss.<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;Gorroochurn, P. 2020. Who Invented the Delta Method, Really? The Mathematical Intelligencer &lt;strong&gt;42&lt;/strong&gt;:46–49. &lt;a href="https://doi.org/10.1007/s00283-020-09982-0" class="uri"&gt;https://doi.org/10.1007/s00283-020-09982-0&lt;/a&gt;&lt;/p&gt;'><sup>2</sup></a></p>
<p>Linearisation of <span class="math inline">\(\boldsymbol h(\boldsymbol x)\)</span> is achieved by a Taylor series approximation of first order
of <span class="math inline">\(\boldsymbol h(\boldsymbol x)\)</span> around <span class="math inline">\(\boldsymbol x_0\)</span>:
<span class="math display">\[\boldsymbol h(\boldsymbol x) \approx \boldsymbol h(\boldsymbol x_0) + \underbrace{J_{\boldsymbol h}(\boldsymbol x_0)}_{\text{Jacobian matrix}}(\boldsymbol x-\boldsymbol x_0)  = 
\underbrace{\boldsymbol h(\boldsymbol x_0) - J_{\boldsymbol h}(\boldsymbol x_0)\, \boldsymbol x_0}_{\boldsymbol a} + \underbrace{J_{\boldsymbol h}(\boldsymbol x_0)}_{\boldsymbol B} \boldsymbol x\]</span></p>
<p>If <span class="math inline">\(h(\boldsymbol x)\)</span> is scalar-valued then <strong>gradient</strong> <span class="math inline">\(\nabla h(\boldsymbol x)\)</span> is given by the vector of partial correlations
<span class="math display">\[
\nabla h(\boldsymbol x) =
\begin{pmatrix}
\frac{\partial h(\boldsymbol x)}{\partial x_1}  \\
\vdots\\
\frac{\partial h(\boldsymbol x)}{\partial x_d} \\
\end{pmatrix}
\]</span>
where <span class="math inline">\(\nabla\)</span> is the nabla operator.</p>
<p>The <strong>Jacobian matrix</strong> is the <strong>generalisation of the gradient</strong> if <span class="math inline">\(\boldsymbol h(\boldsymbol x)\)</span> is vector-valued:</p>
<p><span class="math display">\[J_{\boldsymbol h}(\boldsymbol x) = \begin{pmatrix}\nabla h_1(\boldsymbol x)^T\\ \nabla h_2(\boldsymbol x)^T \\ \vdots \\ \nabla h_m(\boldsymbol x)^T \end{pmatrix} = \begin{pmatrix}
    \frac{\partial h_1(\boldsymbol x)}{\partial x_1} &amp; \dots &amp; \frac{\partial h_1(\boldsymbol x)}{\partial x_d}\\
    \vdots &amp; \ddots &amp; \vdots \\
    \frac{\partial h_m(\boldsymbol x)}{\partial x_1} &amp; \dots &amp; \frac{\partial h_m(\boldsymbol x)}{\partial x_d}
    \end{pmatrix}\]</span>
Note that in the Jacobian matrix by convention the gradient for each individual component of <span class="math inline">\(\boldsymbol h(\boldsymbol x)\)</span> is contained in the <em>row</em> of the matrix so the number of rows corresponds to the dimension of <span class="math inline">\(\boldsymbol h(\boldsymbol x)\)</span> and the number of columns to the dimension of <span class="math inline">\(\boldsymbol x\)</span>.</p>
<p>First order approximation of <span class="math inline">\(\boldsymbol h(\boldsymbol x)\)</span> around <span class="math inline">\(\boldsymbol x_0=\boldsymbol \mu_{\boldsymbol x}\)</span> yields
<span class="math inline">\(\boldsymbol a= \boldsymbol h(\boldsymbol \mu_{\boldsymbol x}) - J_{\boldsymbol h}(\boldsymbol \mu_{\boldsymbol x})\, \boldsymbol \mu_{\boldsymbol x}\)</span> and
<span class="math inline">\(\boldsymbol B= J_{\boldsymbol h}(\boldsymbol \mu_{\boldsymbol x})\)</span> and leads directly to the <strong>multivariate Delta method</strong>:</p>
<p><span class="math display">\[\text{E}(\boldsymbol y)\approx\boldsymbol h(\boldsymbol \mu_{\boldsymbol x})\]</span>
<span class="math display">\[\text{Var}(\boldsymbol y)\approx J_{\boldsymbol h}(\boldsymbol \mu_{\boldsymbol x}) \, \boldsymbol \Sigma_{\boldsymbol x} \, J_{\boldsymbol h}(\boldsymbol \mu_{\boldsymbol x})^T\]</span></p>
<p>The <strong>univariate Delta method</strong> is a special case:
<span class="math display">\[\text{E}(y) \approx h(\mu_x)\]</span>
<span class="math display">\[\text{Var}(y)\approx \sigma^2_x \, h'(\mu_x)^2\]</span></p>
<p>Note that the Delta approximation breaks down if <span class="math inline">\(\text{Var}(\boldsymbol y)\)</span> is singular,
for example if the first derivative (or gradient or Jacobian matrix) at <span class="math inline">\(\boldsymbol \mu_{\boldsymbol x}\)</span> is zero.</p>
<div class="example">
<p><span id="exm:varoddsration" class="example"><strong>Example 2.7  </strong></span><strong>Variance of the odds ratio</strong></p>
<p>The proportion <span class="math inline">\(\hat{p} = \frac{n_1}{n}\)</span> resulting from
<span class="math inline">\(n\)</span> repeats of a Bernoulli experiment has expectation <span class="math inline">\(\text{E}(\hat{p})=p\)</span>
and variance <span class="math inline">\(\text{Var}(\hat{p}) = \frac{p (1-p)}{n}\)</span>.
What are the (approximate) mean and the variance of the corresponding odds ratio <span class="math inline">\(\widehat{OR}=\frac{\hat{p}}{1-\hat{p}}\)</span>?</p>
<p>With <span class="math inline">\(h(x) = \frac{x}{1-x}\)</span>,
<span class="math inline">\(\widehat{OR} = h(\hat{p})\)</span> and <span class="math inline">\(h'(x) = \frac{1}{(1-x)^2}\)</span> we get using the
Delta method
<span class="math inline">\(\text{E}( \widehat{OR} ) \approx h(p) = \frac{p}{1-p}\)</span> and
<span class="math inline">\(\text{Var}( \widehat{OR} )\approx h'(p)^2 \text{Var}( \hat{p} ) = \frac{p}{n (1-p)^3}\)</span>.</p>
</div>
<div class="example">
<p><span id="exm:logtransform" class="example"><strong>Example 2.8  </strong></span><strong>Log-transform as variance stabilisation</strong></p>
<p>Assume <span class="math inline">\(x\)</span> has some mean <span class="math inline">\(\text{E}(x)=\mu\)</span> and variance <span class="math inline">\(\text{Var}(x) = \sigma^2 \mu^2\)</span>,
i.e. the standard deviation <span class="math inline">\(\text{SD}(x)\)</span> is proportional to the mean <span class="math inline">\(\mu\)</span>.
What are the (approximate) mean and the variance of the log-transformed variable <span class="math inline">\(\log(x)\)</span>?</p>
<p>With <span class="math inline">\(h(x) = \log(x)\)</span> and <span class="math inline">\(h'(x) = \frac{1}{x}\)</span> we get using the
Delta method
<span class="math inline">\(\text{E}( \log(x) ) \approx h(\mu) = \log(\mu)\)</span> and
<span class="math inline">\(\text{Var}( \log(x) )\approx h'(\mu)^2 \text{Var}( x ) = \left(\frac{1}{\mu} \right)^2 \sigma^2 \mu^2 = \sigma^2\)</span>. Thus, after applying the log-transform the variance does not depend any more on the mean!</p>
</div>
</div>
<div id="transformation-of-a-probability-density-function-under-a-general-invertible-transformation" class="section level3" number="2.2.3">
<h3>
<span class="header-section-number">2.2.3</span> Transformation of a probability density function under a general invertible transformation<a class="anchor" aria-label="anchor" href="#transformation-of-a-probability-density-function-under-a-general-invertible-transformation"><i class="fas fa-link"></i></a>
</h3>
<p>Assume <span class="math inline">\(\boldsymbol h(\boldsymbol x) = \boldsymbol y(\boldsymbol x)\)</span> is invertible: <span class="math inline">\(\boldsymbol h^{-1}(\boldsymbol y)=\boldsymbol x(\boldsymbol y)\)</span></p>
<p><span class="math inline">\(\boldsymbol x\sim F_{\boldsymbol x}\)</span> with probability density function <span class="math inline">\(f_{\boldsymbol x}(\boldsymbol x)\)</span></p>
<p>The density <span class="math inline">\(f_{\boldsymbol y}(\boldsymbol y)\)</span> of the transformed random vector <span class="math inline">\(\boldsymbol y\)</span> is then given by<br><span class="math display">\[f_{\boldsymbol y}(\boldsymbol y) = |\det\left( J_{\boldsymbol x}(\boldsymbol y) \right)| \,\,\,  f_{\boldsymbol x}\left( \boldsymbol x(\boldsymbol y) \right)\]</span></p>
<p>where <span class="math inline">\(J_{\boldsymbol x}(\boldsymbol y)\)</span> is the Jacobian matrix of the inverse transformation.</p>
<p>Special cases:</p>
<ul>
<li>Univariate version: <span class="math inline">\(f_y(y) = \left|\frac{dx(y)}{dy} \right| \, f_x\left(x(y)\right)\)</span>
</li>
<li>Linear transformation <span class="math inline">\(\boldsymbol h(\boldsymbol x) = \boldsymbol a+ \boldsymbol B\boldsymbol x\)</span>, with <span class="math inline">\(\boldsymbol x(\boldsymbol y) = \boldsymbol B^{-1}(\boldsymbol y-\boldsymbol a)\)</span>
and <span class="math inline">\(J_{\boldsymbol x}(\boldsymbol y) = \boldsymbol B^{-1}\)</span>:
<span class="math display">\[f_{\boldsymbol y}(\boldsymbol y)=\left|\det(\boldsymbol B)\right|^{-1} f_{\boldsymbol x} \left( \boldsymbol B^{-1}(\boldsymbol y-\boldsymbol a)\right)\]</span>
</li>
</ul>
</div>
<div id="normalising-flows" class="section level3" number="2.2.4">
<h3>
<span class="header-section-number">2.2.4</span> Normalising flows<a class="anchor" aria-label="anchor" href="#normalising-flows"><i class="fas fa-link"></i></a>
</h3>
<p>In this module we will focus mostly on linear transformations as these underpin
much of classical multivariate statistics, but it is important to keep in mind for later study
the importance of nonlinear transformations</p>
<p>In machine learning (sequences of) invertible nonlinear transformations are known as “normalising flows”. They are used both in a generative way (building complex models from
simple models) and for simplification and dimension reduction.</p>
<p>If you are interested in normalising flows then a good start to learn more are the review papers
by Kobyzev et al (2021 )<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;Kobyzev et al. 2021. &lt;em&gt;Normalizing Flows: Introduction and Ideas&lt;/em&gt;.
&lt;a href="https://doi.org/10.1109/TPAMI.2020.2992934"&gt;IEEE Trans. Pattern Anal. Mach. Intell. &lt;strong&gt;43&lt;/strong&gt;:3964-3979&lt;/a&gt;&lt;/p&gt;'><sup>3</sup></a> and Papamakarios et al. (2021).<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;Papamakarios et al. 2021. &lt;em&gt;Normalizing Flows for Probabilistic Modeling and Inference&lt;/em&gt;.&lt;br&gt;&lt;a href="https://jmlr.csail.mit.edu/papers/v22/19-1028.html"&gt;JMLR &lt;strong&gt;22&lt;/strong&gt;:1-64&lt;/a&gt;&lt;/p&gt;'><sup>4</sup></a></p>

</div>
</div>
<div id="whitening-transformations" class="section level2" number="2.3">
<h2>
<span class="header-section-number">2.3</span> Whitening transformations<a class="anchor" aria-label="anchor" href="#whitening-transformations"><i class="fas fa-link"></i></a>
</h2>
<div id="overview" class="section level3" number="2.3.1">
<h3>
<span class="header-section-number">2.3.1</span> Overview<a class="anchor" aria-label="anchor" href="#overview"><i class="fas fa-link"></i></a>
</h3>
<p>The <em>Mahalanobis</em> transform (also know as “zero-phase component analysis” or short ZCA transform in machine learning) is a specific example of a <strong>whitening transformation</strong>. These constitute an important and widely used class of invertible location-scale transformations.</p>
<p><em>Terminology:</em> whitening refers to the fact that after the transformation the covariance matrix is spherical, isotrop, white (<span class="math inline">\(\boldsymbol I_d\)</span>)</p>
<p>Whitening is <strong>useful in preprocessing</strong>, to <strong>turn multivariate problems into simple univariate models</strong> and some <strong>reduce the dimension in an optimal way</strong>.</p>
<p>In so-called latent variable models whitening procedures link observed and latent variables (which usually are uncorrelated and standardised random variables):</p>
<p><span class="math display">\[\begin{align*}
\begin{array}{cl}
\text{Whitening} \\
\downarrow
\end{array}
\begin{array}{ll}
\boldsymbol x\\
\uparrow \\
\boldsymbol z\\
\end{array}
\begin{array}{ll}
\text{Observed variable (can be measured)} \\
\text{external, typically correlated} \\
\space \\
\text{Unobserved "latent" variable (cannot be directly measured)} \\
\text{internal, typically chosen to be uncorrelated} \\
\end{array}
\end{align*}\]</span></p>
</div>
<div id="general-whitening-transformation" class="section level3" number="2.3.2">
<h3>
<span class="header-section-number">2.3.2</span> General whitening transformation<a class="anchor" aria-label="anchor" href="#general-whitening-transformation"><i class="fas fa-link"></i></a>
</h3>
<p><strong>Starting point:</strong></p>
<p>Random vector <span class="math inline">\(\boldsymbol x\sim F_{\boldsymbol x}\)</span> <strong>not necessarily from multivariate normal</strong>.</p>
<p><span class="math inline">\(\boldsymbol x\)</span> has mean <span class="math inline">\(\text{E}(\boldsymbol x)=\boldsymbol \mu\)</span> and a positive definite (invertible) covariance matrix <span class="math inline">\(\text{Var}(\boldsymbol x) = \boldsymbol \Sigma\)</span>.</p>
<p>Note that in the following we leave out the subscript <span class="math inline">\(\boldsymbol x\)</span> for the covariance of <span class="math inline">\(\boldsymbol x\)</span>
unless it is needed for clarification.</p>
<p>The covariance can be split into positive variances <span class="math inline">\(\boldsymbol V\)</span> and a
positive definite invertible correlation matrix <span class="math inline">\(\boldsymbol P\)</span> so that <span class="math inline">\(\boldsymbol \Sigma= \boldsymbol V^{1/2} \boldsymbol P\boldsymbol V^{1/2}\)</span>.</p>
<p><strong>Whitening transformation:</strong></p>
<p><span class="math display">\[\underbrace{\boldsymbol z}_{d \times 1 \text{ vector }} = \underbrace{\boldsymbol W}_{d \times d \text{ whitening matrix }} \underbrace{\boldsymbol x}_{d \times 1 \text{ vector }}\]</span>
<strong>Objective</strong>: choose <span class="math inline">\(\boldsymbol W\)</span> so that <span class="math inline">\(\text{Var}(\boldsymbol z)=\boldsymbol I_d\)</span></p>
<p>For Mahalanobis/ZCA whitening we already know that <span class="math inline">\(\boldsymbol W^{\text{ZCA}}=\boldsymbol \Sigma^{-1/2}\)</span>.</p>
<p>In general, the whitening matrix <span class="math inline">\(\boldsymbol W\)</span> needs to satisfy a constraint:
<span class="math display">\[
\begin{array}{lll}
                &amp; \text{Var}(\boldsymbol z) &amp; = \boldsymbol I_d \\
\Longrightarrow &amp; \text{Var}(\boldsymbol W\boldsymbol x) &amp;= \boldsymbol W\boldsymbol \Sigma\boldsymbol W^T = \boldsymbol I_d \\
\Longrightarrow &amp;  \boldsymbol W\, \boldsymbol \Sigma\, \boldsymbol W^T \boldsymbol W= \boldsymbol W&amp; \\
\end{array}
\]</span>
<span class="math display">\[\Longrightarrow \text{constraint on whitening matrix: } \boldsymbol W^T \boldsymbol W= \boldsymbol \Sigma^{-1}\]</span></p>
<p>Clearly, the ZCA whitening matrix satisfies this constraint: <span class="math inline">\((\boldsymbol W^{ZCA})^T \boldsymbol W^{ZCA} = \boldsymbol \Sigma^{-1/2}\boldsymbol \Sigma^{-1/2}=\boldsymbol \Sigma^{-1}\)</span></p>
<p><strong>Covariance-based parameterisation of whitening matrix:</strong></p>
<p>A general way to specify a valid whitening matrix is
<span class="math display">\[
\boldsymbol W= \boldsymbol Q_1 \boldsymbol \Sigma^{-1/2}
\]</span>
where <span class="math inline">\(\boldsymbol Q_1\)</span> is an orthogonal matrix.<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;In this Chapter we will make frequent use of orthogonal matrices. Check Appendix to review their most important properties.&lt;/p&gt;"><sup>5</sup></a></p>
<p>Recall that an orthogonal matrix <span class="math inline">\(\boldsymbol Q\)</span> has the property that <span class="math inline">\(\boldsymbol Q^{-1} = \boldsymbol Q^T\)</span> and
and as a consequence <span class="math inline">\(\boldsymbol Q^T \boldsymbol Q= \boldsymbol Q\boldsymbol Q^T = \boldsymbol I\)</span>.</p>
<p>As a result, the above <span class="math inline">\(\boldsymbol W\)</span> satisfies the whitening constraint:</p>
<p><span class="math display">\[\boldsymbol W^T \boldsymbol W= \boldsymbol \Sigma^{-1/2}\underbrace{\boldsymbol Q_1^T \boldsymbol Q_1}_{\boldsymbol I}\boldsymbol \Sigma^{-1/2}=\boldsymbol \Sigma^{-1}\]</span></p>
<p>Note the converse is also true: any whitening whitening matrix, i.e. any <span class="math inline">\(\boldsymbol W\)</span> satisfying the whitening constraint, can be written in the above form as
<span class="math inline">\(\boldsymbol Q_1 = \boldsymbol W\boldsymbol \Sigma^{1/2}\)</span> is orthogonal by construction.</p>
<p><span class="math inline">\(\Longrightarrow\)</span> instead of choosing <span class="math inline">\(\boldsymbol W\)</span>, <strong>we choose the orthogonal matrix</strong> <span class="math inline">\(\boldsymbol Q_1\)</span>!</p>
<ul>
<li>recall that orthogonal matrices geometrically represent rotations (plus reflections).</li>
<li>it is now clear that there are infinitely many whitening procedures, because there are infinitely many rotations! This also means we need to find ways to choose/select among whitening procedures.</li>
<li>for the Mahalanobis/ZCA transformation <span class="math inline">\(\boldsymbol Q_1^{\text{ZCA}}=\boldsymbol I\)</span>
</li>
<li>
<strong>whitening</strong> can be interpreted as <strong>Mahalanobis transformation</strong> followed by further <strong>rotation-reflection</strong>
</li>
</ul>
<p><strong>Correlation-based parameterisation of whitening matrix:</strong></p>
<p>Instead of working with the covariance matrix <span class="math inline">\(\boldsymbol \Sigma\)</span>, we can express <span class="math inline">\(\boldsymbol W\)</span> also in terms of the corresponding correlation matrix <span class="math inline">\(\boldsymbol P= (\rho_{ij}) = \boldsymbol V^{-1/2} \boldsymbol \Sigma\boldsymbol V^{-1/2}\)</span>
where <span class="math inline">\(\boldsymbol V\)</span> is the diagonal matrix containing the variances.</p>
<p>Specifically, we can specify the whitening matrix as
<span class="math display">\[\boldsymbol W= \boldsymbol Q_2 \boldsymbol P^{-1/2} \boldsymbol V^{-1/2}\]</span></p>
<p>It is easy to verify that this <span class="math inline">\(\boldsymbol W\)</span> also satisfies the whitening constraint:
<span class="math display">\[
\begin{split}
\boldsymbol W^T \boldsymbol W&amp; = \boldsymbol V^{-1/2}\boldsymbol P^{-1/2}\underbrace{\boldsymbol Q_2^T \boldsymbol Q_2}_{\boldsymbol I}\boldsymbol P^{-1/2} \boldsymbol V^{-1/2} \\
&amp; = \boldsymbol V^{-1/2} \boldsymbol P^{-1} \boldsymbol V^{-1/2} = \boldsymbol \Sigma^{-1} \\
\end{split}
\]</span>
Conversely, any whitening matrix <span class="math inline">\(\boldsymbol W\)</span> can also be written in this form as
<span class="math inline">\(\boldsymbol Q_2 = \boldsymbol W\boldsymbol V^{1/2} \boldsymbol P^{1/2}\)</span> is orthogonal by construction.</p>
<ul>
<li>
<strong>Another interpretation of whitening</strong>: first <strong>standardising</strong> (<span class="math inline">\(\boldsymbol V^{-1/2}\)</span>), then <strong>decorrelation</strong> (<span class="math inline">\(\boldsymbol P^{-1/2}\)</span>), followed by <strong>rotation-reflection</strong> (<span class="math inline">\(\boldsymbol Q_2\)</span>)</li>
<li>for Mahalanobis/ZCA transformation <span class="math inline">\(\boldsymbol Q_2^{\text{ZCA}} = \boldsymbol \Sigma^{-1/2} \boldsymbol V^{1/2} \boldsymbol P^{1/2}\)</span>
</li>
</ul>
<p><strong>Both forms to write <span class="math inline">\(\boldsymbol W\)</span> using <span class="math inline">\(\boldsymbol Q_1\)</span> and <span class="math inline">\(\boldsymbol Q_2\)</span> are equally valid (and interchangeable).</strong></p>
<p>Note that for the same <span class="math inline">\(\boldsymbol W\)</span>
<span class="math display">\[\boldsymbol Q_1\neq\boldsymbol Q_2 \text{  Two different orthogonal matrices!}\]</span>
and also
<span class="math display">\[\underbrace{\boldsymbol \Sigma^{-1/2}}_{\text{Symmetric}}\neq\underbrace{\boldsymbol P^{-1/2}\boldsymbol V^{-1/2}}_{\text{Not Symmetric}}\]</span>
even though<br><span class="math display">\[\boldsymbol \Sigma^{-1/2}\boldsymbol \Sigma^{-1/2}=\boldsymbol \Sigma^{-1} = \boldsymbol V^{-1/2}\boldsymbol P^{-1/2}\boldsymbol P^{-1/2}\boldsymbol V^{-1/2}\]</span></p>
</div>
<div id="cross-covariance-and-cross-correlation-for-whitening-transformations" class="section level3" number="2.3.3">
<h3>
<span class="header-section-number">2.3.3</span> Cross-covariance and cross-correlation for whitening transformations<a class="anchor" aria-label="anchor" href="#cross-covariance-and-cross-correlation-for-whitening-transformations"><i class="fas fa-link"></i></a>
</h3>
<p>A useful criterion to characterise and to distinguish among whitening transformations is the
cross-covariance and cross-correlation matrix between
the original variable <span class="math inline">\(\boldsymbol x\)</span> and the whitened variable <span class="math inline">\(\boldsymbol z\)</span>:</p>
<ol style="list-style-type: lower-alpha">
<li>
<p><strong>Cross-covariance</strong> <span class="math inline">\(\boldsymbol \Phi= \Sigma_{\boldsymbol x\boldsymbol z}\)</span> between <span class="math inline">\(\boldsymbol x\)</span> and <span class="math inline">\(\boldsymbol z\)</span>:
<span class="math display">\[
\begin{split}
\boldsymbol \Phi= \text{Cov}(\boldsymbol x, \boldsymbol z) &amp; = \text{Cov}( \boldsymbol x,\boldsymbol W\boldsymbol x)\\
&amp; = \boldsymbol \Sigma\boldsymbol W^T \\
&amp;= \boldsymbol \Sigma\, \boldsymbol \Sigma^{-1/2} \boldsymbol Q_1^T \\
&amp;= \boldsymbol \Sigma^{1/2} \boldsymbol Q_1^T\\
\end{split}
\]</span>
In component notation we write <span class="math inline">\(\boldsymbol \Phi= (\phi_{ij})\)</span> where the row index <span class="math inline">\(i\)</span>
refers to <span class="math inline">\(\boldsymbol x\)</span> and the column index <span class="math inline">\(j\)</span> to <span class="math inline">\(\boldsymbol z\)</span>.</p>
<p><strong>Cross-covariance is linked with</strong> <span class="math inline">\(\boldsymbol Q_1\)</span>!
Thus, choosing cross-covariance determines <span class="math inline">\(\boldsymbol Q_1\)</span> (and vice versa).</p>
<p>Note that the above cross-covariance matrix <span class="math inline">\(\boldsymbol \Phi\)</span> satisfies the condition
<span class="math inline">\(\boldsymbol \Phi\boldsymbol \Phi^T = \boldsymbol \Sigma\)</span>.</p>
<p>The whitening matrix expressed in terms of cross-covariance is <span class="math inline">\(\boldsymbol W= \boldsymbol \Phi^T \boldsymbol \Sigma^{-1}\)</span>, so as required <span class="math inline">\(\boldsymbol W^T \boldsymbol W= \boldsymbol \Sigma^{-1} \boldsymbol \Phi\boldsymbol \Phi^T \boldsymbol \Sigma^{-1} =\boldsymbol \Sigma^{-1}\)</span>.
Furthermore, <span class="math inline">\(\boldsymbol \Phi\)</span> is
the <em>inverse</em> of the whitening matrix,
as <span class="math inline">\(\boldsymbol W^{-1} = \left( \boldsymbol Q_1 \boldsymbol \Sigma^{-1/2} \right)^{-1} = \boldsymbol \Sigma^{1/2} \boldsymbol Q_1^{-1} = \boldsymbol \Sigma^{1/2} \boldsymbol Q_1^{T} = \boldsymbol \Phi\)</span>.</p>
</li>
<li>
<p><strong>Cross-correlation</strong> <span class="math inline">\(\boldsymbol \Psi= \boldsymbol P_{\boldsymbol x\boldsymbol z}\)</span> between <span class="math inline">\(\boldsymbol x\)</span> and <span class="math inline">\(\boldsymbol z\)</span>:
<span class="math display">\[
\begin{split}
\boldsymbol \Psi= \text{Cor}(\boldsymbol x, \boldsymbol z) &amp; = \boldsymbol V^{-1/2} \boldsymbol \Phi\\
&amp; =  \boldsymbol V^{-1/2} \boldsymbol \Sigma\boldsymbol W^T \\
&amp;=\boldsymbol V^{-1/2} \boldsymbol \Sigma\boldsymbol V^{-1/2} \boldsymbol P^{-1/2} \boldsymbol Q_2^T\\
&amp; =  \boldsymbol P^{1/2}  \boldsymbol Q_2^T\\
\end{split}
\]</span></p>
<p>In component notation we write <span class="math inline">\(\boldsymbol \Psi= (\psi_{ij})\)</span> where the row index <span class="math inline">\(i\)</span>
refers to <span class="math inline">\(\boldsymbol x\)</span> and the column index <span class="math inline">\(j\)</span> to <span class="math inline">\(\boldsymbol z\)</span>.</p>
<p><strong>Cross-correlation is linked with</strong> <span class="math inline">\(\boldsymbol Q_2\)</span>!
Hence, choosing cross-correlation determines <span class="math inline">\(\boldsymbol Q_2\)</span> (and vice versa). The whitening
matrix expressed in terms of cross-correlation is
<span class="math inline">\(\boldsymbol W= \boldsymbol \Psi^T \boldsymbol P^{-1} \boldsymbol V^{-1/2}\)</span>.</p>
</li>
</ol>
<p>Note that the factorisation of the cross-covariance <span class="math inline">\(\boldsymbol \Phi=\boldsymbol \Sigma^{1/2}\boldsymbol Q_1^T\)</span> and
the cross-correlation <span class="math inline">\(\boldsymbol \Psi=\boldsymbol P^{1/2}\boldsymbol Q_2^T\)</span> into the product of
a positive definite symmetric matrix and an orthogonal matrix are examples of a <strong>polar decomposition</strong>.</p>
</div>
<div id="inverse-whitening-transformation-and-loadings" class="section level3" number="2.3.4">
<h3>
<span class="header-section-number">2.3.4</span> Inverse whitening transformation and loadings<a class="anchor" aria-label="anchor" href="#inverse-whitening-transformation-and-loadings"><i class="fas fa-link"></i></a>
</h3>
<p><strong>Inverse transformation:</strong></p>
<p>Recall that <span class="math inline">\(\boldsymbol z= \boldsymbol W\boldsymbol x\)</span>. Therefore, the reverse transformation going from the whitened
to the original variable is <span class="math inline">\(\boldsymbol x= \boldsymbol W^{-1} \boldsymbol z\)</span>.
This can be expressed also in terms of cross-covariance and cross-correlation.
With <span class="math inline">\(\boldsymbol W^{-1} = \boldsymbol \Phi\)</span> we get
<span class="math display">\[
\boldsymbol x= \boldsymbol \Phi\boldsymbol z\, .
\]</span>
Furthermore, since <span class="math inline">\(\boldsymbol \Psi= \boldsymbol V^{-1/2} \boldsymbol \Phi\)</span> we have
<span class="math inline">\(\boldsymbol W^{-1} = \boldsymbol V^{1/2} \boldsymbol \Psi\)</span> and hence
<span class="math display">\[
\boldsymbol V^{-1/2} \boldsymbol x=   \boldsymbol \Psi\boldsymbol z\, .
\]</span></p>
<p>The reverse whitening transformation is also known as colouring transformation
(the previously discussed inverse Mahalanobis transform is one example).</p>
<p><strong>Definition of loadings:</strong></p>
<p><em>Loadings</em> are the coefficients of the linear transformation from the latent variable back to the observed variable. If the variables are standardised to unit variance then the loadings are also called <em>correlation loadings</em>.</p>
<p>Hence, the cross-covariance matrix <span class="math inline">\(\boldsymbol \Phi\)</span> plays the role of <em>loadings</em> linking the latent variable <span class="math inline">\(\boldsymbol z\)</span>
with the original <span class="math inline">\(\boldsymbol x\)</span>. Similarly, the cross-correlation matrix <span class="math inline">\(\boldsymbol \Psi\)</span> contains the <em>correlation loadings</em>
linking the (already standardised) latent variable <span class="math inline">\(\boldsymbol z\)</span> with the standardised <span class="math inline">\(\boldsymbol x\)</span>.</p>
<p>In the convention we use here the rows correspond to the original variables
and the columns to the whitened latent variables.</p>
<p><strong>Multiple correlation coefficients from <span class="math inline">\(\boldsymbol z\)</span> back to <span class="math inline">\(\boldsymbol x\)</span>:</strong></p>
<p>We consider the backtransformation from the whitened variable <span class="math inline">\(\boldsymbol z\)</span> to the original variables <span class="math inline">\(\boldsymbol x\)</span> and note that the components of <span class="math inline">\(\boldsymbol z\)</span> are all uncorrelated.
The squared multiple correlation coefficient between each <span class="math inline">\(x_i\)</span> and all <span class="math inline">\(\boldsymbol z\)</span>
is therefore just the sum of the corresponding squared correlations
<span class="math inline">\(\text{Cor}(x_i, z_j)^2\)</span>:
<span class="math display">\[
\begin{split}
\text{Cor}(x_i, \boldsymbol z)^2 &amp;=  \boldsymbol P_{x_i \boldsymbol z} \boldsymbol P_{\boldsymbol z\boldsymbol z} \boldsymbol P_{\boldsymbol zx_i} = \\
             &amp; \sum_{j=1}^d  \text{Cor}(x_i, z_j)^2  \\
 &amp;  = \sum_{j=1}^d \psi_{ij}^2 = 1
\end{split}
\]</span>
As shown earlier for a general linear one-to-one- transformation (which includes whitening as special case) the squared multiple correlation must be 1 because there is
no error. We can confirm this by computing the <strong>row sums of squares</strong> of the cross-correlation matrix <span class="math inline">\(\boldsymbol \Psi\)</span> in matrix notation
<span class="math display">\[
\begin{split}
 \text{Diag}\left(\boldsymbol \Psi\boldsymbol \Psi^T\right) &amp;= \text{Diag}\left(\boldsymbol P^{1/2} \boldsymbol Q_2^T \boldsymbol Q_2\boldsymbol P^{1/2}\right) \\
&amp;= \text{Diag}(\boldsymbol P) \\
&amp;= (1, \ldots, 1)^T\\
\end{split}
\]</span>
from which it is clear that the choice of <span class="math inline">\(\boldsymbol Q_2\)</span> is not relevant.</p>
<p>Similarly, the <strong>row sums of squares</strong> of the cross-covariance matrix <span class="math inline">\(\boldsymbol \Phi\)</span>
equal the variances of the original variables, regardless of <span class="math inline">\(\boldsymbol Q_1\)</span>:
<span class="math display">\[
\sum_{j=1}^d \phi_{ij}^2 = \text{Var}(x_i)
\]</span>
or in matrix notation
<span class="math display">\[
\begin{split}
 \text{Diag}\left(\boldsymbol \Phi\boldsymbol \Phi^T\right) &amp;= \text{Diag}\left(\boldsymbol \Sigma^{1/2} \boldsymbol Q_1^T \boldsymbol Q_1 \boldsymbol \Sigma^{1/2}\right) \\
&amp;= \text{Diag}(\boldsymbol \Sigma) \\
&amp;= (\text{Var}(x_1), \ldots, \text{Var}(x_d)^T\\
\end{split}
\]</span></p>
</div>
<div id="summaries-of-cross-covariance-boldsymbol-phi-and-cross-correlation-boldsymbol-psi-resulting-from-whitening-transformations" class="section level3" number="2.3.5">
<h3>
<span class="header-section-number">2.3.5</span> Summaries of cross-covariance <span class="math inline">\(\boldsymbol \Phi\)</span> and cross-correlation <span class="math inline">\(\boldsymbol \Psi\)</span> resulting from whitening transformations<a class="anchor" aria-label="anchor" href="#summaries-of-cross-covariance-boldsymbol-phi-and-cross-correlation-boldsymbol-psi-resulting-from-whitening-transformations"><i class="fas fa-link"></i></a>
</h3>
<p><strong>Matrix trace:</strong></p>
<p>A simply summary of a matrix is its trace. For the cross-covariance matrix <span class="math inline">\(\boldsymbol \Phi\)</span> the trace is
the sum of all covariances between corresponding elements in <span class="math inline">\(\boldsymbol x\)</span> and <span class="math inline">\(\boldsymbol z\)</span>:
<span class="math display">\[
\text{Tr}(\boldsymbol \Phi) =  \sum_{i=1}^d \text{Cov}(x_i, z_i) =  \sum_{i=1}^d  \phi_{ii} = \text{Tr}\left(\boldsymbol \Sigma^{1/2} \boldsymbol Q_1^T\right)
\]</span>
Likewise, for the cross-correlation matrix <span class="math inline">\(\boldsymbol \Psi\)</span> the trace is
the sum of all correlations between corresponding elements in <span class="math inline">\(\boldsymbol x\)</span> and <span class="math inline">\(\boldsymbol z\)</span>:
<span class="math display">\[
\text{Tr}(\boldsymbol \Psi) =  \sum_{i=1}^d \text{Cor}(x_i, z_i) =  \sum_{i=1}^d  \psi_{ii} = \text{Tr}\left(\boldsymbol P^{1/2} \boldsymbol Q_2^T\right)
\]</span></p>
<p>In both cases the value of the trace depends on <span class="math inline">\(\boldsymbol Q_1\)</span> and <span class="math inline">\(\boldsymbol Q_2\)</span>.
Interestingly, there is unique choice such that the trace is maximised.</p>
<p>Specifically, to maximise <span class="math inline">\(\text{Tr}(\boldsymbol \Phi)\)</span> we conduct the following steps:</p>
<ol style="list-style-type: lower-roman">
<li>Apply eigendecomposition to <span class="math inline">\(\boldsymbol \Sigma= \boldsymbol U\boldsymbol \Lambda\boldsymbol U^T\)</span>. Note that <span class="math inline">\(\boldsymbol \Lambda\)</span> is diagonal with positive eigenvalues <span class="math inline">\(\lambda_i &gt; 0\)</span> as <span class="math inline">\(\boldsymbol \Sigma\)</span> is positive definite and <span class="math inline">\(\boldsymbol U\)</span> is an orthogonal matrix.</li>
<li>The objective function becomes
<span class="math display">\[
\begin{split}
\text{Tr}(\boldsymbol \Phi) &amp;= \text{Tr}\left(\boldsymbol \Sigma^{1/2} \boldsymbol Q_1^T\right)\\
&amp;= \text{Tr}\left( \boldsymbol U\boldsymbol \Lambda^{1/2} \boldsymbol U^T \boldsymbol Q_1^T \right) \\
&amp;= \text{Tr}\left(\boldsymbol \Lambda^{1/2} \, \boldsymbol U^T \boldsymbol Q_1^T \boldsymbol U\right) \\
&amp; = \text{Tr}\left(\boldsymbol \Lambda^{1/2} \, \boldsymbol B\right) \\
&amp; = \sum_{i=1}^d \lambda_i^{1/2} b_{ii}.
\end{split} 
\]</span>
Note that the product of two orthogonal matrices is itself an orthogonal matrix.
Therefore, <span class="math inline">\(\boldsymbol B= \boldsymbol U^T \boldsymbol Q_1^T \boldsymbol U\)</span> is an orthogonal matrix and
<span class="math inline">\(\boldsymbol Q_1 = \boldsymbol U\boldsymbol B^T \boldsymbol U^T\)</span>.</li>
<li>As <span class="math inline">\(\lambda_i &gt; 0\)</span> and all <span class="math inline">\(b_{ii} \in [-1, 1]\)</span> the objective function is maximised
for <span class="math inline">\(b_{ii}=1\)</span>, i.e. for <span class="math inline">\(\boldsymbol B=\boldsymbol I\)</span>.</li>
<li>In turn this implies that <span class="math inline">\(\text{Tr}(\boldsymbol \Phi)\)</span> is maximised for <span class="math inline">\(\boldsymbol Q_1=\boldsymbol I\)</span>.</li>
</ol>
<p>Similary, to maximise <span class="math inline">\(\text{Tr}(\boldsymbol \Psi)\)</span> we</p>
<ul>
<li>decompose <span class="math inline">\(\boldsymbol P= \boldsymbol G\boldsymbol \Theta\boldsymbol G^T\)</span> and then, following the above,<br>
</li>
<li>find that <span class="math inline">\(\text{Tr}(\boldsymbol \Psi) = \text{Tr}\left(\boldsymbol \Theta^{1/2} \, \boldsymbol G^T \boldsymbol Q_2^T \boldsymbol G\right)\)</span> is maximised for <span class="math inline">\(\boldsymbol Q_2=\boldsymbol I\)</span>.</li>
</ul>
<p><strong>Squared Frobenius norm and total variation:</strong></p>
<p>Another way to summarise and dissect the association between <span class="math inline">\(\boldsymbol x\)</span> and the corresponding whitened <span class="math inline">\(\boldsymbol z\)</span>
is the squared Frobenius norm and the total variation based on <span class="math inline">\(\boldsymbol \Phi\)</span> and <span class="math inline">\(\boldsymbol \Psi\)</span>.</p>
<p>The squared Frobenius norm (Euclidean) norm is the sum of squared elements of a matrix.</p>
<p>If we consider the squared Frobenius norm of the cross-covariance matrix, i.e. the sum of squared covariances between
<span class="math inline">\(\boldsymbol x\)</span> and <span class="math inline">\(\boldsymbol z\)</span>,
<span class="math display">\[
|| \boldsymbol \Phi||_F^2 = \sum_{i=1}^d \sum_{j=1}^d \phi_{ij}^2 =  \text{Tr}(\boldsymbol \Phi\boldsymbol \Phi^T) = \text{Tr}( \boldsymbol \Sigma)
\]</span>
we find that this equals the <strong>total variation</strong> of <span class="math inline">\(\boldsymbol \Sigma\)</span> and that it does not depend on <span class="math inline">\(\boldsymbol Q_1\)</span>.
Likewise, computing the squared Frobenius norm of the cross-correlation matrix, i.e. the sum of squared correlations between
<span class="math inline">\(\boldsymbol x\)</span> and <span class="math inline">\(\boldsymbol z\)</span>,
<span class="math display">\[
|| \boldsymbol \Psi||_F^2  = \sum_{i=1}^d \sum_{j=1}^d \psi_{ij}^2= \text{Tr}(\boldsymbol \Psi\boldsymbol \Psi^T) =\text{Tr}( \boldsymbol P) = d
\]</span>
yields the total variation of <span class="math inline">\(\boldsymbol P\)</span> which also does not depend on <span class="math inline">\(\boldsymbol Q_2\)</span>.
Note this is because the squared Frobenius norm is invariant against rotations and reflections.</p>
<p><strong>Proportion of total variation:</strong></p>
<p>We can now compute the
relative contribution of each whitened component <span class="math inline">\(z_j\)</span> to the total variation.
The total sum of squared covariances of each <span class="math inline">\(z_j\)</span> with all <span class="math inline">\(x_1, \ldots, x_d\)</span> is
<span class="math display">\[
h_j = \sum^d_{i=1}\text{Cov}(x_i,z_j)^2 = \sum^d_{i=1} \phi_{ij}^2
\]</span>
In vector notation this is written as the <strong>column sums of squares</strong> of <span class="math inline">\(\boldsymbol \Phi\)</span>
<span class="math display">\[
\boldsymbol h= (h_1,...,h_d)^T = \text{Diag}(\boldsymbol \Phi^T\boldsymbol \Phi) = \text{Diag}\left(\boldsymbol Q_1\boldsymbol \Sigma\boldsymbol Q_1^T\right)
\]</span>
with <span class="math inline">\(\sum_{j=1}^d h_j = \text{Tr}( \boldsymbol \Sigma)\)</span>. The relative contribution of <span class="math inline">\(z_j\)</span> to the total variation is
<span class="math display">\[
\frac{ h_j }{\text{Tr}( \boldsymbol \Sigma)} \,.
\]</span></p>
<p>Similarly, the total sum of squared correlations of each <span class="math inline">\(z_j\)</span> with all <span class="math inline">\(x_1, \ldots, x_d\)</span> is
<span class="math display">\[
k_j = \sum^d_{i=1}\text{Cor}(x_i,z_j)^2 = \sum^d_{i=1} \psi_{ij}^2
\]</span>
and in vector notation as the <strong>column sums of squares</strong> of <span class="math inline">\(\boldsymbol \Psi\)</span>
<span class="math display">\[
\boldsymbol k= (k_1,...,k_d)^T = \text{Diag}\left(\boldsymbol \Psi^T\boldsymbol \Psi\right)=\text{Diag}\left(\boldsymbol Q_2\boldsymbol P\boldsymbol Q_2^T\right)
\]</span>
with <span class="math inline">\(\sum_{i=j}^d k_j = \text{Tr}( \boldsymbol P) = d\)</span>.
Then the relative contribution of <span class="math inline">\(z_j\)</span> to the total variation of the correlation <span class="math inline">\(\boldsymbol P\)</span>
is
<span class="math display">\[
\frac{ k_j  }{\text{Tr}( \boldsymbol P)} = \frac{ k_j  }{d} \,.
\]</span></p>
<p><strong>Maximising the proportion of total variation:</strong></p>
<p>In contrast to the total variation itself, the relative contributions <span class="math inline">\(h_j\)</span> and <span class="math inline">\(k_j\)</span> depend on <span class="math inline">\(\boldsymbol Q_1\)</span> and <span class="math inline">\(\boldsymbol Q_2\)</span>, respectively.</p>
<p>Interestingly, it is possible to choose a unique whitening transformation in order to maximise the relative contributions so that the sum of the <span class="math inline">\(m\)</span> largest contributions of <span class="math inline">\(h_j\)</span> and <span class="math inline">\(k_j\)</span>, respectively, is as large as possible.</p>
<p>Specifically, we note that <span class="math inline">\(\boldsymbol \Phi^T\boldsymbol \Phi\)</span> and <span class="math inline">\(\boldsymbol \Psi^T\boldsymbol \Psi\)</span> are symmetric real matrices. For these type of matrices we know from Schur’s theorem (1923)
that the eigenvalues <span class="math inline">\(\lambda_1 \geq \lambda_2 \geq \ldots \geq \lambda_d\)</span> <strong>majorise</strong> the diagonal elements <span class="math inline">\(p_1 \geq p_2 \geq \ldots \geq p_d\)</span>.
More precisely,
<span class="math display">\[
\sum_{i=1}^m \lambda_i \geq \sum_{i=1}^m p_i \, ,
\]</span>
i.e. the sum of the largest <span class="math inline">\(m\)</span> eigenvalues is larger than or equal to the sum of the <span class="math inline">\(m\)</span> largest diagonal elements.
The maximum (and equality) is only achieved if the matrix is diagonal, as in this case the diagonal elements are equal to the eigenvalues.</p>
<p>Therefore, the optimal solution to problem of maximising the relative contributions is obtained by computing
the eigendecompositions <span class="math inline">\(\boldsymbol \Sigma= \boldsymbol U\boldsymbol \Lambda\boldsymbol U^T\)</span> and <span class="math inline">\(\boldsymbol P= \boldsymbol G\boldsymbol \Theta\boldsymbol G^T\)</span>
and diagonalise <span class="math inline">\(\boldsymbol \Phi^T\boldsymbol \Phi\)</span> and <span class="math inline">\(\boldsymbol \Psi^T \boldsymbol \Psi\)</span> by
setting <span class="math inline">\(\boldsymbol Q_1= \boldsymbol U^T\)</span> and <span class="math inline">\(\boldsymbol Q_2= \boldsymbol G^T\)</span>, respectively. This yields
<span class="math display">\[
\boldsymbol h= (\lambda_1, \ldots, \lambda_d)^T
\]</span>
and
<span class="math display">\[
\boldsymbol k= (\theta_1, \ldots, \theta_d)^T
\]</span>
with eigenvalues arranged in decreasing order.</p>
</div>
</div>
<div id="natural-whitening-procedures" class="section level2" number="2.4">
<h2>
<span class="header-section-number">2.4</span> Natural whitening procedures<a class="anchor" aria-label="anchor" href="#natural-whitening-procedures"><i class="fas fa-link"></i></a>
</h2>
<p>We now introduce several strategies (maximise correlation between individual components, maximise compression, structural constraints) to select an optimal whitening procedure.</p>
<p>Specifically, we discuss the following whitening transformations:</p>
<ul>
<li>
<strong>Mahalanobis</strong> whitening, also known as <strong>ZCA</strong> (zero-phase component analysis) whitening in machine learning (based on covariance)</li>
<li>
<strong>ZCA-cor</strong> whitening (based on correlation)</li>
<li>
<strong>PCA</strong> whitening (based on covariance)</li>
<li>
<strong>PCA-cor</strong> whitening (based on correlation)</li>
<li>
<strong>Cholesky</strong> whitening</li>
</ul>
<p>Thus, in the following we consider three main types (ZCA, PCA, Cholesky) of whitening.</p>
<p>In the following <span class="math inline">\(\boldsymbol x_c = \boldsymbol x-\boldsymbol \mu_{\boldsymbol x}\)</span> and <span class="math inline">\(\boldsymbol z_c = \boldsymbol z-\boldsymbol \mu_{\boldsymbol z}\)</span> denote the mean-centered variables.</p>
<div id="zca-whitening" class="section level3" number="2.4.1">
<h3>
<span class="header-section-number">2.4.1</span> ZCA whitening<a class="anchor" aria-label="anchor" href="#zca-whitening"><i class="fas fa-link"></i></a>
</h3>
<p><em>Aim</em>: remove correlations and standardise but otherwise make sure that the
whitened vector <span class="math inline">\(\boldsymbol z\)</span> does not differ too much from the original vector <span class="math inline">\(\boldsymbol x\)</span>. Specifically, each latent component <span class="math inline">\(z_i\)</span> should be as close as as possible to the corresponding original variable <span class="math inline">\(x_i\)</span>:
<span class="math display">\[
\begin{array}{cc}
x_1\leftrightarrow z_1 \\
x_2\leftrightarrow z_2\\
x_3\leftrightarrow z_3 \\
\vdots
\end{array}
\]</span>
One possible way to implement this is to compute the expected squared difference between the two centered random vectors <span class="math inline">\(\boldsymbol z_c\)</span> and <span class="math inline">\(\boldsymbol x_c\)</span>.</p>
<p><em>ZCA objective function</em>: <strong>minimise</strong> <span class="math inline">\(\text{E}\left( || \boldsymbol x_c - \boldsymbol z_c ||^2_F \right)\)</span> to find an optimal whitening procedure.</p>
<p>The ZCA objective function can be simplified as follows:
<span class="math display">\[
\begin{split}
\text{E}\left( || \boldsymbol x_c-\boldsymbol z_c ||^2_F   \right)&amp;=\text{E}\left( || \boldsymbol x_c ||^2_F   \right)  -2 \text{E}\left(  \text{Tr}\left( \boldsymbol x_c \boldsymbol z_c^T \right) \right)  + \text{E}\left( || \boldsymbol z_c ||^2_F   \right) \\
&amp; = \text{Tr}(  \text{E}( \boldsymbol x_c \boldsymbol x_c^T ) )  - 2 \text{Tr}( \text{E}(  \boldsymbol x_c \boldsymbol z_c^T ) ) + \text{Tr}( \text{E}( \boldsymbol z_c \boldsymbol z_c^T ) )
   \\
&amp; = \text{Tr}( \text{Var}(\boldsymbol x) ) - 2 \text{Tr}( \text{Cov}(\boldsymbol x, \boldsymbol z) ) +  \text{Tr}( \text{Var}(\boldsymbol z) )  \\
&amp; = \text{Tr}(\boldsymbol \Sigma) - 2\text{Tr}(\boldsymbol \Phi)+ d \\
\end{split}
\]</span>
The same objective function can also be obtained by putting a diagonal constraint on the cross-covariance <span class="math inline">\(\boldsymbol \Phi\)</span>. Specifically, we are looking for the <span class="math inline">\(\boldsymbol \Phi\)</span> that is closest to the diagonal matrix <span class="math inline">\(\boldsymbol I\)</span> by <strong>minimising</strong>
<span class="math display">\[
\begin{split}
|| \boldsymbol \Phi- \boldsymbol I||^2_F &amp;= || \boldsymbol \Phi||^2_F  - 2 \text{Tr}(\boldsymbol \Phi^T \boldsymbol I)  + || \boldsymbol I||^2_F \\
&amp;= \text{Tr}(\boldsymbol \Sigma) - 2 \text{Tr}(\boldsymbol \Phi) + d \\
\end{split}
\]</span>
This will force the off-diagonal elements of <span class="math inline">\(\boldsymbol \Phi\)</span> to be close to
zero and thus leads to sparsity in the cross-covariance matrix.</p>
<p>The only term in the above that depends on the whitening transformation is <span class="math inline">\(-2 \text{Tr}(\boldsymbol \Phi)\)</span> as <span class="math inline">\(\boldsymbol \Phi\)</span> is a function
of <span class="math inline">\(\boldsymbol Q_1\)</span>. Therefore we can use the following
alternative objective:</p>
<p><em>ZCA equivalent objective</em>: <strong>maximise</strong> <span class="math inline">\(\text{Tr}(\boldsymbol \Phi) = \text{Tr}(\boldsymbol \Sigma^{1/2} \boldsymbol Q_1^T)\)</span> to find the optimal <span class="math inline">\(\boldsymbol Q_1\)</span></p>
<p><em>Solution</em>:</p>
<p>From the earlier discussion we know that the optimal matrix is
<span class="math display">\[
\boldsymbol Q_1^{\text{ZCA}}=\boldsymbol I
\]</span>
The corresponding whitening matrix for ZCA is therefore
<span class="math display">\[
\boldsymbol W^{\text{ZCA}} = \boldsymbol \Sigma^{-1/2}
\]</span>
and the cross-covariance matrix is
<span class="math display">\[
\boldsymbol \Phi^{\text{ZCA}} = \boldsymbol \Sigma^{1/2}
\]</span>
and the cross-correlation matrix
<span class="math display">\[
\boldsymbol \Psi^{\text{ZCA}} = \boldsymbol V^{-1/2} \boldsymbol \Sigma^{1/2} 
\]</span></p>
<p>Note that <span class="math inline">\(\boldsymbol \Sigma^{1/2}\)</span> is a symmetric positive definite matrix,
hence its diagonal elements are all positive. As a result,
the diagonals of <span class="math inline">\(\boldsymbol \Phi^{\text{ZCA}}\)</span> and <span class="math inline">\(\boldsymbol \Psi^{\text{ZCA}}\)</span> are positive,
i.e. <span class="math inline">\(\text{Cov}(x_i, z_i) &gt; 0\)</span> and <span class="math inline">\(\text{Cor}(x_i, z_i) &gt; 0\)</span>.
Hence, for ZCA two corresponding components <span class="math inline">\(x_i\)</span> and <span class="math inline">\(z_i\)</span> are always positively correlated!</p>
<p><em>Proportion of total variation</em>:</p>
<p>For ZCA with <span class="math inline">\(\boldsymbol Q_1=\boldsymbol I\)</span> we find that <span class="math inline">\(\boldsymbol h=\text{Diag}(\boldsymbol \Sigma) = \sum_{j=1}^d \text{Var}(x_j)\)</span> with <span class="math inline">\(h_i=\text{Var}(x_i)\)</span> hence for ZCA the proportion of total variation contributed by the
latent component <span class="math inline">\(z_i\)</span> is the ratio <span class="math inline">\(\frac{\text{Var}(x_i}{\sum_{j=1}^d \text{Var}(x_j)}\)</span>.</p>
<p><em>Summary</em>:</p>
<ul>
<li>ZCA/Mahalanobis transform is the unique transformation that minimises the expected total squared component-wise difference between <span class="math inline">\(\boldsymbol x_c\)</span> and <span class="math inline">\(\boldsymbol z_c\)</span>.</li>
<li>In ZCA corresponding components in the whitened and original variables are always positively correlated. This facilitates the interpretation of the whitened variables.</li>
<li>Use ZCA aka Mahalanobis whitening if you want to “just” remove correlations.</li>
</ul>
</div>
<div id="zca-cor-whitening" class="section level3" number="2.4.2">
<h3>
<span class="header-section-number">2.4.2</span> ZCA-Cor whitening<a class="anchor" aria-label="anchor" href="#zca-cor-whitening"><i class="fas fa-link"></i></a>
</h3>
<p><em>Aim</em>: same as above but remove scale in <span class="math inline">\(\boldsymbol x\)</span> first before comparing to <span class="math inline">\(\boldsymbol z\)</span>.</p>
<p><em>ZCA-cor objective function</em>: <strong>minimise</strong> <span class="math inline">\(\text{E}\left( || \boldsymbol V^{-1/2} \boldsymbol x_c -\boldsymbol z_c ||^2_F \right)\)</span> to find an optimal whitening procedure.</p>
<p>This can be simplified as follows:
<span class="math display">\[
\begin{split}
\text{E}\left( || \boldsymbol V^{-1/2} \boldsymbol x_c -\boldsymbol z_c||^2_F   \right)&amp;=\text{E}\left( || \boldsymbol V^{-1/2} \boldsymbol x_c ||^2_F   \right)  -2 \text{E}\left(  \text{Tr}\left( \boldsymbol V^{-1/2} \boldsymbol x_c \boldsymbol z_c^T  \right) \right) +  \text{E}\left( || \boldsymbol z_c ||^2_F   \right)\\
&amp; = \text{Tr}(  \text{E}(\boldsymbol V^{-1/2} \boldsymbol x_c \boldsymbol x_c^T \boldsymbol V^{-1/2}) )  
- 2 \text{Tr}( \text{E}( \boldsymbol V^{-1/2} \boldsymbol x_c \boldsymbol z_c^T  ) ) 
+\text{Tr}( \text{E}( \boldsymbol z_c \boldsymbol z_c^T ) )
  \\
&amp; = \text{Tr}(  \text{Cor}(\boldsymbol x, \boldsymbol x) ) - 2 \text{Tr}( \text{Cor}(\boldsymbol x, \boldsymbol z) ) + \text{Tr}( \text{Var}(\boldsymbol z) )   \\
&amp; = d - 2\text{Tr}(\boldsymbol \Psi)+ d \\
&amp; = 2d - 2\text{Tr}(\boldsymbol \Psi)
\end{split}
\]</span>
The same objective function can also be obtained by putting a diagonal constraint on the cross-correlation <span class="math inline">\(\boldsymbol \Psi\)</span>. Specifically, we are looking for the <span class="math inline">\(\boldsymbol \Psi\)</span> that is closest to the diagonal matrix <span class="math inline">\(\boldsymbol I\)</span> by <strong>minimising</strong>
<span class="math display">\[
\begin{split}
|| \boldsymbol \Psi- \boldsymbol I||^2_F &amp;= || \boldsymbol \Psi||^2_F  - 2 \text{Tr}(\boldsymbol \Psi^T \boldsymbol I)  + || \boldsymbol I||^2_F \\
&amp;= d - 2 \text{Tr}(\boldsymbol \Psi) + d \\
&amp;= 2 d - 2 \text{Tr}(\boldsymbol \Psi) \\
\end{split}
\]</span>
This will force the off-diagonal elements of <span class="math inline">\(\boldsymbol \Psi\)</span> to be close to
zero and thus leads to sparsity in the cross-correlation matrix.</p>
<p>The only term in the above that depends on the whitening transformation is <span class="math inline">\(-2 \text{Tr}(\boldsymbol \Psi)\)</span> as <span class="math inline">\(\boldsymbol \Psi\)</span> is a function of <span class="math inline">\(\boldsymbol Q_2\)</span>. Thus we can use the following alternative objective instead:</p>
<p><em>ZCA-cor equivalent objective</em>: <strong>maximise</strong> <span class="math inline">\(\text{Tr}(\boldsymbol \Psi)=\text{Tr}(\boldsymbol P^{1/2} \boldsymbol Q_2^T)\)</span> to find optimal <span class="math inline">\(\boldsymbol Q_2\)</span></p>
<p><em>Solution</em>: same as above for ZCA but using correlation instead of covariance:</p>
<p>From the earlier discussion we know that the optimal matrix is
<span class="math display">\[
\boldsymbol Q_2^{\text{ZCA-Cor}}=\boldsymbol I
\]</span>
The corresponding whitening matrix for ZCA-cor is therefore
<span class="math display">\[
\boldsymbol W^{\text{ZCA-Cor}} = \boldsymbol P^{-1/2}\boldsymbol V^{-1/2}
\]</span>
and the cross-covariance matrix is
<span class="math display">\[
\boldsymbol \Phi^{\text{ZCA-Cor}} = \boldsymbol V^{1/2} \boldsymbol P^{1/2} 
\]</span>
and the cross-correlation matrix is
<span class="math display">\[
\boldsymbol \Psi^{\text{ZCA-Cor}} = \boldsymbol P^{1/2}
\]</span></p>
<p>For the ZCA-cor transformation we also have
<span class="math inline">\(\text{Cov}(x_i, z_i) &gt; 0\)</span> and <span class="math inline">\(\text{Cor}(x_i, z_i) &gt; 0\)</span>
so that two corresponding components <span class="math inline">\(x_i\)</span> and <span class="math inline">\(z_i\)</span> are always positively correlated!</p>
<p><em>Proportion of total variation</em>:</p>
<p>For ZCA-cor with <span class="math inline">\(\boldsymbol Q_2=\boldsymbol I\)</span> we find that <span class="math inline">\(\boldsymbol k=\text{Diag}(\boldsymbol P) = d\)</span> with all <span class="math inline">\(k_i =1\)</span>.
Thus, in ZCA-cor each whitened component <span class="math inline">\(z_i\)</span> contributes equally to the total variation <span class="math inline">\(\text{Tr}(\boldsymbol P) =d\)</span>, with relative proportion
<span class="math inline">\(\frac{1}{d}\)</span>.</p>
<p><em>Summary</em>:</p>
<ul>
<li>ZCA-cor whitening is the unique whitening transformation maximising the
total correlation between corresponding elements in <span class="math inline">\(\boldsymbol x\)</span> and <span class="math inline">\(\boldsymbol z\)</span>.</li>
<li>ZCA-cor leads to interpretable <span class="math inline">\(\boldsymbol z\)</span> because each individual element in <span class="math inline">\(\boldsymbol z\)</span>
is (typically strongly) positively correlated with the corresponding element in the original <span class="math inline">\(\boldsymbol x\)</span>.</li>
<li>As ZCA-cor is explicitly constructed to maximise the total
pairwise correlations it achieves higher total correlation than ZCA.</li>
<li>If <span class="math inline">\(\boldsymbol x\)</span> is standardised to <span class="math inline">\(\text{Var}(x_i)=1\)</span> then ZCA and ZCA-cor are identical.</li>
</ul>
</div>
<div id="pca-whitening" class="section level3" number="2.4.3">
<h3>
<span class="header-section-number">2.4.3</span> PCA whitening<a class="anchor" aria-label="anchor" href="#pca-whitening"><i class="fas fa-link"></i></a>
</h3>
<p><em>Aim</em>: remove correlations and at the same time compress information into a few latent variables.
Specifically, we would like that the first latent component <span class="math inline">\(z_1\)</span> is
maximally linked with all variables in <span class="math inline">\(\boldsymbol x\)</span>, followed by
the second component <span class="math inline">\(z_2\)</span> and so on:
<span class="math display">\[
\begin{array}{cc}
x_1, x_2, \ldots, x_d &amp; \rightarrow z_1 \\
x_1, x_2, \ldots, x_d &amp; \rightarrow z_2 \\
\vdots\\
x_1, x_2, \ldots, x_d &amp; \rightarrow z_d \\
\end{array}
\]</span>
One way to measure the total association of the latent component <span class="math inline">\(z_j\)</span> with all
the original <span class="math inline">\(x_1, \ldots, x_d\)</span> is the sum of the
corresponding squared covariances
<span class="math display">\[
h_j = \sum^d_{i=1}\text{Cov}(x_i,z_j)^2 = \sum^d_{i=1} \phi_{ij}^2
\]</span>
or equivalently the <strong>column sum of squares</strong> of <span class="math inline">\(\boldsymbol \Phi\)</span>
<span class="math display">\[
\boldsymbol h= (h_1,...,h_d)^T = \text{Diag}(\boldsymbol \Phi^T\boldsymbol \Phi) = \text{Diag}\left(\boldsymbol Q_1\boldsymbol \Sigma\boldsymbol Q_1^T\right)
\]</span>
Each <span class="math inline">\(h_j\)</span> is the contribution
of <span class="math inline">\(z_j\)</span> to <span class="math inline">\(\text{Tr}\left( \boldsymbol Q_1 \boldsymbol \Sigma\boldsymbol Q_1^T \right)= \text{Tr}(\boldsymbol \Sigma)\)</span>
i.e. to the total variation based on <span class="math inline">\(\boldsymbol \Sigma\)</span>.
As <span class="math inline">\(\text{Tr}(\boldsymbol \Sigma)\)</span> is constant this implies that there are only <span class="math inline">\(d-1\)</span> independent <span class="math inline">\(h_j\)</span>.</p>
<p>In PCA-whitening we wish to concentrate most of the contributions to the total variation based
on <span class="math inline">\(\boldsymbol \Sigma\)</span> in a small number
of latent components.</p>
<p><em>PCA whitening objective function</em>: find an optimal optimal <span class="math inline">\(\boldsymbol Q_1\)</span> so that
the resulting set <span class="math inline">\(h_1 \geq h_2 \ldots \geq h_d\)</span> in <span class="math inline">\(\boldsymbol h= \text{Diag}\left(\boldsymbol Q_1\boldsymbol \Sigma\boldsymbol Q_1^T\right)\)</span> majorizes any other set of relative contributions.</p>
<p><em>Solution:</em></p>
<p>Following the earlier discussion we apply Schur’s theorem and find the optimal
solution by diagonalising <span class="math inline">\(\boldsymbol \Phi^T\boldsymbol \Phi\)</span> through eigendecomposition of <span class="math inline">\(\boldsymbol \Sigma= \boldsymbol U\boldsymbol \Lambda\boldsymbol U^T\)</span>.
Hence, the optimal value for the <span class="math inline">\(\boldsymbol Q_1\)</span> matrix is
<span class="math display">\[
\boldsymbol Q_1^{\text{PCA}}=\boldsymbol U^T
\]</span>
However, recall that <span class="math inline">\(\boldsymbol U\)</span> is not uniquely defined — you are free to change the columns signs.
The corresponding whitening matrix is
<span class="math display">\[
\boldsymbol W^{\text{PCA}} = \boldsymbol U^T\boldsymbol \Sigma^{-1/2}=\boldsymbol \Lambda^{-1/2}\boldsymbol U^T
\]</span><br>
and the cross-covariance matrix is
<span class="math display">\[
\boldsymbol \Phi^{\text{PCA}} = \boldsymbol U\boldsymbol \Lambda^{1/2} 
\]</span>
and the cross-correlation matrix is
<span class="math display">\[
\boldsymbol \Psi^{\text{PCA}} = \boldsymbol V^{-1/2} \boldsymbol U\boldsymbol \Lambda^{1/2} 
\]</span></p>
<p><em>Identifiability:</em></p>
<p>Note that all of the above (i.e. <span class="math inline">\(\boldsymbol Q_1^{\text{PCA}}, \boldsymbol W^{\text{PCA}}, \boldsymbol \Phi^{\text{PCA}}, \boldsymbol \Psi^{\text{PCA}}\)</span>) is not unique
due to the sign ambiguity in the columns of <span class="math inline">\(\boldsymbol U\)</span>.</p>
<p>Therefore, for identifiability reasons we may wish to impose a further constraint on <span class="math inline">\(\boldsymbol Q_1^{\text{PCA}}\)</span>
or equivalently <span class="math inline">\(\boldsymbol \Phi^{\text{PCA}}\)</span>. A useful condition is to require (for the given ordering
of the original variables!) that <span class="math inline">\(\boldsymbol Q_1^{\text{PCA}}\)</span> has a positive diagonal
or equivalently that <span class="math inline">\(\boldsymbol \Phi^{\text{PCA}}\)</span> has a positive diagonal. This implies that
<span class="math inline">\(\text{Diag}(\boldsymbol U) &gt; 0\)</span> and <span class="math inline">\(\text{Diag}(\boldsymbol \Psi^{\text{PCA}}) &gt; 0\)</span>, hence
all pairs <span class="math inline">\(x_i\)</span> and <span class="math inline">\(z_i\)</span> are positively correlated.</p>
<p>It is particularly important to pay attention to the sign ambiguity
when comparing different computer implementations of PCA whitening (and the related PCA approach).</p>
<p>Note that the actual objective of PCA whitening <span class="math inline">\(\text{Diag}(\boldsymbol \Phi^T\boldsymbol \Phi)\)</span> is not affected by the sign ambiguity
since the column signs of <span class="math inline">\(\boldsymbol \Phi\)</span> do not matter.</p>
<p><em>Proportion of total variation:</em></p>
<p>In PCA whitening the contribution <span class="math inline">\(h_i^{\text{PCA}}\)</span> of each latent component <span class="math inline">\(z_i\)</span>
to the total variation based on the covariance <span class="math inline">\(\text{Tr}(\boldsymbol \Sigma) = \sum_{j=1}^d \lambda_j\)</span> is
<span class="math inline">\(h_i^{\text{PCA}} = \lambda_i\)</span>.
The fraction <span class="math inline">\(\frac{\lambda_i}{\sum^d_{j=1}\lambda_j}\)</span> is the relative
contribution of each element in <span class="math inline">\(\boldsymbol z\)</span> to explain the total variation.</p>
<p>Thus, low ranking components <span class="math inline">\(z_i\)</span> with small <span class="math inline">\(h_i^{\text{PCA}}=\lambda_i\)</span> may be discarded.
In this way PCA whitening achieves both compression and
dimension reduction.</p>
<p><em>Summary:</em></p>
<ul>
<li>PCA whitening is a whitening transformation that maximises compression with the sum of squared cross-covariances as underlying optimality criterion.</li>
<li>There are sign ambiguities in the PCA whitened variables which are inherited from the sign ambiguities in eigenvectors.</li>
<li>If a positive-diagonal condition on the orthogonal matrices is imposed then these sign ambiguities are fully resolved and corresponding components <span class="math inline">\(z_i\)</span> and <span class="math inline">\(x_i\)</span> are always positively correlated.</li>
</ul>
</div>
<div id="pca-cor-whitening" class="section level3" number="2.4.4">
<h3>
<span class="header-section-number">2.4.4</span> PCA-cor whitening<a class="anchor" aria-label="anchor" href="#pca-cor-whitening"><i class="fas fa-link"></i></a>
</h3>
<p><em>Aim</em>: same as for PCA whitening but remove scale in <span class="math inline">\(\boldsymbol x\)</span> first. This means we use squared correlations rather than squared covariances to measure compression, i.e.<br><span class="math display">\[
k_j = \sum^d_{i=1}\text{Cor}(x_i, z_j)^2 = \sum^d_{i=1} \psi_{ij}^2
\]</span>
or in vector notation the <strong>column sum of squares</strong> of <span class="math inline">\(\boldsymbol \Psi\)</span>
<span class="math display">\[
\boldsymbol k= (k_1,...,k_d)^T = \text{Diag}\left(\boldsymbol \Psi^T\boldsymbol \Psi\right)=\text{Diag}\left(\boldsymbol Q_2\boldsymbol P\boldsymbol Q_2^T\right)
\]</span>
Each <span class="math inline">\(k_j\)</span> is the contribution
of <span class="math inline">\(z_j\)</span> to <span class="math inline">\(\text{Tr}\left( \boldsymbol Q_2 \boldsymbol P\boldsymbol Q_2^T \right)= \text{Tr}(\boldsymbol P) = d\)</span>
i.e. the total variation based on <span class="math inline">\(\boldsymbol P\)</span>.
As <span class="math inline">\(\text{Tr}(\boldsymbol P)=d\)</span> is constant this implies that there are only <span class="math inline">\(d-1\)</span> independent <span class="math inline">\(k_j\)</span>.</p>
<p>In PCA-cor-whitening we wish to concentrate most of the contributions to the total variation based on <span class="math inline">\(\boldsymbol P\)</span> in a small number of latent components.</p>
<p><em>PCA-cor whitening objective function</em>: find an optimal optimal <span class="math inline">\(\boldsymbol Q_2\)</span> so that
the resulting set <span class="math inline">\(k_1 \geq k_2 \ldots \geq k_d\)</span> in <span class="math inline">\(\boldsymbol k= \text{Diag}\left(\boldsymbol Q_2\boldsymbol P\boldsymbol Q_2^T\right)\)</span> majorizes any other set of relative contributions.</p>
<p><em>Solution:</em></p>
<p>Following the earlier discussion we apply Schur’s theorem and find the optimal
solution by diagonalising <span class="math inline">\(\boldsymbol \Psi^T\boldsymbol \Psi\)</span> through eigendecomposition of <span class="math inline">\(\boldsymbol P= \boldsymbol G\boldsymbol \Theta\boldsymbol G^T\)</span>.
Hence, the optimal value for the <span class="math inline">\(\boldsymbol Q_2\)</span> matrix is
<span class="math display">\[
\boldsymbol Q_2^{\text{PCA-Cor}}=\boldsymbol G^T
\]</span>
Again <span class="math inline">\(\boldsymbol G\)</span> is not uniquely defined — you are free to change signs of the columns.
The corresponding whitening matrix is
<span class="math display">\[
\boldsymbol Q_2^{\text{PCA-Cor}}=\boldsymbol G^T
\]</span>
The corresponding whitening matrix is<br><span class="math display">\[
\boldsymbol W^{\text{PCA-Cor}} = \boldsymbol \Theta^{-1/2} \boldsymbol G^T \boldsymbol V^{-1/2}
\]</span><br>
and the cross-covariance matrix is
<span class="math display">\[
\boldsymbol \Phi^{\text{PCA-Cor}} = \boldsymbol V^{1/2} \boldsymbol G\boldsymbol \Theta^{1/2} 
\]</span>
and the cross-correlation matrix is
<span class="math display">\[
\boldsymbol \Psi^{\text{PCA-Cor}} = \boldsymbol G\boldsymbol \Theta^{1/2} 
\]</span></p>
<p><em>Identifiability:</em></p>
<p>As with PCA whitening, there are sign ambiguities in the above because the column signs of <span class="math inline">\(\boldsymbol G\)</span>
can be freely chosen. For identifiability we may wish to impose further constraints
on <span class="math inline">\(\boldsymbol Q_2^{\text{PCA-Cor}}\)</span> or equivalently on <span class="math inline">\(\boldsymbol \Psi^{\text{PCA-Cor}}\)</span>. A useful condition is to require (for the given
ordering of the original variables!)
that the diagonal elements of <span class="math inline">\(\boldsymbol Q_2^{\text{PCA-Cor}}\)</span> are all positive or equivalently that <span class="math inline">\(\boldsymbol \Psi^{\text{PCA-Cor}}\)</span> has a positive diagonal.
This implies that
<span class="math inline">\(\text{Diag}(\boldsymbol G) &gt; 0\)</span> and <span class="math inline">\(\text{Diag}(\boldsymbol \Phi^{\text{PCA-Cor}}) &gt; 0\)</span>.</p>
<p>Note that the actual objective of PCA-cor whitening <span class="math inline">\(\text{Diag}(\boldsymbol \Psi^T\boldsymbol \Psi)\)</span> is not affected by the sign ambiguity
since the column signs of <span class="math inline">\(\boldsymbol \Psi\)</span> do not matter.</p>
<p><em>Proportion of total variation:</em></p>
<p>In PCA-cor whitening the contribution <span class="math inline">\(k_i^{\text{PCA-Cor}}\)</span> of each latent component
<span class="math inline">\(z_i\)</span>
to the total variation based on the correlation <span class="math inline">\(\text{Tr}(\boldsymbol P) = d\)</span> is
<span class="math inline">\(k_i^{\text{PCA-Cor}} = \theta_i\)</span>.
The fraction <span class="math inline">\(\frac{\theta_i}{d}\)</span> is the relative
contribution of each element in <span class="math inline">\(\boldsymbol z\)</span> to explain the total variation.</p>
<p><em>Summary:</em></p>
<ul>
<li>PCA-cor whitening is a whitening transformation that maximises compression with the sum of squared cross-correlations as underlying optimality criterion.</li>
<li>There are sign ambiguities in the PCA-cor whitened variables which are inherited from the sign ambiguities in the eigenvectors.</li>
<li>If a positive-diagonal condition on the orthogonal matrices is imposed then these sign ambiguities are fully resolved and corresponding components <span class="math inline">\(z_i\)</span> and <span class="math inline">\(x_i\)</span> are always positively correlated.</li>
<li>If <span class="math inline">\(\boldsymbol x\)</span> is standardised to <span class="math inline">\(\text{Var}(x_i)=1\)</span>, then PCA and PCA-cor whitening are identical.</li>
</ul>
</div>
<div id="cholesky-whitening" class="section level3" number="2.4.5">
<h3>
<span class="header-section-number">2.4.5</span> Cholesky whitening<a class="anchor" aria-label="anchor" href="#cholesky-whitening"><i class="fas fa-link"></i></a>
</h3>
<p><strong>Aim in Cholesky whitening:</strong></p>
<p>Find a whitening transformation such that the cross-covariance <span class="math inline">\(\boldsymbol \Phi\)</span> and cross-correlation <span class="math inline">\(\boldsymbol \Psi\)</span> have lower triangular structure. Specifically, we wish that the original variable <span class="math inline">\(x_1\)</span> is linked
with the first latent variable <span class="math inline">\(z_1\)</span> only, the second original variable <span class="math inline">\(x_2\)</span> is linked to
<span class="math inline">\(z_1\)</span> and <span class="math inline">\(z_2\)</span> only, and so on, and the last variable <span class="math inline">\(x_d\)</span> is linked with all latent variables
<span class="math inline">\(z_1, \ldots, z_d\)</span>:</p>
<p><span class="math display">\[
\begin{array}{cc}
x_1 &amp; \rightarrow z_1 \\
x_1, x_2 &amp; \rightarrow z_2 \\
\vdots\\
x_1, x_2, \ldots, x_d &amp; \rightarrow z_d \\
\end{array}
\]</span></p>
<p>Thus, Cholesky whitening imposes a structural (sparsity!) constraint on the loadings,
where the non-zero coefficients are all in the lower half whereas in the upper half
the coefficients all vanish.</p>
<p><strong>Cholesky matrix decomposition:</strong></p>
<p>In order to find such a whitening transformation we use the Cholesky decomposition</p>
<p>The Cholesky decomposition of a square matrix <span class="math inline">\(\boldsymbol A= \boldsymbol L\boldsymbol L^T\)</span> requires a positive definite <span class="math inline">\(\boldsymbol A\)</span> and is unique.
<span class="math inline">\(\boldsymbol L\)</span> is a lower triangular matrix with positive diagonal elements.
Its inverse <span class="math inline">\(\boldsymbol L^{-1}\)</span> is also lower triangular with positive diagonal elements.
If <span class="math inline">\(\boldsymbol D\)</span> is a diagonal matrix with positive elements then <span class="math inline">\(\boldsymbol D\boldsymbol L\)</span> is also a lower triangular matrix with a positive diagonal and the Cholesky factor for the matrix <span class="math inline">\(\boldsymbol D\boldsymbol A\boldsymbol D\)</span>.</p>
<p><em>Solution</em>: Apply a Cholesky decomposition to <span class="math inline">\(\boldsymbol \Sigma= \boldsymbol L\boldsymbol L^T\)</span></p>
<p>The resulting whitening matrix is
<span class="math display">\[
\boldsymbol W^{\text{Chol}}=\boldsymbol L^{-1}
\]</span><br>
By construction, <span class="math inline">\(\boldsymbol W^{\text{Chol}}\)</span> is a lower triangular matrix with positive
diagonal. The whitening constraint is satisfied as
<span class="math inline">\((\boldsymbol W^{\text{Chol}})^T\boldsymbol W^{\text{Chol}} = (\boldsymbol L^{-1})^T \boldsymbol L^{-1} = (\boldsymbol L^T)^{-1} \boldsymbol L^{-1} = (\boldsymbol L\boldsymbol L^T)^{-1} = \boldsymbol \Sigma^{-1}\)</span>.</p>
<p>The cross-covariance matrix is the inverse of the whitening matrix
<span class="math display">\[
\boldsymbol \Phi^{\text{Chol}} = \boldsymbol L
\]</span>
and the cross-correlation matrix is
<span class="math display">\[
\boldsymbol \Psi^{\text{Chol}} = \boldsymbol V^{-1/2} \boldsymbol L
\]</span>
Both <span class="math inline">\(\boldsymbol \Phi^{\text{Chol}}\)</span> and
<span class="math inline">\(\boldsymbol \Psi^{\text{Chol}}\)</span> are
lower triangular matrices with positive diagonal elements.
Hence two corresponding components <span class="math inline">\(x_i\)</span> and <span class="math inline">\(z_i\)</span> are always positively correlated!</p>
<p>Finally, the corresponding orthogonal matrices are
<span class="math display">\[
\boldsymbol Q_1^{\text{Chol}}  =  \boldsymbol \Phi^T \boldsymbol \Sigma^{-1/2} =   \boldsymbol L^T \boldsymbol \Sigma^{-1/2}
\]</span>
and
<span class="math display">\[
\boldsymbol Q_2^{\text{Chol}} =  \boldsymbol \Psi^T \boldsymbol P^{-1/2} =  \boldsymbol L^T \boldsymbol V^{-1/2} \boldsymbol P^{-1/2} 
\]</span></p>
<p><em>Application to correlation instead of covariance</em>:</p>
<p>We may also apply the Cholesky decomposition to the correlation rather than the covariance matrix.
However, this does <em>not</em> lead to a different whitening transform (unlike for ZCA and PCA):</p>
<p>The Cholesky factor for <span class="math inline">\(\boldsymbol P= \boldsymbol V^{-1/2} \boldsymbol \Sigma\boldsymbol V^{-1/2}\)</span> is <span class="math inline">\(\boldsymbol V^{-1/2} \boldsymbol L\)</span>.
The corresponding whitening matrix is <span class="math inline">\((\boldsymbol V^{-1/2} \boldsymbol L)^{-1} \boldsymbol V^{-1/2} =\boldsymbol L^{-1} = \boldsymbol W^{\text{Chol}}\)</span>.</p>
<p>This is also intuively clear as the covariance and correlation loadings are
closely linked, in particular they share the same triangular shape.</p>
<p><em>Dependence on the input order</em>:</p>
<p>Cholesky whitening depends on the ordering of input variables.
Each ordering of the original variables will yield a different triangular
constraint and thus a different Cholesky whitening transform. For example,
by inverting the ordering to <span class="math inline">\(x_d, x_{d-1}, \ldots, x_1\)</span> we effectively enforce an upper triangular
shape.</p>
<p>An alternative formulation of Cholesky whitening decomposes the
precision matrix rather than the covariance matrix. This yields the
upper triangular structure directly and is otherwise fully equivalent to Cholesky whitening
based on decomposing the covariance.</p>
</div>
<div id="comparison-of-whitening-procedures---simulated-data" class="section level3" number="2.4.6">
<h3>
<span class="header-section-number">2.4.6</span> Comparison of whitening procedures - simulated data<a class="anchor" aria-label="anchor" href="#comparison-of-whitening-procedures---simulated-data"><i class="fas fa-link"></i></a>
</h3>
<p>For comparison, here are the results of ZCA, PCA and Cholesky whitening applied to a simulated bivariate normal data set with correlation <span class="math inline">\(\rho=0.8\)</span>.</p>
<div class="inline-figure"><img src="2-transformations-b_files/figure-html/fig1-1.png" width="672"></div>
<p>In column 1 you can see the simulated data as scatter plot.</p>
<p>Column 2 shows the scatter plots of the whitened data — as expect all three methods remove correlation and produce an isotropic covariance.</p>
<p>However, the three approaches differ in the cross-correlations. Columns 3 and 4 show the cross-correlations between the first two corresponding components (<span class="math inline">\(x_1\)</span> and <span class="math inline">\(z_1\)</span>, and <span class="math inline">\(x_2\)</span> and <span class="math inline">\(z_2\)</span>) for ZCA, PCA and Cholesky whitening. As expected, in ZCA both pairs show strong correlation, but this is not the case for PCA and Cholesky whitening.</p>
<p>Note that for Cholesky whitening the first component <span class="math inline">\(z_1\)</span>
is perfectly positively correlated with the original component <span class="math inline">\(x_1\)</span>
because the whitening matrix is lower triangular with a positive diagonal and hence <span class="math inline">\(z_1\)</span> is just <span class="math inline">\(x_1\)</span> multiplied with a positive constant.</p>
</div>
<div id="comparison-of-whitening-procedures---iris-flowers" class="section level3" number="2.4.7">
<h3>
<span class="header-section-number">2.4.7</span> Comparison of whitening procedures - iris flowers<a class="anchor" aria-label="anchor" href="#comparison-of-whitening-procedures---iris-flowers"><i class="fas fa-link"></i></a>
</h3>
<p>As an example we consider the well known <a href="https://en.wikipedia.org/wiki/Iris_flower_data_set">iris flower data set</a>. It consists of botanical measures (sepal length, sepal width,
petal length and petal width) for 150 iris flowers comprising
three species (<a href="https://en.wikipedia.org/wiki/Iris_setosa">Iris setosa</a>, <a href="https://en.wikipedia.org/wiki/Iris_versicolor">Iris versicolor</a>, <a href="https://en.wikipedia.org/wiki/Iris_virginica">Iris virginica</a>). Hence this data set has dimension <span class="math inline">\(d=4\)</span> and sample size <span class="math inline">\(n=150\)</span>.</p>
<p>We apply all discussed whitening transforms to this data, and then sort the whitened components by their relative contribution to the total variation. For Cholesky whitening we used the
input order for the shape constraint.</p>
<p>Here are the results for explained variation based on covariance loadings:</p>
<div class="inline-figure"><img src="2-transformations-b_files/figure-html/unnamed-chunk-2-1.png" width="384"></div>
<p>As expected, the two PCA whitening approaches compress the data most.
On the other end of the spectrum, the ZCA whitening methods are the two least
compressing approaches. Cholesky whitening is a compromise between ZCA and PCA in terms
of compression.</p>
<p>Similar results are obtained based on correlation loadings - note how ZCA-cor provides
equal weight for each latent variable.</p>
<div class="inline-figure"><img src="2-transformations-b_files/figure-html/unnamed-chunk-3-1.png" width="384"></div>
</div>
<div id="recap" class="section level3" number="2.4.8">
<h3>
<span class="header-section-number">2.4.8</span> Recap<a class="anchor" aria-label="anchor" href="#recap"><i class="fas fa-link"></i></a>
</h3>
<div class="inline-table"><table class="table table-sm">
<colgroup>
<col width="31%">
<col width="68%">
</colgroup>
<thead><tr class="header">
<th>Method</th>
<th>Type of usage</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>ZCA, ZCA-cor:</td>
<td>pure decorrelate, maintain similarity to original data set, interpretability</td>
</tr>
<tr class="even">
<td>PCA, PCA-cor:</td>
<td>compression, find effective dimension, reduce dimensionality, feature identification</td>
</tr>
<tr class="odd">
<td>Cholesky</td>
<td>triangular shaped <span class="math inline">\(\boldsymbol W\)</span>, <span class="math inline">\(\boldsymbol \Phi\)</span> and <span class="math inline">\(\boldsymbol \Psi\)</span>, sparsity</td>
</tr>
</tbody>
</table></div>
<p>If data are standardised the <span class="math inline">\(\boldsymbol \Phi\)</span> and <span class="math inline">\(\boldsymbol \Psi\)</span> will be the same and
hence ZCA will become ZCA-cor and PCA becomes PCA-cor. The triangular shape constraint of
Cholesky whitening depends on the ordering of the original variables.</p>
<p><strong>Related methods not discussed in this course:</strong></p>
<ul>
<li><p>Factor models: essentially whitening plus an additional error term, factors have rotational
freedom just like in whitening</p></li>
<li><p>Partial Least Squares (PLS): similar to Principal Components Analysis (PCA) but in a regression setting (with the choice of
latent variables depending on the response)</p></li>
</ul>
</div>
</div>
<div id="principal-component-analysis-pca" class="section level2" number="2.5">
<h2>
<span class="header-section-number">2.5</span> Principal Component Analysis (PCA)<a class="anchor" aria-label="anchor" href="#principal-component-analysis-pca"><i class="fas fa-link"></i></a>
</h2>
<div id="pca-transformation" class="section level3" number="2.5.1">
<h3>
<span class="header-section-number">2.5.1</span> PCA transformation<a class="anchor" aria-label="anchor" href="#pca-transformation"><i class="fas fa-link"></i></a>
</h3>
<p>Principal component analysis was proposed in 1933 by Harald Hotelling<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;Hotelling, H. 1933. Analysis of a complex of statistical variables into principal components.
Journal of Educational Psychology &lt;strong&gt;24&lt;/strong&gt;:417–441 (Part 1) and &lt;strong&gt;24&lt;/strong&gt;:498–520 (Part 2).
&lt;a href="https://doi.org/10.1037/h0071325" class="uri"&gt;https://doi.org/10.1037/h0071325&lt;/a&gt; and &lt;a href="https://doi.org/10.1037/h0070888" class="uri"&gt;https://doi.org/10.1037/h0070888&lt;/a&gt;&lt;/p&gt;'><sup>6</sup></a> and is very closely related to <strong>PCA whitening</strong>. The underlying mathematics was developed earlier in 1901 by Karl Pearson<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;Pearson, K. 1901. On lines and planes of closest fit to systems of
points in space. Philosophical Magazine &lt;strong&gt;2&lt;/strong&gt;:559–572. &lt;a href="https://doi.org/10.1080/14786440109462720" class="uri"&gt;https://doi.org/10.1080/14786440109462720&lt;/a&gt;&lt;/p&gt;'><sup>7</sup></a> for the problem of orthogonal regression.</p>
<p>Assume random vector <span class="math inline">\(\boldsymbol x\)</span> with <span class="math inline">\(\text{Var}(\boldsymbol x) = \boldsymbol \Sigma= \boldsymbol U\boldsymbol \Lambda\boldsymbol U^T\)</span>.
PCA is a particular orthogonal transformation of the original <span class="math inline">\(\boldsymbol x\)</span>
such that the resulting components are orthogonal:
<span class="math display">\[
\underbrace{\boldsymbol t^{\text{PCA}}}_{\text{Principal components}} = \underbrace{\boldsymbol U^T}_{\text{Orthogonal matrix}}   \boldsymbol x
\]</span>
<span class="math display">\[\text{Var}(\boldsymbol t^{\text{PCA}}) = \boldsymbol \Lambda= \begin{pmatrix} \lambda_1 &amp; \dots &amp; 0 \\ \vdots &amp; \ddots &amp; \vdots \\ 0 &amp; \dots &amp; \lambda_d\end{pmatrix}\]</span>
Note that while principal components are <em>orthogonal</em> they do <em>not</em> have unit variance but the variance of principal components <span class="math inline">\(t_i\)</span> equals the eigenvalues <span class="math inline">\(\lambda_i\)</span>.</p>
<p>Thus PCA itself is <em>not</em> a whitening procedure. However, you arrive at PCA whitening by simply by standardising the PCA components: <span class="math inline">\(\boldsymbol z^{\text{PCA}} = \boldsymbol \Lambda^{-1/2} \boldsymbol t^{\text{PCA}}\)</span></p>
<p><strong>Compression properties:</strong></p>
<p>The total variation is <span class="math inline">\(\text{Tr}(\text{Var}(\boldsymbol t^{\text{PCA}})) = \text{Tr}( \boldsymbol \Lambda) = \sum^d_{j=1}\lambda_j\)</span>.
With principle components the fraction <span class="math inline">\(\frac{\lambda_i}{\sum^d_{j=1}\lambda_j}\)</span> can be interpreted as the proportion of variation contributed by
each component in <span class="math inline">\(\boldsymbol t^{\text{PCA}}\)</span> to the total variation. Thus, low ranking components in <span class="math inline">\(\boldsymbol t^{\text{PCA}}\)</span> with low variation may be discarded, thus leading to a reduction in dimension.</p>
</div>
<div id="application-to-data" class="section level3" number="2.5.2">
<h3>
<span class="header-section-number">2.5.2</span> Application to data<a class="anchor" aria-label="anchor" href="#application-to-data"><i class="fas fa-link"></i></a>
</h3>
<p>Written in terms of a data matrix <span class="math inline">\(\boldsymbol X\)</span> instead of a random vector <span class="math inline">\(\boldsymbol x\)</span> PCA becomes:
<span class="math display">\[\underbrace{\boldsymbol T}_{\text{Sample version of principal components}}=\underbrace{\boldsymbol X}_{\text{Data matrix}}\boldsymbol U\]</span>
There are now two ways to obtain <span class="math inline">\(\boldsymbol U\)</span>:</p>
<ol style="list-style-type: decimal">
<li><p>Estimate the covariance matrix, e.g. by <span class="math inline">\(\hat{\boldsymbol \Sigma} = \frac{1}{n}\boldsymbol X_c^T\boldsymbol X_c\)</span> where <span class="math inline">\(\boldsymbol X_c\)</span> is the column-centred data matrix; then apply the eigenvalue decomposition on <span class="math inline">\(\hat{\boldsymbol \Sigma}\)</span> to get <span class="math inline">\(\boldsymbol U\)</span>.</p></li>
<li><p>Compute the singular value decomposition of <span class="math inline">\(\boldsymbol X_c = \boldsymbol V\boldsymbol D\boldsymbol U^T\)</span>. As <span class="math inline">\(\hat{\boldsymbol \Sigma} = \frac{1}{n}\boldsymbol X_c^T\boldsymbol X_c = \boldsymbol U(\frac{1}{n}\boldsymbol D^2)\boldsymbol U^T\)</span> you can just use <span class="math inline">\(\boldsymbol U\)</span> from the SVD of <span class="math inline">\(\boldsymbol X_c\)</span> and there is no need to compute the covariance.</p></li>
</ol>
</div>
<div id="iris-flower-data-example" class="section level3" number="2.5.3">
<h3>
<span class="header-section-number">2.5.3</span> Iris flower data example<a class="anchor" aria-label="anchor" href="#iris-flower-data-example"><i class="fas fa-link"></i></a>
</h3>
<p>We first standardise the data, then compute PCA components and plot the proportion of total variation contributed by each component.
This shows that only two PCA components are needed to achieve 95% of the total variation:</p>
<div class="inline-figure"><img src="2-transformations-c_files/figure-html/fig2-1.png" width="384"></div>
<p>A scatter plot plot of the the first two principal components is also informative:</p>
<div class="inline-figure"><img src="2-transformations-c_files/figure-html/fig3-1.png" width="432"></div>
<p>This shows that there groupings among the
150 flowers, corresponding to the species, and that these groups can be characterised
by the the principal components.</p>
</div>
</div>
<div id="correlation-loadings-plot-to-interpret-pca-components" class="section level2" number="2.6">
<h2>
<span class="header-section-number">2.6</span> Correlation loadings plot to interpret PCA components<a class="anchor" aria-label="anchor" href="#correlation-loadings-plot-to-interpret-pca-components"><i class="fas fa-link"></i></a>
</h2>
<div id="pca-correlation-loadings" class="section level3" number="2.6.1">
<h3>
<span class="header-section-number">2.6.1</span> PCA correlation loadings<a class="anchor" aria-label="anchor" href="#pca-correlation-loadings"><i class="fas fa-link"></i></a>
</h3>
<p>In an earlier section we have learned that for a general whitening transformation the cross-correlations <span class="math inline">\(\boldsymbol \Psi=\text{Cor}(\boldsymbol x, \boldsymbol z)\)</span> play the role of correlation loadings in the inverse transformation:
<span class="math display">\[
\boldsymbol V^{-1/2} \boldsymbol x= \boldsymbol \Psi\boldsymbol z\, , 
\]</span>
i.e. they are the coefficients linking the whitened variable <span class="math inline">\(\boldsymbol z\)</span> with the standardised original variable <span class="math inline">\(\boldsymbol x\)</span>.
This relationship holds therefore also for PCA-whitening
with <span class="math inline">\(\boldsymbol z^{\text{PCA}}= \boldsymbol \Lambda^{-1/2} \boldsymbol U^T \boldsymbol x\)</span> and <span class="math inline">\(\boldsymbol \Psi^{\text{PCA}} = \boldsymbol V^{-1/2} \boldsymbol U\boldsymbol \Lambda^{1/2}\)</span>.</p>
<p>The classical PCA is not a whitening approach because <span class="math inline">\(\text{Var}(\boldsymbol t^{\text{PCA}}) \neq \boldsymbol I\)</span>. However, we can still compute cross-correlations between <span class="math inline">\(\boldsymbol x\)</span> and
the principal components <span class="math inline">\(\boldsymbol t^{\text{PCA}}\)</span>, resulting in
<span class="math display">\[
\text{Cor}(\boldsymbol x, \boldsymbol t^{\text{PCA}}) = \boldsymbol V^{-1/2} \boldsymbol U\boldsymbol \Lambda^{1/2}  = \boldsymbol \Psi^{\text{PCA}}
\]</span>
Note these are the same as the cross-correlations for PCA-whitening since
<span class="math inline">\(\boldsymbol t^{\text{PCA}}\)</span> and <span class="math inline">\(\boldsymbol z^{\text{PCA}}\)</span> only differ in scale.</p>
<p>The inverse PCA transformation is
<span class="math display">\[
\boldsymbol x= \boldsymbol U\boldsymbol t^{\text{PCA}}
\]</span>
In terms of standardised PCA components <span class="math inline">\(\boldsymbol z^{\text{PCA}} = \boldsymbol \Lambda^{-1/2} \boldsymbol t^{\text{PCA}}\)</span> and standardised original components it becomes
<span class="math display">\[
\boldsymbol V^{-1/2} \boldsymbol x= \boldsymbol \Psi\boldsymbol \Lambda^{-1/2} \boldsymbol t^{\text{PCA}}
\]</span>
Thus the cross-correlation matrix <span class="math inline">\(\boldsymbol \Psi\)</span> plays the role of <em>correlation loadings</em>
also in classical PCA, i.e. they are the
coefficients linking the standardised PCA components with the standardised original components.</p>
</div>
<div id="pca-correlation-loadings-plot" class="section level3" number="2.6.2">
<h3>
<span class="header-section-number">2.6.2</span> PCA correlation loadings plot<a class="anchor" aria-label="anchor" href="#pca-correlation-loadings-plot"><i class="fas fa-link"></i></a>
</h3>
<p>In PCA and PCA-cor whitening as well as in classical PCA the aim is compression, i.e.
to find latent variables such that most of the total variation is contributed by
a small number of components.</p>
<p>In order to be able to better interpret the top ranking PCA component we can use a visual device called <em>correlation loadings plot</em>. For this we compute the correlation between the PCA components 1 and 2 (<span class="math inline">\(t_1^{\text{PCA}}\)</span> and <span class="math inline">\(t_2^{\text{PCA}})\)</span> with all original variables <span class="math inline">\(x_1, \ldots, x_d\)</span>.</p>
<p>For each original variable <span class="math inline">\(x_i\)</span> we therefore have two numbers between -1 and 1, the correlation
<span class="math inline">\(\text{Cor}(x_i, t_1^{\text{PCA}}) = \psi_{i1}\)</span> and <span class="math inline">\(\text{Cor}(x_i, t_2^{\text{PCA}}) = \psi_{i2}\)</span> that we use as coordinates to draw a point in a plane. Recall that the
row sums of squares of the correlation loadings <span class="math inline">\(\boldsymbol \Psi\)</span> are all identical to 1.
Hence, the sum of the squared loadings from just the first two components is also at most 1.
Thus, by construction, all points
have to lie within a unit circle around the origin.<br>
The original variables most strongly influenced
by the two latent variables will have strong correlation and thus lie near the outer circle, whereas variables that are not influenced by the two latent variables will lie near the origin.</p>
<p>As an example, here is the correlation loadings plot showing the cross-correlation between the first two
PCA components and all four variables of the iris flower data set discussed earlier.</p>
<div class="inline-figure"><img src="2-transformations-c_files/figure-html/fig4-1.png" width="384"></div>
<p>The interpretation of this plot is discussed in Worksheet 4.</p>
</div>
</div>
<div id="canonical-correlation-analysis-cca-aka-cca-whitening" class="section level2" number="2.7">
<h2>
<span class="header-section-number">2.7</span> Canonical Correlation Analysis (CCA) aka CCA whitening<a class="anchor" aria-label="anchor" href="#canonical-correlation-analysis-cca-aka-cca-whitening"><i class="fas fa-link"></i></a>
</h2>
<p>Canonical correlation analysis was invented by Harald Hotelling in 1936.<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;Hotelling, H. 1936. Relations between two sets of variates. Biometrika &lt;strong&gt;28&lt;/strong&gt;:321–377. &lt;a href="https://doi.org/10.1093/biomet/28.3-4.321" class="uri"&gt;https://doi.org/10.1093/biomet/28.3-4.321&lt;/a&gt;&lt;/p&gt;'><sup>8</sup></a></p>
<p>So far, we have looked only into whitening as a <strong>single</strong> vector <span class="math inline">\(\boldsymbol x\)</span>. In CCA whitening we consider <strong>two vectors</strong> <span class="math inline">\(\boldsymbol x\)</span> and <span class="math inline">\(\boldsymbol y\)</span> simultaneously:</p>
<p><span class="math display">\[\begin{align*}
\begin{array}{ll}
\boldsymbol x= \begin{pmatrix} x_1 \\ \vdots \\ x_p \end{pmatrix} \\
\text{Dimension } p
\end{array}
\begin{array}{ll}
\boldsymbol y= \begin{pmatrix} y_1 \\ \vdots \\ y_q \end{pmatrix} \\
\text{Dimension } q
\end{array}
\begin{array}{ll}
\text{Var}(\boldsymbol x) = \boldsymbol \Sigma_{\boldsymbol x} = \boldsymbol V_{\boldsymbol x}^{1/2}\boldsymbol P_{\boldsymbol x}\boldsymbol V_{\boldsymbol x}^{1/2} \\
\text{Var}(\boldsymbol y) = \boldsymbol \Sigma_{\boldsymbol y} = \boldsymbol V_{\boldsymbol y}^{1/2}\boldsymbol P_{\boldsymbol y}\boldsymbol V_{\boldsymbol y}^{1/2} \\
\end{array}
\end{align*}\]</span></p>
<p><span class="math display">\[\begin{align*}
\begin{array}{cc}
\text{Whitening of } \boldsymbol x\text{:} \\
\text{Whitening of } \boldsymbol y\text{:}
\end{array}
\begin{array}{cc}
\boldsymbol z_{\boldsymbol x} = \boldsymbol W_{\boldsymbol x}\boldsymbol x=\boldsymbol Q_{\boldsymbol x}\boldsymbol P_{\boldsymbol x}^{-1/2}\boldsymbol V_{\boldsymbol x}^{-1/2}\boldsymbol x\\
\boldsymbol z_{\boldsymbol y} = \boldsymbol W_{\boldsymbol y}\boldsymbol y=\boldsymbol Q_{\boldsymbol y}\boldsymbol P_{\boldsymbol y}^{-1/2}\boldsymbol V_{\boldsymbol y}^{-1/2}\boldsymbol y
\end{array}
\end{align*}\]</span>
(note we use the correlation-based form of <span class="math inline">\(\boldsymbol W\)</span>)</p>
<p>Cross-correlation between <span class="math inline">\(\boldsymbol z_{\boldsymbol y}\)</span> and <span class="math inline">\(\boldsymbol z_{\boldsymbol y}\)</span>:</p>
<p><span class="math display">\[\text{Cor}(\boldsymbol z_{\boldsymbol x},\boldsymbol z_{\boldsymbol y})=\boldsymbol Q_{\boldsymbol x}\boldsymbol K\boldsymbol Q_{\boldsymbol y}^T\]</span></p>
<p>with <span class="math inline">\(\boldsymbol K= \boldsymbol P_{\boldsymbol x}^{-1/2}\boldsymbol P_{\boldsymbol x\boldsymbol y}\boldsymbol P_{\boldsymbol y}^{-1/2}\)</span>.</p>
<p><strong>Idea</strong>: we can choose suitable orthogonal matrices <span class="math inline">\(\boldsymbol Q_{\boldsymbol x}\)</span> and <span class="math inline">\(\boldsymbol Q_{\boldsymbol y}\)</span> by putting constraints on the cross-correlation.</p>
<p><strong>CCA</strong>: we aim for a <em>diagonal</em> <span class="math inline">\(\text{Cor}(\boldsymbol z_{\boldsymbol x},\boldsymbol z_{\boldsymbol y})\)</span> so that each component in <span class="math inline">\(\boldsymbol z_{\boldsymbol x}\)</span> only influences one (the corresponding) component in <span class="math inline">\(\boldsymbol z_{\boldsymbol y}\)</span>.</p>
<p><strong>Motivation</strong>: pairs of “modules” represented by components of <span class="math inline">\(\boldsymbol z_{\boldsymbol x}\)</span>
and <span class="math inline">\(\boldsymbol z_{\boldsymbol y}\)</span> influencing each other (and not anyone other module).</p>
<p><span class="math display">\[
\begin{array}{ll}
\boldsymbol z_{\boldsymbol x} = \begin{pmatrix} z^x_1 \\ z^x_2 \\ \vdots \\ z^x_p \end{pmatrix} &amp;
\boldsymbol z_{\boldsymbol y} = \begin{pmatrix} z^y_1 \\ z^y_2 \\ \vdots \\ z^y_q \end{pmatrix} \\
\end{array}
\]</span></p>
<p><span class="math display">\[\text{Cor}(\boldsymbol z_{\boldsymbol x},\boldsymbol z_{\boldsymbol y}) = \begin{pmatrix} d_1 &amp; \dots &amp; 0 \\ \vdots &amp;  \vdots \\ 0 &amp; \dots &amp; d_m \end{pmatrix}\]</span></p>
<p>where <span class="math inline">\(d_i\)</span> are the <em>canonical correlations</em> and <span class="math inline">\(m=\min(p,q)\)</span>.</p>
<div id="how-to-make-cross-correlation-matrix-textcorboldsymbol-z_boldsymbol-xboldsymbol-z_boldsymbol-y-diagonal" class="section level3" number="2.7.1">
<h3>
<span class="header-section-number">2.7.1</span> How to make cross-correlation matrix <span class="math inline">\(\text{Cor}(\boldsymbol z_{\boldsymbol x},\boldsymbol z_{\boldsymbol y})\)</span> diagonal?<a class="anchor" aria-label="anchor" href="#how-to-make-cross-correlation-matrix-textcorboldsymbol-z_boldsymbol-xboldsymbol-z_boldsymbol-y-diagonal"><i class="fas fa-link"></i></a>
</h3>
<ul>
<li>Use Singular Value Decomposition (SVD) of matrix <span class="math inline">\(\boldsymbol K\)</span>:<br><span class="math display">\[\boldsymbol K= (\boldsymbol Q_{\boldsymbol x}^{\text{CCA}})^T  \boldsymbol D\boldsymbol Q_{\boldsymbol y}^{\text{CCA}}\]</span>
where <span class="math inline">\(\boldsymbol D\)</span> is the diagonal matrix containing the singular values of <span class="math inline">\(\boldsymbol K\)</span>
</li>
<li>This yields orthogonal matrices <span class="math inline">\(\boldsymbol Q_{\boldsymbol x}^{\text{CCA}}\)</span> and <span class="math inline">\(\boldsymbol Q_{\boldsymbol y}^{\text{CCA}}\)</span> and thus the desired whitened matrices <span class="math inline">\(\boldsymbol W_{\boldsymbol x}^{\text{CCA}}\)</span> and <span class="math inline">\(\boldsymbol W_{\boldsymbol y}^{\text{CCA}}\)</span>
</li>
<li>As a result <span class="math inline">\(\text{Cor}(\boldsymbol z_{\boldsymbol x},\boldsymbol z_{\boldsymbol y}) = \boldsymbol D\)</span> i.e. singular values of <span class="math inline">\(\boldsymbol K\)</span> are identical to canonical correlations <span class="math inline">\(d_i\)</span>!</li>
</ul>
<p><span class="math inline">\(\longrightarrow\)</span> <span class="math inline">\(\boldsymbol Q_{\boldsymbol x}^{\text{CCA}}\)</span> and <span class="math inline">\(\boldsymbol Q_{\boldsymbol y}^{\text{CCA}}\)</span> are determined by the diagonality constraint (and are different to the other previously discussed whitening methods).</p>
<p>Note that the signs of corresponding in columns in <span class="math inline">\(\boldsymbol Q_{\boldsymbol x}^{\text{CCA}}\)</span> and <span class="math inline">\(\boldsymbol Q_{\boldsymbol y}^{\text{CCA}}\)</span> are not identified. Traditionally, in an SVD the
signs are chosen such that the singular values are positive. However, if we
impose positive-diagonality on <span class="math inline">\(\boldsymbol Q_{\boldsymbol x}^{\text{CCA}}\)</span> and <span class="math inline">\(\boldsymbol Q_{\boldsymbol y}^{\text{CCA}}\)</span>,
and thus positive-diagonality on the cross-correlations <span class="math inline">\(\boldsymbol \Psi_{\boldsymbol x}\)</span> and
<span class="math inline">\(\boldsymbol \Psi_{\boldsymbol y}\)</span>, then the canonical correlations may take on both positive and
negative values.</p>
</div>
<div id="related-methods" class="section level3" number="2.7.2">
<h3>
<span class="header-section-number">2.7.2</span> Related methods<a class="anchor" aria-label="anchor" href="#related-methods"><i class="fas fa-link"></i></a>
</h3>
<ul>
<li><p>O2PLS: similar to CCA but using orthogonal projections rather than whitening.</p></li>
<li><p>Vector correlation: aggregates the squared canonical correlations into a single overall measure
of association between two random vectors <span class="math inline">\(\boldsymbol x\)</span> and <span class="math inline">\(\boldsymbol y\)</span> (see Chapter 5
on multivariate dependencies).</p></li>
<li><p>nonlinear dimension reduction methods such as SNE, tSNE, UMAP.</p></li>
</ul>
</div>
</div>
</div>

  <div class="chapter-nav">
<div class="prev"><a href="multivariate-random-variables.html"><span class="header-section-number">1</span> Multivariate random variables</a></div>
<div class="next"><a href="unsupervised-learning-and-clustering.html"><span class="header-section-number">3</span> Unsupervised learning and clustering</a></div>
</div></main><div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <nav id="toc" data-toggle="toc" aria-label="On this page"><h2>On this page</h2>
      <ul class="nav navbar-nav">
<li><a class="nav-link" href="#transformations-and-dimension-reduction"><span class="header-section-number">2</span> Transformations and dimension reduction</a></li>
<li>
<a class="nav-link" href="#linear-transformations"><span class="header-section-number">2.1</span> Linear Transformations</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#location-scale-transformation"><span class="header-section-number">2.1.1</span> Location-scale transformation</a></li>
<li><a class="nav-link" href="#squared-multiple-correlation"><span class="header-section-number">2.1.2</span> Squared multiple correlation</a></li>
<li><a class="nav-link" href="#invertible-location-scale-transformation"><span class="header-section-number">2.1.3</span> Invertible location-scale transformation</a></li>
<li><a class="nav-link" href="#transformation-of-a-density-under-an-invertible-location-scale-transformation"><span class="header-section-number">2.1.4</span> Transformation of a density under an invertible location-scale transformation:</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#nonlinear-transformations"><span class="header-section-number">2.2</span> Nonlinear transformations</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#general-transformation"><span class="header-section-number">2.2.1</span> General transformation</a></li>
<li><a class="nav-link" href="#delta-method"><span class="header-section-number">2.2.2</span> Delta method</a></li>
<li><a class="nav-link" href="#transformation-of-a-probability-density-function-under-a-general-invertible-transformation"><span class="header-section-number">2.2.3</span> Transformation of a probability density function under a general invertible transformation</a></li>
<li><a class="nav-link" href="#normalising-flows"><span class="header-section-number">2.2.4</span> Normalising flows</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#whitening-transformations"><span class="header-section-number">2.3</span> Whitening transformations</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#overview"><span class="header-section-number">2.3.1</span> Overview</a></li>
<li><a class="nav-link" href="#general-whitening-transformation"><span class="header-section-number">2.3.2</span> General whitening transformation</a></li>
<li><a class="nav-link" href="#cross-covariance-and-cross-correlation-for-whitening-transformations"><span class="header-section-number">2.3.3</span> Cross-covariance and cross-correlation for whitening transformations</a></li>
<li><a class="nav-link" href="#inverse-whitening-transformation-and-loadings"><span class="header-section-number">2.3.4</span> Inverse whitening transformation and loadings</a></li>
<li><a class="nav-link" href="#summaries-of-cross-covariance-boldsymbol-phi-and-cross-correlation-boldsymbol-psi-resulting-from-whitening-transformations"><span class="header-section-number">2.3.5</span> Summaries of cross-covariance \(\boldsymbol \Phi\) and cross-correlation \(\boldsymbol \Psi\) resulting from whitening transformations</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#natural-whitening-procedures"><span class="header-section-number">2.4</span> Natural whitening procedures</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#zca-whitening"><span class="header-section-number">2.4.1</span> ZCA whitening</a></li>
<li><a class="nav-link" href="#zca-cor-whitening"><span class="header-section-number">2.4.2</span> ZCA-Cor whitening</a></li>
<li><a class="nav-link" href="#pca-whitening"><span class="header-section-number">2.4.3</span> PCA whitening</a></li>
<li><a class="nav-link" href="#pca-cor-whitening"><span class="header-section-number">2.4.4</span> PCA-cor whitening</a></li>
<li><a class="nav-link" href="#cholesky-whitening"><span class="header-section-number">2.4.5</span> Cholesky whitening</a></li>
<li><a class="nav-link" href="#comparison-of-whitening-procedures---simulated-data"><span class="header-section-number">2.4.6</span> Comparison of whitening procedures - simulated data</a></li>
<li><a class="nav-link" href="#comparison-of-whitening-procedures---iris-flowers"><span class="header-section-number">2.4.7</span> Comparison of whitening procedures - iris flowers</a></li>
<li><a class="nav-link" href="#recap"><span class="header-section-number">2.4.8</span> Recap</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#principal-component-analysis-pca"><span class="header-section-number">2.5</span> Principal Component Analysis (PCA)</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#pca-transformation"><span class="header-section-number">2.5.1</span> PCA transformation</a></li>
<li><a class="nav-link" href="#application-to-data"><span class="header-section-number">2.5.2</span> Application to data</a></li>
<li><a class="nav-link" href="#iris-flower-data-example"><span class="header-section-number">2.5.3</span> Iris flower data example</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#correlation-loadings-plot-to-interpret-pca-components"><span class="header-section-number">2.6</span> Correlation loadings plot to interpret PCA components</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#pca-correlation-loadings"><span class="header-section-number">2.6.1</span> PCA correlation loadings</a></li>
<li><a class="nav-link" href="#pca-correlation-loadings-plot"><span class="header-section-number">2.6.2</span> PCA correlation loadings plot</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#canonical-correlation-analysis-cca-aka-cca-whitening"><span class="header-section-number">2.7</span> Canonical Correlation Analysis (CCA) aka CCA whitening</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#how-to-make-cross-correlation-matrix-textcorboldsymbol-z_boldsymbol-xboldsymbol-z_boldsymbol-y-diagonal"><span class="header-section-number">2.7.1</span> How to make cross-correlation matrix \(\text{Cor}(\boldsymbol z_{\boldsymbol x},\boldsymbol z_{\boldsymbol y})\) diagonal?</a></li>
<li><a class="nav-link" href="#related-methods"><span class="header-section-number">2.7.2</span> Related methods</a></li>
</ul>
</li>
</ul>

      <div class="book-extra">
        <ul class="list-unstyled">
          
        </ul>
</div>
    </nav>
</div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5"><div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong>Multivariate Statistics and Machine Learning</strong>" was written by Korbinian Strimmer. It was last built on 29 May 2022.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>This book was built by the <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer><!-- dynamically load mathjax for compatibility with self-contained --><script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script><script type="text/x-mathjax-config">const popovers = document.querySelectorAll('a.footnote-ref[data-toggle="popover"]');
for (let popover of popovers) {
  const div = document.createElement('div');
  div.setAttribute('style', 'position: absolute; top: 0, left:0; width:0, height:0, overflow: hidden; visibility: hidden;');
  div.innerHTML = popover.getAttribute('data-content');

  var has_math = div.querySelector("span.math");
  if (has_math) {
    document.body.appendChild(div);
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, div]);
    MathJax.Hub.Queue(function() {
      popover.setAttribute('data-content', div.innerHTML);
      document.body.removeChild(div);
    })
  }
}
</script>
</body>
</html>
