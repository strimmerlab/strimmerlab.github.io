<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>3 Unsupervised learning and clustering | Multivariate Statistics and Machine Learning</title>
<meta name="author" content="Korbinian Strimmer">
<meta name="generator" content="bookdown 0.26 with bs4_book()">
<meta property="og:title" content="3 Unsupervised learning and clustering | Multivariate Statistics and Machine Learning">
<meta property="og:type" content="book">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="3 Unsupervised learning and clustering | Multivariate Statistics and Machine Learning">
<!-- JS --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script><script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet">
<script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script><script src="libs/bs3compat-0.3.1/transition.js"></script><script src="libs/bs3compat-0.3.1/tabs.js"></script><script src="libs/bs3compat-0.3.1/bs3compat.js"></script><link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet">
<script src="libs/bs4_book-1.0.0/bs4_book.js"></script><script src="libs/accessible-code-block-0.0.1/empty-anchor.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- CSS --><style type="text/css">
    
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  </style>
<meta name="description" content="3.1 Challenges in unsupervised learning  3.1.1 Objective We observe data \(\boldsymbol x_1, \ldots, \boldsymbol x_n\) for \(n\) objects (or subjects). Each sample \(\boldsymbol x_i\) is a vector...">
<meta property="og:description" content="3.1 Challenges in unsupervised learning  3.1.1 Objective We observe data \(\boldsymbol x_1, \ldots, \boldsymbol x_n\) for \(n\) objects (or subjects). Each sample \(\boldsymbol x_i\) is a vector...">
<meta name="twitter:description" content="3.1 Challenges in unsupervised learning  3.1.1 Objective We observe data \(\boldsymbol x_1, \ldots, \boldsymbol x_n\) for \(n\) objects (or subjects). Each sample \(\boldsymbol x_i\) is a vector...">
</head>
<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book"><a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h1>
        <a href="index.html" title="">Multivariate Statistics and Machine Learning</a>
      </h1>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
</form>

      <nav aria-label="Table of contents"><h2>Table of contents</h2>
        <ul class="book-toc list-unstyled">
<li><a class="" href="index.html">Welcome</a></li>
<li><a class="" href="preface.html">Preface</a></li>
<li><a class="" href="multivariate-random-variables.html"><span class="header-section-number">1</span> Multivariate random variables</a></li>
<li><a class="" href="transformations-and-dimension-reduction.html"><span class="header-section-number">2</span> Transformations and dimension reduction</a></li>
<li><a class="active" href="unsupervised-learning-and-clustering.html"><span class="header-section-number">3</span> Unsupervised learning and clustering</a></li>
<li><a class="" href="supervised-learning-and-classification.html"><span class="header-section-number">4</span> Supervised learning and classification</a></li>
<li><a class="" href="multivariate-dependencies.html"><span class="header-section-number">5</span> Multivariate dependencies</a></li>
<li><a class="" href="nonlinear-and-nonparametric-models.html"><span class="header-section-number">6</span> Nonlinear and nonparametric models</a></li>
<li class="book-part">Appendix</li>
<li><a class="" href="brief-refresher-on-matrices.html"><span class="header-section-number">A</span> Brief refresher on matrices</a></li>
<li><a class="" href="further-study.html"><span class="header-section-number">B</span> Further study</a></li>
<li><a class="" href="bibliography.html">Bibliography</a></li>
</ul>

        <div class="book-extra">
          
        </div>
      </nav>
</div>
  </header><main class="col-sm-12 col-md-9 col-lg-7" id="content"><div id="unsupervised-learning-and-clustering" class="section level1" number="3">
<h1>
<span class="header-section-number">3</span> Unsupervised learning and clustering<a class="anchor" aria-label="anchor" href="#unsupervised-learning-and-clustering"><i class="fas fa-link"></i></a>
</h1>
<div id="challenges-in-unsupervised-learning" class="section level2" number="3.1">
<h2>
<span class="header-section-number">3.1</span> Challenges in unsupervised learning<a class="anchor" aria-label="anchor" href="#challenges-in-unsupervised-learning"><i class="fas fa-link"></i></a>
</h2>
<div id="objective" class="section level3" number="3.1.1">
<h3>
<span class="header-section-number">3.1.1</span> Objective<a class="anchor" aria-label="anchor" href="#objective"><i class="fas fa-link"></i></a>
</h3>
<p>We observe data <span class="math inline">\(\boldsymbol x_1, \ldots, \boldsymbol x_n\)</span> for <span class="math inline">\(n\)</span> objects (or subjects).
Each sample <span class="math inline">\(\boldsymbol x_i\)</span> is a vector of dimension <span class="math inline">\(d\)</span>. Thus, for each of the <span class="math inline">\(n\)</span> objects / subjects we have measurements on <span class="math inline">\(d\)</span> variables.
The aim of unsupervised learning is to identify patters relating the objects/subjects based on the information available in <span class="math inline">\(\boldsymbol x_i\)</span>. Note that in unsupervised learning we use <em>only</em> the information
in <span class="math inline">\(\boldsymbol x_i\)</span> and nothing else.</p>
<p>For illustration consider the first two principal components of the Iris flower data (see e.g. Worksheet 4):</p>
<div class="inline-figure"><img src="3-clustering-a_files/figure-html/unnamed-chunk-1-1.png" width="672"></div>
<p>Clearly there is a group structure among the samples that is linked to particular
patterns in the first two principal components.</p>
<p>Note that in this plot we have used additional information, the class labels (setosa, versicolor, virginica), to highlighting the true underlying structure (the three flower species).</p>
<p>In <strong>unsupervised learning</strong> the class labels are (assumed to be) unknown, and the aim is to infer the clustering and thus the classes labels.<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;In contrast, in &lt;strong&gt;supervised learning&lt;/strong&gt; (to be discussed in a subsequent chapter) the class labels are known for a subset of the data (the training data set) and are required to learn a prediction function.&lt;/p&gt;"><sup>9</sup></a></p>
<p>There are many methods for clustering and unsupervise learning, both purely algorithmic as well as probabilistic. In this chapter we will study a few of the most commonly used approaches.</p>
</div>
<div id="questions-and-problems" class="section level3" number="3.1.2">
<h3>
<span class="header-section-number">3.1.2</span> Questions and problems<a class="anchor" aria-label="anchor" href="#questions-and-problems"><i class="fas fa-link"></i></a>
</h3>
<p>In order to implement unsupervised learning we need to address a number of questions:</p>
<ul>
<li>how do we define clusters?</li>
<li>how do we learn / infer clusters?</li>
<li>how many clusters are there? (this is surprisingly difficult!)</li>
<li>how can we assess the uncertainty of clusters?</li>
</ul>
<p>Once we know the clusters we are also interested in:</p>
<ul>
<li>which features define / separate each cluster?</li>
</ul>
<p>(note this is a feature / variable selection problem, discussed in in supervised learning).</p>
<p>Many of these problems and questions are highly specific to the data at hand.
Correspondingly, there are many different types of methods and models for clustering and unsupervised learning.</p>
<p>In terms of representing the data, unsupervised learning tries to balance between the following two extremes:</p>
<ol style="list-style-type: decimal">
<li>all objects are grouped into a single cluster (low complexity model)</li>
<li>all objects are put into their own cluster (high complexity model)</li>
</ol>
<p>In practise, the aim is to find a compromise, i.e. a model that captures the
structure in the data with appropriate complexity — not too low and not too complex.</p>
</div>
<div id="why-is-clustering-difficult" class="section level3" number="3.1.3">
<h3>
<span class="header-section-number">3.1.3</span> Why is clustering difficult?<a class="anchor" aria-label="anchor" href="#why-is-clustering-difficult"><i class="fas fa-link"></i></a>
</h3>
<p><strong>Partioning problem</strong> (combinatorics): How many partitions of <span class="math inline">\(n\)</span> objects (say flowers) into <span class="math inline">\(K\)</span> groups (say species) exists?</p>
<p><strong>Answer:</strong></p>
<p><span class="math display">\[
S(n,K) = \left\{\begin{array}{l} n \\ K \end{array} \right\}
\]</span>
this is the “Sterling number of the second type”.</p>
<p>For large n:
<span class="math display">\[
S(n,K) \approx \frac{K^n }{ K!}
\]</span>
Example:</p>
<div class="inline-table"><table class="table table-sm">
<thead><tr class="header">
<th><span class="math inline">\(n\)</span></th>
<th><span class="math inline">\(K\)</span></th>
<th>Number of possible partitions</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>15</td>
<td>3</td>
<td>
<span class="math inline">\(\approx\)</span> 2.4 million (<span class="math inline">\(10^6\)</span>)</td>
</tr>
<tr class="even">
<td>20</td>
<td>4</td>
<td>
<span class="math inline">\(\approx\)</span> 2.4 billion (<span class="math inline">\(10^9\)</span>)</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\vdots\)</span></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>100</td>
<td>5</td>
<td><span class="math inline">\(\approx 6.6 \times 10^{76}\)</span></td>
</tr>
</tbody>
</table></div>
<p>These are enormously big numbers even for relatively small problems!</p>
<p><span class="math inline">\(\Longrightarrow\)</span> Clustering / partitioning / structure discovery is not easy!</p>
<p><span class="math inline">\(\Longrightarrow\)</span> We cannot expect perfect answers or a single “true” clustering</p>
<p>In fact, as a model of the data many differnt clusterings may fit the data equally well.</p>
<p><span class="math inline">\(\Longrightarrow\)</span> We need to assesse the uncertainty of the clustering</p>
<p>This can be done as part of probabilistic modelling or by resampling (e.g., bootstrap).</p>
</div>
<div id="common-types-of-clustering-methods" class="section level3" number="3.1.4">
<h3>
<span class="header-section-number">3.1.4</span> Common types of clustering methods<a class="anchor" aria-label="anchor" href="#common-types-of-clustering-methods"><i class="fas fa-link"></i></a>
</h3>
<p>There are very many different clustering algorithms!</p>
<p>We consider the following two broad types of methods:</p>
<ol style="list-style-type: decimal">
<li>
<strong>Algorithmic clustering methods</strong> (these are not explicitly based on a probabilistic model)</li>
</ol>
<ul>
<li>
<span class="math inline">\(K\)</span>-means</li>
<li>PAM</li>
<li>hierarchical clustering (distance or similarity-based, divise and agglomerative)</li>
</ul>
<blockquote>
<p><strong>pros:</strong> fast, effective algorithms to find at least some grouping
<strong>cons:</strong> no probabilistic interpretation, blackbox methods</p>
</blockquote>
<ol start="2" style="list-style-type: decimal">
<li>
<strong>Model-based clustering</strong> (based on a probabilistic model)</li>
</ol>
<ul>
<li>mixture models (e.g. Gaussian mixture models, GMMs, non-hierarchical)</li>
<li>graphical models (e.g. Bayesian networks, Gaussian graphical models GGM, trees and networks)</li>
</ul>
<blockquote>
<p><strong>pros:</strong> full probabilistic model with all corresponding advantages
<strong>cons:</strong> computationally very expensive, sometimes impossible to compute exactly.</p>
</blockquote>
</div>
</div>
<div id="hierarchical-clustering" class="section level2" number="3.2">
<h2>
<span class="header-section-number">3.2</span> Hierarchical clustering<a class="anchor" aria-label="anchor" href="#hierarchical-clustering"><i class="fas fa-link"></i></a>
</h2>
<div id="tree-like-structures" class="section level3" number="3.2.1">
<h3>
<span class="header-section-number">3.2.1</span> Tree-like structures<a class="anchor" aria-label="anchor" href="#tree-like-structures"><i class="fas fa-link"></i></a>
</h3>
<p>Often, categorisations of objects are nested, i.e. there sub-categories of categories etc. These can be naturally represented by <strong>tree-like hierarchical structures</strong>.</p>
<p>In many branches of science hierarchical clusterings are widely employed, for example in evolutionary biology: see e.g. </p>
<ul>
<li>
<a href="http://tolweb.org/">Tree of Life</a> explaining the biodiversity of life</li>
<li>phylogenetic trees among species (e.g. vertebrata)</li>
<li>population genetic trees to describe human evolution</li>
<li>taxonomic trees for plant species</li>
<li>etc.</li>
</ul>
<p>Note that when visualising hierarchical structures typically the corresponding tree is depicted facing downwards, i.e. the root of the tree is shown on the top, and the tips/leaves of the tree are shown at the bottom!</p>
<p>In order to obtain such a hierarchical clustering from data two opposing strategies are commonly used:</p>
<ol style="list-style-type: decimal">
<li>
<strong>divisive or recursive partitioning algorithms</strong>
<ul>
<li>grow the tree from the root downwards</li>
<li>first determine the main two clusters, then recursively refine the clusters further.</li>
</ul>
</li>
<li>
<strong>agglomerative algorithms</strong>
<ul>
<li>grow the tree from the leaves upwards</li>
<li>successively form partitions by first joining individual object together,
then recursively join groups of items together, until all is merged.</li>
</ul>
</li>
</ol>
<p>In the following we discuss a number of popular hierarchical agglomerative clustering algorithms that are based on the pairwise distances / similarities (a <span class="math inline">\(n \times n\)</span> matrix) among all data points.</p>
</div>
<div id="agglomerative-hierarchical-clustering-algorithms" class="section level3" number="3.2.2">
<h3>
<span class="header-section-number">3.2.2</span> Agglomerative hierarchical clustering algorithms<a class="anchor" aria-label="anchor" href="#agglomerative-hierarchical-clustering-algorithms"><i class="fas fa-link"></i></a>
</h3>
<p>A general algorithm for agglomerative construction of a hierarchical clustering works as follows:</p>
<p><em>Initialisation:</em></p>
<p>Compute a dissimilarity / distance matrix between all pairs of objects where “objects” are single data points at this stage but later are also be sets of data points.</p>
<p><em>Iterative procedure:</em></p>
<ol style="list-style-type: decimal">
<li><p>identify the pair of objects with the smallest distance. These two objects are then merged together into one set. Create an internal node in the tree to represent this set.</p></li>
<li><p>update the distance matrix by computing the distances between the new set and all other
objects. If the new set contains all data points the procedure terminates. The final node created is the root node.</p></li>
</ol>
<p>For actual implementation of this algorithm two key ingredients are needed:</p>
<ol style="list-style-type: decimal">
<li>a distance measure <span class="math inline">\(d(\boldsymbol a, \boldsymbol b)\)</span> between two individual elementary data points <span class="math inline">\(\boldsymbol a\)</span> and <span class="math inline">\(\boldsymbol b\)</span>.</li>
</ol>
<blockquote>
<p>This is typically one of the following:</p>
</blockquote>
<blockquote>
<ul>
<li>Euclidean distance <span class="math inline">\(d(\boldsymbol a, \boldsymbol b) = \sqrt{\sum_{i=1}^d ( a_i-b_i )^2} = \sqrt{(\boldsymbol a-\boldsymbol b)^T (\boldsymbol a-\boldsymbol b)}\)</span>
</li>
<li>Manhattan distance <span class="math inline">\(d(\boldsymbol a, \boldsymbol b) = \sum_{i=1}^d | a_i-b_i |\)</span>
</li>
<li>Maximum norm <span class="math inline">\(d(\boldsymbol a, \boldsymbol b) = \underset{i \in \{1, \ldots, d\}}{\max} | a_i-b_i |\)</span>
</li>
</ul>
</blockquote>
<blockquote>
<p>In the end, making the correct choice of distance will require subject knowledge about the data!</p>
</blockquote>
<ol start="2" style="list-style-type: decimal">
<li>a distance measure <span class="math inline">\(d(A, B)\)</span> between two sets of objects <span class="math inline">\(A=\{\boldsymbol a_1, \boldsymbol a_2, \ldots, \boldsymbol a_{n_A} \}\)</span> and <span class="math inline">\(B=\{\boldsymbol b_1, \boldsymbol b_2, \ldots, \boldsymbol b_{n_B}\}\)</span> of size <span class="math inline">\(n_A\)</span> and <span class="math inline">\(n_B\)</span>, respectively.</li>
</ol>
<blockquote>
<p>To determine the distance <span class="math inline">\(d(A, B)\)</span> between these two sets the following measures are often employed:</p>
</blockquote>
<blockquote>
<ul>
<li>
<strong>complete linkage</strong> (max. distance): <span class="math inline">\(d(A, B) = \underset{\boldsymbol a_i \in A, \boldsymbol b_i \in B}{\max} d(\boldsymbol a_i, \boldsymbol b_i)\)</span>
</li>
<li>
<strong>single linkage</strong> (min. distance): <span class="math inline">\(d(A, B) = \underset{\boldsymbol a_i \in A, \boldsymbol b_i \in B}{\min} d(\boldsymbol a_i, \boldsymbol b_i)\)</span>
</li>
<li>
<strong>average linkage</strong> (avg. distance): <span class="math inline">\(d(A, B) = \frac{1}{n_A n_B} \sum_{\boldsymbol a_i \in A} \sum_{\boldsymbol b_i \in B} d(\boldsymbol a_i, \boldsymbol b_i)\)</span>
</li>
</ul>
</blockquote>
</div>
<div id="wards-clustering-method" class="section level3" number="3.2.3">
<h3>
<span class="header-section-number">3.2.3</span> Ward’s clustering method<a class="anchor" aria-label="anchor" href="#wards-clustering-method"><i class="fas fa-link"></i></a>
</h3>
<p>Another agglomerative hierarchical procedure is <strong>Ward’s minimum variance approach</strong>. In this approach in each iteration the two sets <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are merged that lead to the <em>smallest increase in within-group variation, or equivalenty, 5h3 total within-group sum of squares</em> (cf. <span class="math inline">\(K\)</span>-means). The centroids of the two sets is given by <span class="math inline">\(\boldsymbol \mu_A = \frac{1}{n_A} \sum_{\boldsymbol a_i \in A} \boldsymbol a_i\)</span> and <span class="math inline">\(\boldsymbol \mu_B = \frac{1}{n_B} \sum_{\boldsymbol b_i \in B} \boldsymbol b_i\)</span>.</p>
<p>The within-group sum of squares for group <span class="math inline">\(A\)</span> is
<span class="math display">\[
w_A = \sum_{\boldsymbol a_i \in A} (\boldsymbol a_i -\boldsymbol \mu_A)^T (\boldsymbol a_i -\boldsymbol \mu_A)
\]</span>
and is computed here on the basis of the difference of the observations <span class="math inline">\(\boldsymbol a_i\)</span> relative to their mean <span class="math inline">\(\boldsymbol \mu_A\)</span>.
However, it is also possible to compute it from the pairwise differences
between the observations using
<span class="math display">\[
w_A = \frac{1}{n_A} \sum_{\boldsymbol a_i, \boldsymbol a_j \in A, i &lt; j} (\boldsymbol a_i -\boldsymbol a_j)^T (\boldsymbol a_i -\boldsymbol a_j)
\]</span>
This trick is used in Ward’s clustering method by constructing a distance measure between to sets <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> as
<span class="math display">\[
d(A, B) = w_{A \cup B} - w_A -w_B \, .
\]</span>
Correspondingly, the distance between two elementary data points <span class="math inline">\(\boldsymbol a\)</span> and <span class="math inline">\(\boldsymbol b\)</span> is the squared Euclidean distance
<span class="math display">\[
d(\boldsymbol a, \boldsymbol b) = (\boldsymbol a- \boldsymbol b)^T (\boldsymbol a- \boldsymbol b) \, .
\]</span></p>
</div>
<div id="application-to-swiss-banknote-data-set" class="section level3" number="3.2.4">
<h3>
<span class="header-section-number">3.2.4</span> Application to Swiss banknote data set<a class="anchor" aria-label="anchor" href="#application-to-swiss-banknote-data-set"><i class="fas fa-link"></i></a>
</h3>
<p>This data set is reports 6 pysical measurements on 200 Swiss bank notes. Of the 200 notes
100 are genuine and 100 are counterfeit. The measurements are: length, left width, right width, bottom margin, top margin, diagonal length of the bank notes.</p>
<p>Plotting the first to PCAs of this data shows that there are indeed two well defined groups,
and that these groups correspond precisely to the genuine and counterfeit banknotes:</p>
<div class="inline-figure"><img src="3-clustering-a_files/figure-html/unnamed-chunk-2-1.png" width="672"></div>
<div style="page-break-after: always;"></div>
<p>We now compare the hierarchical clusterings of the Swiss bank note data using four different methods using Euclidean distance.</p>
<p>An interactive <a href="https://shiny.rstudio.com/">R Shiny web app</a> of this analysis (which also allows to explore further distance measures) is available
online at <a href="https://minerva.it.manchester.ac.uk/shiny/strimmer/hclust/" class="uri">https://minerva.it.manchester.ac.uk/shiny/strimmer/hclust/</a> .</p>
<p>Ward.D2 (=Ward’s method):</p>
<div class="inline-figure"><img src="3-clustering-a_files/figure-html/unnamed-chunk-3-1.png" width="672"></div>
<p>Average linkage:</p>
<div class="inline-figure"><img src="3-clustering-a_files/figure-html/unnamed-chunk-4-1.png" width="672"></div>
<div style="page-break-after: always;"></div>
<p>Complete linkage:</p>
<div class="inline-figure"><img src="3-clustering-a_files/figure-html/unnamed-chunk-5-1.png" width="672"></div>
<p>Single linkage:</p>
<div class="inline-figure"><img src="3-clustering-a_files/figure-html/unnamed-chunk-6-1.png" width="672"></div>
<p>Result:</p>
<ul>
<li>All four trees / hierarchical clusterings are quite different!</li>
<li>The Ward.D2 method is the only one that finds the correct grouping (except for a single error).</li>
</ul>
<div style="page-break-after: always;"></div>
</div>
<div id="assessment-of-the-uncertainty-of-hierarchical-clusterings" class="section level3" number="3.2.5">
<h3>
<span class="header-section-number">3.2.5</span> Assessment of the uncertainty of hierarchical clusterings<a class="anchor" aria-label="anchor" href="#assessment-of-the-uncertainty-of-hierarchical-clusterings"><i class="fas fa-link"></i></a>
</h3>
<p>In practical application of hierarchical clustering methods is is essential to evaluate the stability and uncertainty of the obtained groupings. This is often done as follows using the “bootstrap”:</p>
<ul>
<li>Sampling with replacement is used to generate a number of so-called bootstrap data sets (say <span class="math inline">\(B=200\)</span>) similar to the original one. Specifically, we create new data matrices by repeately randomly selecting columns (variables) from the original data matrix for inclusion in the bootstrap data matrix. Note that we sample columns as our aim is to cluster the samples.</li>
<li>Subsequently, a hierarchical clustering is computed for each of the bootstrap data sets. As a result, we now have an “ensemble” of <span class="math inline">\(B\)</span> bootstrap trees.</li>
<li>Finally, analysis of the clusters (bipartions) shown in all the bootstrap trees allows to count the clusters that appear frequently, and also those that appear less frequently. These counts provide a measure of the stability of the clusterings appearing in the original tree.</li>
<li>Additionally, from the bootstrap tree we can also compute a consensus tree containing the most stable clusters. This an be viewed as an “ensemble average” of all the bootstrap trees.</li>
</ul>
<p>A disadvantage of this procedure is that bootstrapping trees is computationally very expensive, as the original procedure is already time consuming but now needs to be repeated a large number of times.</p>

</div>
</div>
<div id="k-means-clustering" class="section level2" number="3.3">
<h2>
<span class="header-section-number">3.3</span> <span class="math inline">\(K\)</span>-means clustering<a class="anchor" aria-label="anchor" href="#k-means-clustering"><i class="fas fa-link"></i></a>
</h2>
<div id="set-up" class="section level3" number="3.3.1">
<h3>
<span class="header-section-number">3.3.1</span> Set-up<a class="anchor" aria-label="anchor" href="#set-up"><i class="fas fa-link"></i></a>
</h3>
<ul>
<li>We assume that there are <span class="math inline">\(K\)</span> groups (i.e. <span class="math inline">\(K\)</span> is known in advance).</li>
<li>For each group <span class="math inline">\(k \in \{1, \ldots, K\}\)</span> we assume a group mean <span class="math inline">\(\boldsymbol \mu_k\)</span>.</li>
<li>Aim: partition the data points <span class="math inline">\(\boldsymbol x_1, \ldots, \boldsymbol x_n\)</span> into <span class="math inline">\(K\)</span> non-overlapping groups.</li>
<li>Each of the <span class="math inline">\(n\)</span> data points <span class="math inline">\(\boldsymbol x_i\)</span> is assigned to exactly one of the <span class="math inline">\(K\)</span> groups.</li>
<li>Maximise the homogeneity within each group (i.e. each group should contain similar objects).</li>
<li>Maximise the heterogeneity between the different groups (i.e each group should differ from the other groups).</li>
</ul>
</div>
<div id="algorithm" class="section level3" number="3.3.2">
<h3>
<span class="header-section-number">3.3.2</span> Algorithm<a class="anchor" aria-label="anchor" href="#algorithm"><i class="fas fa-link"></i></a>
</h3>
<p>After running <span class="math inline">\(K\)</span>-means we will get estimates of <span class="math inline">\(\hat{\boldsymbol \mu}_k\)</span> of the group means,
as well allocations <span class="math inline">\(y_i \in \{1, \ldots, K\}\)</span> of each data point <span class="math inline">\(\boldsymbol x_i\)</span> to one of the classes.</p>
<p><em>Initialisation:</em></p>
<p>At the start of the algorithm the <span class="math inline">\(n\)</span> observations <span class="math inline">\(\boldsymbol x_1, \ldots, \boldsymbol x_n\)</span> are randomly allocated with equal probability to one of the <span class="math inline">\(K\)</span> groups. The resulting assignment is <span class="math inline">\(y_1, \ldots, y_n\)</span>, with each <span class="math inline">\(y_i=\{1, \ldots, K\}\)</span>.
With <span class="math inline">\(G_k = \{ i | y_i = k\}\)</span> we denote the set of indices of the data points in cluster <span class="math inline">\(k\)</span>, and with <span class="math inline">\(n_k = | G_k |\)</span> the
number of samples in cluster <span class="math inline">\(k\)</span>.</p>
<p><em>Iterative refinement:</em></p>
<ol style="list-style-type: decimal">
<li>Estimate the group means by
<span class="math display">\[
\hat{\boldsymbol \mu}_k = \frac{1}{n_k} \sum_{i \in G_k} \boldsymbol x_i
\]</span>
</li>
<li>Update the group allocations <span class="math inline">\(y_i\)</span>. Specifically, assign each data point <span class="math inline">\(\boldsymbol x_i\)</span> to the group <span class="math inline">\(k\)</span> with the nearest <span class="math inline">\(\hat{\boldsymbol \mu}_k\)</span>. The distance is measured in terms of the Euclidean norm:
<span class="math display">\[
\begin{split}
y_i &amp; = \underset{k}{\arg \min} \,  \left| \boldsymbol x_i-\hat{\boldsymbol \mu}_k \right|_2 \\
      &amp; = \underset{k}{\arg \min} \, (\boldsymbol x_i-\hat{\boldsymbol \mu}_k)^T (\boldsymbol x_i-\hat{\boldsymbol \mu}_k) \\
\end{split}
\]</span>
</li>
</ol>
<p>Steps 1 and 2 are repeated until the algorithm converges (i.e. until the group allocations don’t change any more) or until a specified upper limit of iterations is reached.</p>
</div>
<div id="properties" class="section level3" number="3.3.3">
<h3>
<span class="header-section-number">3.3.3</span> Properties<a class="anchor" aria-label="anchor" href="#properties"><i class="fas fa-link"></i></a>
</h3>
<p>Despite its simplicity <span class="math inline">\(K\)</span>-means is, perhaps surprisingly, a very effective clustering algorithm.<br>
The main reason for this is the close connection of <span class="math inline">\(K\)</span>-means with probabilistic clustering based on Gaussian mixture models (for details see later section).</p>
<p>Since the clustering depends on the initialisation it is often useful to run <span class="math inline">\(K\)</span>-means several
times with different starting group allocations of the data points. Furthermore, non-random or non-uniform
initialisations can lead to improved and faster convergence, see e.g. 
the <a href="https://en.wikipedia.org/wiki/K-means%2B%2B">K-means++</a> algorithm.</p>
<p>The clusters constructed in <span class="math inline">\(K\)</span>-means have linear boundaries and thus form a
<a href="https://en.wikipedia.org/wiki/Voronoi_diagram">Voronoi tessellation</a> around the cluster means.
Again, this can be explained by the link of <span class="math inline">\(K\)</span>-means with a particular Gaussian mixture model.</p>
</div>
<div id="choosing-the-number-of-clusters" class="section level3" number="3.3.4">
<h3>
<span class="header-section-number">3.3.4</span> Choosing the number of clusters<a class="anchor" aria-label="anchor" href="#choosing-the-number-of-clusters"><i class="fas fa-link"></i></a>
</h3>
<p>Once the <span class="math inline">\(K\)</span>-means algorithm has run we can assess the homogeneity and
heterogeneity of the resulting clusters:</p>
<ol style="list-style-type: lower-alpha">
<li><p>the total within-group sum of squares <span class="math inline">\(SSW\)</span> (in R: <code>tot.withinss</code>), or total unexplained sum of squares:
<span class="math display">\[
SSW = \sum_{k=1}^K \, \sum_{i \in G_k} (\boldsymbol x_i -\hat{\boldsymbol \mu}_k)^T (\boldsymbol x_i -\hat{\boldsymbol \mu}_k)
\]</span>
This quantity decreases with <span class="math inline">\(K\)</span> and is zero for <span class="math inline">\(K=n\)</span>.
The <span class="math inline">\(K\)</span>-means algorithm tries to minimise this quantity but it will typically only find a local minimum rather than the global one.</p></li>
<li><p>the between-group sum of squares <span class="math inline">\(SSB\)</span> (in R: <code>betweenss</code>), or explained sum of squares:
<span class="math display">\[
SSB = \sum_{k=1}^K n_k (\hat{\boldsymbol \mu}_k - \hat{\boldsymbol \mu}_0)^T (\hat{\boldsymbol \mu}_k - \hat{\boldsymbol \mu}_0)
\]</span>
where <span class="math inline">\(\hat{\boldsymbol \mu}_0 = \frac{1}{n} \sum_{i=1}^n \boldsymbol x_i = \frac{1}{n} \sum_{k=1}^K n_k \hat{\boldsymbol \mu}_k\)</span>
is the global mean of the samples. <span class="math inline">\(SSB\)</span> increases with the number of clusters <span class="math inline">\(K\)</span> until for <span class="math inline">\(K=n\)</span> it
becomes equal to the total sum of squares <span class="math inline">\(SST\)</span>.</p></li>
<li><p>the total sum of squares
<span class="math display">\[
SST = \sum_{i=1}^n (\boldsymbol x_i - \hat{\boldsymbol \mu}_0)^T (\boldsymbol x_i - \hat{\boldsymbol \mu}_0) \, .
\]</span>
By construction <span class="math inline">\(SST = SSB + SSW\)</span> for any <span class="math inline">\(K\)</span> (i.e. <span class="math inline">\(SST\)</span> is a constant independent of <span class="math inline">\(K\)</span>).</p></li>
</ol>
<p>Dividing the sum of squares by the sample size <span class="math inline">\(n\)</span> we get</p>
<ul>
<li>
<span class="math inline">\(T = \frac{SST}{n}\)</span> as the <em>total variation</em>,</li>
<li>
<span class="math inline">\(B = \frac{SSW}{n}\)</span> as the <em>explained variation</em> and</li>
<li>
<span class="math inline">\(W = \frac{SSW}{n}\)</span> as the total <em>unexplained variation</em> ,</li>
<li>with <span class="math inline">\(T = B + W\)</span>.</li>
</ul>
<p>In order to decide on the optimal number of clusters we run <span class="math inline">\(K\)</span>-means for different settings for <span class="math inline">\(K\)</span> and then choose the smallest <span class="math inline">\(K\)</span> for which the explained variation <span class="math inline">\(B\)</span> is not significantly worse compared to a clustering with a substantially larger <span class="math inline">\(K\)</span> (see example below).</p>
</div>
<div id="k-medoids-aka-pam" class="section level3" number="3.3.5">
<h3>
<span class="header-section-number">3.3.5</span> <span class="math inline">\(K\)</span>-medoids aka PAM<a class="anchor" aria-label="anchor" href="#k-medoids-aka-pam"><i class="fas fa-link"></i></a>
</h3>
<p>A closely related clustering method is <span class="math inline">\(K\)</span>-medoids or PAM (“Partitioning Around Medoids”).</p>
<p>This works exactly like <span class="math inline">\(K\)</span>-means, only that</p>
<ul>
<li>instead of the estimated group means <span class="math inline">\(\hat{\boldsymbol \mu}_k\)</span> one member of each group is selected as its representative (the so-called “medoid”)</li>
<li>instead of squared Euclidean distance other dissimilarity measures are also allowed.</li>
</ul>
</div>
<div id="application-of-k-means-to-iris-data" class="section level3" number="3.3.6">
<h3>
<span class="header-section-number">3.3.6</span> Application of <span class="math inline">\(K\)</span>-means to Iris data<a class="anchor" aria-label="anchor" href="#application-of-k-means-to-iris-data"><i class="fas fa-link"></i></a>
</h3>
<p>Scatter plots of Iris data:</p>
<div class="inline-figure"><img src="3-clustering-b_files/figure-html/unnamed-chunk-1-1.png" width="480"></div>
<p>The R output from a <span class="math inline">\(K\)</span>-means analysis with true number of clusters specified (<span class="math inline">\(K=3\)</span>) is:</p>
<pre><code>## K-means clustering with 3 clusters of sizes 50, 47, 53
## 
## Cluster means:
##   Sepal.Length Sepal.Width Petal.Length Petal.Width
## 1  -1.01119138  0.85041372   -1.3006301  -1.2507035
## 2   1.13217737  0.08812645    0.9928284   1.0141287
## 3  -0.05005221 -0.88042696    0.3465767   0.2805873
## 
## Clustering vector:
##   [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
##  [38] 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 3 3 3 2 3 3 3 3 3 3 3 3 2 3 3 3 3 2 3 3 3
##  [75] 3 2 2 2 3 3 3 3 3 3 3 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 2 3 2 2 2 2 3 2 2 2 2
## [112] 2 2 3 3 2 2 2 2 3 2 3 2 3 2 2 3 2 2 2 2 2 2 3 3 2 2 2 3 2 2 2 3 2 2 2 3 2
## [149] 2 3
## 
## Within cluster sum of squares by cluster:
## [1] 47.35062 47.45019 44.08754
##  (between_SS / total_SS =  76.7 %)
## 
## Available components:
## 
## [1] "cluster"      "centers"      "totss"        "withinss"     "tot.withinss"
## [6] "betweenss"    "size"         "iter"         "ifault"</code></pre>
<p>The corresponding total within-group sum of squares (<span class="math inline">\(SSW\)</span>, <code>tot.withinss</code>)
is</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">kmeans.out</span><span class="op">$</span><span class="va">tot.withinss</span></code></pre></div>
<pre><code>## [1] 138.8884</code></pre>
<p>and the between-group sum of squares (<span class="math inline">\(SSB\)</span>, <code>betweenss</code>) is</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">kmeans.out</span><span class="op">$</span><span class="va">betweenss</span></code></pre></div>
<pre><code>## [1] 457.1116</code></pre>
<p>By comparing with the known class assignments we can assess the accuracy of <span class="math inline">\(K\)</span>-means clustering:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/table.html">table</a></span><span class="op">(</span><span class="va">L.iris</span>, <span class="va">kmeans.out</span><span class="op">$</span><span class="va">cluster</span><span class="op">)</span></code></pre></div>
<pre><code>##             
## L.iris        1  2  3
##   setosa     50  0  0
##   versicolor  0 11 39
##   virginica   0 36 14</code></pre>
<p>For choosing <span class="math inline">\(K\)</span> we run <span class="math inline">\(K\)</span>-means several times and compute
within and between cluster variation in dependence of <span class="math inline">\(K\)</span>:</p>
<div class="inline-figure"><img src="3-clustering-b_files/figure-html/unnamed-chunk-6-1.png" width="480"></div>
<p>Thus, <span class="math inline">\(K=3\)</span> clusters seem appropriate since the the explained variation does not significantly improve
(and the unexplained variation does not significantly decrease) with a further increase of the number of clusters.</p>
</div>
<div id="arbitrariness-of-cluster-labels-and-label-switching" class="section level3" number="3.3.7">
<h3>
<span class="header-section-number">3.3.7</span> Arbitrariness of cluster labels and label switching<a class="anchor" aria-label="anchor" href="#arbitrariness-of-cluster-labels-and-label-switching"><i class="fas fa-link"></i></a>
</h3>
<p>It is important to realise that in unsupervised learning and clustering the labels of each group are assigned in an arbitrary fashion.
Recall that for <span class="math inline">\(K\)</span> groups there are <span class="math inline">\(K!\)</span> possibilities to attach the
labels, corresponding to the number of permutations of <span class="math inline">\(K\)</span> groups.</p>
<p>Thus, different runs of a clustering algorithm such as <span class="math inline">\(K\)</span>-means may return the same clustering (groupings of samples) but with different labels. This phenomenon is called “label switching”
and makes it difficult to automatise comparison of clusterings.</p>
<p>In particular when comparing clusterings one cannot simply rely on the automaticaly assigned group label to identify a clustering, instead one needs to compare the actual members of the clusters.</p>
<p>A way to resolve the problem of label switching is to relabel the clusters using additional information, such as requiring that some samples are in specific groups
(e.g.: sample 1 is always in group labelled “1”), and/or linking labels to orderings or constraints on the group characteristics (e.g.: the group with label “1” has always a smaller mean that group with label “2”).</p>

</div>
</div>
<div id="mixture-models" class="section level2" number="3.4">
<h2>
<span class="header-section-number">3.4</span> Mixture models<a class="anchor" aria-label="anchor" href="#mixture-models"><i class="fas fa-link"></i></a>
</h2>
<div id="finite-mixture-model" class="section level3" number="3.4.1">
<h3>
<span class="header-section-number">3.4.1</span> Finite mixture model<a class="anchor" aria-label="anchor" href="#finite-mixture-model"><i class="fas fa-link"></i></a>
</h3>
<ul>
<li>
<span class="math inline">\(K\)</span> groups / classes / categories, with finite <span class="math inline">\(K\)</span> known in advance.</li>
<li>Probability of class <span class="math inline">\(k\)</span>: <span class="math inline">\(\text{Pr}(k) = \pi_k\)</span> with <span class="math inline">\(\sum_{k=1}^K \pi_k = 1\)</span>.</li>
<li>Each class <span class="math inline">\(k \in C= \{1, \ldots, K\}\)</span> is modelled by its own distribution <span class="math inline">\(F_k\)</span> with own parameters <span class="math inline">\(\boldsymbol \theta_k\)</span>.</li>
<li>Density of class <span class="math inline">\(k\)</span>: <span class="math inline">\(f_k(\boldsymbol x) = f(\boldsymbol x| k)\)</span>.</li>
<li>The conditional means and variances for each class <span class="math inline">\(k \in C\)</span> are <span class="math inline">\(\text{E}(\boldsymbol x| k) = \boldsymbol \mu_k\)</span> and <span class="math inline">\(\text{Var}(\boldsymbol x| k) = \boldsymbol \Sigma_k\)</span>.</li>
<li>The resulting mixture density for the observed variable <span class="math inline">\(\boldsymbol x\)</span> is
<span class="math display">\[
f_{\text{mix}}(\boldsymbol x) = \sum_{k=1}^K \pi_k f_k(\boldsymbol x)
\]</span>
</li>
</ul>
<p>Very often one uses <strong>multivariate normal components</strong> <span class="math inline">\(f_k(\boldsymbol x) = N(\boldsymbol x| \boldsymbol \mu_k, \boldsymbol \Sigma_k)\)</span> <span class="math inline">\(\\ \Longrightarrow\)</span> <strong>Gaussian mixture model</strong> (GMM)</p>
<p>Mixture models are fundamental not just in clustering but for many other applications (e.g. classification).</p>
<p>Note: don’t confuse <em>mixture model</em> with <em>mixed model</em> (= terminology for a <em>random effects</em> regression model).</p>
</div>
<div id="total-mean-and-variance-of-mixture-model" class="section level3" number="3.4.2">
<h3>
<span class="header-section-number">3.4.2</span> Total mean and variance of mixture model<a class="anchor" aria-label="anchor" href="#total-mean-and-variance-of-mixture-model"><i class="fas fa-link"></i></a>
</h3>
<p>Using the law of total expectation we obtain the mean of the mixture density as follows:
<span class="math display">\[
\begin{split}
\text{E}(\boldsymbol x) &amp; = \text{E}(\text{E}(\boldsymbol x| k)) \\
            &amp; = \sum_{k=1}^K \pi_k \boldsymbol \mu_k \\
            &amp;= \boldsymbol \mu_0 \\
\end{split}
\]</span></p>
<p>Similarly, using the law of total variance we compute the marginal variance:
<span class="math display">\[
\begin{split}
\underbrace{\text{Var}(\boldsymbol x)}_{\text{total}} &amp; =  \underbrace{ \text{Var}( \text{E}(\boldsymbol x| k )  )}_{\text{explained / between-group}} + \underbrace{\text{E}(\text{Var}(\boldsymbol x|k))}_{\text{unexplained / within-group}} \\
\boldsymbol \Sigma_0 &amp; =  \sum_{k=1}^K \pi_k (\boldsymbol \mu_k - \boldsymbol \mu_0) (\boldsymbol \mu_k - \boldsymbol \mu_0)^T + \sum_{k=1}^K \pi_k \boldsymbol \Sigma_k  \\
\end{split}
\]</span></p>
<p>Thus, the <strong>total variance</strong> decomposes into the <strong>explained
(between group) variance</strong> and the <strong>unexplained (within group) variance</strong>. This is the same
decomposition as in linear regression (see <a href="https://strimmerlab.github.io/publications/lecture-notes/MATH20802/">MATH20802 Statistical Methods</a>).</p>
</div>
<div id="total-variation" class="section level3" number="3.4.3">
<h3>
<span class="header-section-number">3.4.3</span> Total variation<a class="anchor" aria-label="anchor" href="#total-variation"><i class="fas fa-link"></i></a>
</h3>
<p>The <strong>total variation</strong> is given by the <strong>trace of the covariance matrix</strong>. The above decomposition for the total variation is
<span class="math display">\[
\begin{split}
\text{Tr}(\boldsymbol \Sigma_0) &amp; =  \sum_{k=1}^K \pi_k \text{Tr}((\boldsymbol \mu_k - \boldsymbol \mu_0) (\boldsymbol \mu_k - \boldsymbol \mu_0)^T) + \sum_{k=1}^K \pi_k \text{Tr}(\boldsymbol \Sigma_k)  \\
&amp; =  \sum_{k=1}^K \pi_k (\boldsymbol \mu_k - \boldsymbol \mu_0)^T (\boldsymbol \mu_k - \boldsymbol \mu_0) + \sum_{k=1}^K \pi_k \text{Tr}(\boldsymbol \Sigma_k)\\
\end{split}
\]</span>
If the covariances are replaced by their empirical estimates we obtain
the <span class="math inline">\(T=B+W\)</span> decomposition of total variation familiar from <span class="math inline">\(K\)</span>-means:
<span class="math display">\[T = \text{Tr}\left( \hat{\boldsymbol \Sigma}_0 \right)  = 
\frac{1}{n} \sum_{i=1}^n (\boldsymbol x_i - \hat{\boldsymbol \mu}_0)^T (\boldsymbol x_i - \hat{\boldsymbol \mu}_0)\]</span>
<span class="math display">\[B = \frac{1}{n} \sum_{k=1}^K n_k (\hat{\boldsymbol \mu}_k - \hat{\boldsymbol \mu}_0)^T (\hat{\boldsymbol \mu}_k - \hat{\boldsymbol \mu}_0)\]</span>
<span class="math display">\[W = \frac{1}{n}  \sum_{k=1}^K \, \sum_{i \in G_k} (\boldsymbol x_i -\hat{\boldsymbol \mu}_k)^T (\boldsymbol x_i -\hat{\boldsymbol \mu}_k)
\]</span></p>
</div>
<div id="univariate-mixture" class="section level3" number="3.4.4">
<h3>
<span class="header-section-number">3.4.4</span> Univariate mixture<a class="anchor" aria-label="anchor" href="#univariate-mixture"><i class="fas fa-link"></i></a>
</h3>
<p>For a univariate mixture (<span class="math inline">\(d=1\)</span>) with <span class="math inline">\(K=2\)</span> components we get
<span class="math display">\[
\mu_0 = \pi_1 \mu_1+ \pi_2 \mu_2 \, ,
\]</span>
<span class="math display">\[
\sigma^2_{\text{within}} = \pi_1 \sigma^2_1 + \pi_2 \sigma^2_2 = \sigma^2_{\text{pooled}}\,,
\]</span>
also know as pooled variance, and
<span class="math display">\[
\begin{split}
\sigma^2_{\text{between}} &amp;= \pi_1 (\mu_1 - \mu_0)^2 + \pi_2 (\mu_2 - \mu_0)^2 \\
&amp; =\pi_1 \pi_2^2 (\mu_1 - \mu_2)^2 + \pi_2 \pi_1^2 (\mu_1 - \mu_2)^2\\
&amp; = \pi_1 \pi_2 (\mu_1 - \mu_2)^2  \\
&amp; = \left( \frac{1}{\pi_1} + \frac{1}{\pi_2}   \right)^{-1} (\mu_1 - \mu_2)^2 \\
\end{split} \,.
\]</span>
The ratio of the between-group variance and the within-group variance is proportional
(by factor of <span class="math inline">\(n\)</span>) to the squared pooled-variance <span class="math inline">\(t\)</span>-score:
<span class="math display">\[
\frac{\sigma^2_{\text{between}}}{\sigma^2_{\text{within}}} =
  \frac{ (\mu_1 - \mu_2)^2}{ \left(\frac{1}{\pi_1} + \frac{1}{\pi_2}   \right)  \sigma^2_{\text{pooled}} }= \frac{t_{\text{pooled}}^2}{n}
\]</span>
If you are familiar with ANOVA (e.g. linear models course) you will recognise this ratio as the <span class="math inline">\(F\)</span>-score.</p>
</div>
<div id="example-of-mixtures" class="section level3" number="3.4.5">
<h3>
<span class="header-section-number">3.4.5</span> Example of mixtures<a class="anchor" aria-label="anchor" href="#example-of-mixtures"><i class="fas fa-link"></i></a>
</h3>
<p>Mixtures can take on many different shapes and forms, so it is instructive to study a few examples.</p>
<div class="inline-figure"><img src="3-clustering-c_files/figure-html/unnamed-chunk-2-1.png" width="672"></div>
<p>In first plot we show the density of a mixture distribution consisting of two normals with <span class="math inline">\(\pi_1=0.7\)</span>,
<span class="math inline">\(\mu_1=-1\)</span>, <span class="math inline">\(\mu_2=2\)</span> and the two variances equal to 1 (<span class="math inline">\(\sigma^2_1 = 1\)</span> and <span class="math inline">\(\sigma^2_2 = 1\)</span>).
Because the two components are well-separated there are two clear modes. The plot also shows the density of a normal distribution with the same total mean (<span class="math inline">\(\mu_0=-0.1\)</span>) and variance (<span class="math inline">\(\sigma_0^2=2.89\)</span>) as the mixture distribution. Clearly the total normal and the mixture density are very different.</p>
<div class="inline-figure"><img src="3-clustering-c_files/figure-html/unnamed-chunk-3-1.png" width="672"></div>
<p>However, mixtures can also look very different. For example, if the mean of the second component is adjusted to <span class="math inline">\(\mu_2=0\)</span> then there is only a single mode and the total normal density with <span class="math inline">\(\mu_0=-0.7\)</span> and <span class="math inline">\(\sigma_0^2=1.21\)</span> is now almost inistinguishable in form from the mixture density.
Thus, in this case it will be very hard (or even impossible) to identify the two peaks from data.</p>
<p>An interactive version of the above two normal component mixture is available online as
<a href="https://shiny.rstudio.com/">R Shiny web app</a> at <a href="https://minerva.it.manchester.ac.uk/shiny/strimmer/mixture/" class="uri">https://minerva.it.manchester.ac.uk/shiny/strimmer/mixture/</a> .</p>
<p>Mixture models need not to be univariate, in fact most mixtures we consider in this course are multivariate.
For illustration, here is a plot of a mixture of two bivariate normals,
with <span class="math inline">\(\pi_1=0.7\)</span>, <span class="math inline">\(\boldsymbol \mu_1 = \begin{pmatrix}-1 \\1 \\ \end{pmatrix}\)</span>,
<span class="math inline">\(\boldsymbol \Sigma_1 = \begin{pmatrix} 1 &amp; 0.7 \\ 0.7 &amp; 1 \\ \end{pmatrix}\)</span>,
<span class="math inline">\(\boldsymbol \mu_2 = \begin{pmatrix}2.5 \\0.5 \\ \end{pmatrix}\)</span> and <span class="math inline">\(\boldsymbol \Sigma_2 = \begin{pmatrix} 1 &amp; -0.7 \\ -0.7 &amp; 1 \\ \end{pmatrix}\)</span>:</p>
<div class="inline-figure"><img src="3-clustering-c_files/figure-html/fig2-1.png" width="672"></div>
</div>
<div id="sampling-from-a-mixture-model" class="section level3" number="3.4.6">
<h3>
<span class="header-section-number">3.4.6</span> Sampling from a mixture model<a class="anchor" aria-label="anchor" href="#sampling-from-a-mixture-model"><i class="fas fa-link"></i></a>
</h3>
<p>Assuming we know how to sample from the component densities <span class="math inline">\(f_k(\boldsymbol x)\)</span> of the mixture model it is straightforward to set up a procedure for sampling from the mixture <span class="math inline">\(f_{\text{mix}}(\boldsymbol x) = \sum_{k=1}^K \pi_k f_k(\boldsymbol x)\)</span> itself.</p>
<p>This is done in a two-step process:</p>
<ol style="list-style-type: decimal">
<li><p>Draw from categorical distribution with parameter <span class="math inline">\(\boldsymbol \pi=(\pi_1, \ldots, \pi_K)^T\)</span>:
<span class="math display">\[\boldsymbol z\sim \text{Cat}(\boldsymbol \pi)\]</span>
Here the vector <span class="math inline">\(\boldsymbol z= (z_1, \ldots, z_K)^T\)</span> indicates a hard group 0/1 allocation, with all components <span class="math inline">\(z_{\neq k}=0\)</span> except for a single entry <span class="math inline">\(z_k=1\)</span>.</p></li>
<li><p>Subsequently, sample from the component <span class="math inline">\(k\)</span> selected in step 1:
<span class="math display">\[
\boldsymbol x\sim F_k
\]</span></p></li>
</ol>
<p>This two-stage sampling approach is also known as hierarchical generative model for a mixture distribution. This generative view is not only useful for simulating data from a mixture model but also highlights the role of the latent variable (the class allocation).</p>
</div>
</div>
<div id="fitting-mixture-models-to-data-and-inferring-the-latent-states" class="section level2" number="3.5">
<h2>
<span class="header-section-number">3.5</span> Fitting mixture models to data and inferring the latent states<a class="anchor" aria-label="anchor" href="#fitting-mixture-models-to-data-and-inferring-the-latent-states"><i class="fas fa-link"></i></a>
</h2>
<p>In the following we denote by</p>
<ul>
<li>
<span class="math inline">\(\boldsymbol X= (\boldsymbol x_1, \ldots, \boldsymbol x_n)^T\)</span> the data matrix containing the observations of <span class="math inline">\(n\)</span> independent and identically distributed samples
<span class="math inline">\(\boldsymbol x_1, \ldots, \boldsymbol x_n\)</span>, and</li>
<li>
<span class="math inline">\(\boldsymbol y= (y_1, \ldots, y_n)^T\)</span> the associated group memberships, as well as</li>
<li>the parameters <span class="math inline">\(\boldsymbol \theta\)</span> which for a Gaussian mixture model are <span class="math inline">\(\boldsymbol \theta= \{\boldsymbol \pi, \boldsymbol \mu_1, \ldots, \boldsymbol \mu_K, \boldsymbol \Sigma_1, \ldots, \boldsymbol \Sigma_K\}\)</span>.</li>
</ul>
<div id="observed-and-latent-variables" class="section level3" number="3.5.1">
<h3>
<span class="header-section-number">3.5.1</span> Observed and latent variables<a class="anchor" aria-label="anchor" href="#observed-and-latent-variables"><i class="fas fa-link"></i></a>
</h3>
<p>When we observe data from a mixture model we collect samples <span class="math inline">\(\boldsymbol x_1, \ldots, \boldsymbol x_n\)</span>.
Associated with each observed <span class="math inline">\(\boldsymbol x_i\)</span> is the corresponding underlying class allocation <span class="math inline">\(y_1, \ldots, y_n\)</span> where
each <span class="math inline">\(y_i\)</span> takes on a value from <span class="math inline">\(C = \{1, \ldots, K\}\)</span>. Crucially, the class allocations <span class="math inline">\(y_i\)</span> are unknown and
cannot be directly observed, thus are latent.</p>
<ul>
<li>The <strong>joint density</strong> for observed and unobserved variables:
<span class="math display">\[f(\boldsymbol x, y) = f(\boldsymbol x| y) \text{Pr}(y) = f_k(\boldsymbol y) \pi_y\]</span>
</li>
</ul>
<p>The mixture density is therefore a <strong>marginal density</strong> as it arises from the joint density <span class="math inline">\(f(\boldsymbol x, y)\)</span>
by marginalising over the discrete variable <span class="math inline">\(y\)</span>.</p>
<ul>
<li>Marginalisation: <span class="math inline">\(f(\boldsymbol x) = \sum_{y \in C} f(\boldsymbol x, y)\)</span>
</li>
</ul>
</div>
<div id="complete-data-likelihood-and-observed-data-likelihood" class="section level3" number="3.5.2">
<h3>
<span class="header-section-number">3.5.2</span> Complete data likelihood and observed data likelihood<a class="anchor" aria-label="anchor" href="#complete-data-likelihood-and-observed-data-likelihood"><i class="fas fa-link"></i></a>
</h3>
<p>If we know <span class="math inline">\(\boldsymbol y\)</span> in advance, i.e. if we know which sample belongs to a particular group,
we can construct a <em>complete data log-likelihood</em>
based on the joint distribution <span class="math inline">\(f(\boldsymbol x, y) = \pi_y f_y(\boldsymbol x)\)</span>.
The log-likelihood for <span class="math inline">\(\boldsymbol \theta\)</span> given the both <span class="math inline">\(\boldsymbol X\)</span> and <span class="math inline">\(\boldsymbol y\)</span> is
<span class="math display">\[
\log L(\boldsymbol \theta| \boldsymbol X, \boldsymbol y) = \sum_{i=1}^n \log f(\boldsymbol x_i, y_i)  =  \sum_{i=1}^n  \log \left(\pi_{y_i} f_{y_i}(\boldsymbol x_i) \right) 
\]</span></p>
<p>On the other hand, typically we do not know <span class="math inline">\(\boldsymbol y\)</span> and therefore use
the marginal or mixture density <span class="math inline">\(f(\boldsymbol x)\)</span> to construct the <em>observed data log-likelihood</em>
(sometimes also called <em>incomplete data log-likelihood</em>) <span class="math inline">\(f(\boldsymbol x| \boldsymbol \theta)\)</span> as
<span class="math display">\[
\begin{split}
\log L(\boldsymbol \theta| \boldsymbol X) &amp; =\sum_{i=1}^n \log f(\boldsymbol x_i | \boldsymbol \theta)\\
&amp; = \sum_{i=1}^n \log \left( \sum_{k=1}^K \pi_k f_k(\boldsymbol x_i)  \right)\\
\end{split}
\]</span></p>
<p>The <em>observed data log-likelihood</em> can also be computed from the complete data likelihood
function by marginalising over <span class="math inline">\(\boldsymbol y\)</span>
<span class="math display">\[
\begin{split}
\log L(\boldsymbol \theta| \boldsymbol X) &amp;= \log \sum_{\boldsymbol y}   L(\boldsymbol \theta| \boldsymbol X, \boldsymbol y)\\
 &amp;= \log \sum_{y_1, \ldots, y_K}  \prod_{i=1}^n f(\boldsymbol x_i, y_i)\\
&amp;= \log \prod_{i=1}^n  \sum_{k=1}^K f(\boldsymbol x_i, k)\\
&amp; = \sum_{i=1}^n \log \left(  \sum_{k=1}^K f(\boldsymbol x_i, k)     \right)
\end{split} 
\]</span></p>
<p>Clustering with a mixture model can be viewed as an <em>incomplete</em> or <em>missing</em> data problem
(see also part II of <a href="https://strimmerlab.github.io/publications/lecture-notes/MATH20802/">MATH20802 Statistical Methods</a> ).</p>
<p>Specifically, we face the problem of</p>
<ul>
<li>fitting the model using only the observed data <span class="math inline">\(\boldsymbol X\)</span> and</li>
<li>simultaneously inferring the class allocations <span class="math inline">\(\boldsymbol y\)</span>, i.e. states of the latent variable.</li>
</ul>
</div>
<div id="fitting-the-mixture-model-to-the-observed-data" class="section level3" number="3.5.3">
<h3>
<span class="header-section-number">3.5.3</span> Fitting the mixture model to the observed data<a class="anchor" aria-label="anchor" href="#fitting-the-mixture-model-to-the-observed-data"><i class="fas fa-link"></i></a>
</h3>
<p>For large sample size <span class="math inline">\(n\)</span> the standard way to fit a mixture model
is to employ maximum likelihood to find the MLEs of the parameters of the mixture model.</p>
<p>The direct way to fit a mixture model by maximum likelihood is to <strong>maximise the observed data log-likelihood function</strong> with regard to <span class="math inline">\(\boldsymbol \theta\)</span>:
<span class="math display">\[
\hat{\boldsymbol \theta}^{ML} = \underset{\boldsymbol \theta}{\arg \max}\,\, \log L(\boldsymbol \theta| \boldsymbol X)
\]</span></p>
<p>Unfortunately, in practise evaluation and optimisation of the log-likelihood function can be difficult due to a number of reasons:</p>
<ul>
<li>The form of the observed data log-likelihood function prevents analytic simplifications
(note the sum inside the logarithm) and thus can be difficult to compute.</li>
<li>Because of the symmetries due to exchangeability of cluster labels the likelihood function is multimodal and thus hard to optimise. Note this is also linked to the general
problem of label switching and non-identifiability of cluster labels — see the discussion for <span class="math inline">\(K\)</span>-means clustering.</li>
<li>Further identifiability issues can arise if (for instance) two neighboring components of the mixture model are largely overlapping and thus are too close to each other to be discriminated as two different modes. In other words, it is difficult to determine the number of classes.</li>
<li>Furthermore, the likelihood in Gaussian mixture models is singular if one of the fitted covariance matrices becomes singular. However, this can be easily adressed by using some form of regularisation (Bayes, penalised ML, etc.) or simply by requiring sufficient sample size per group.</li>
</ul>
</div>
<div id="predicting-the-group-allocation-of-a-given-sample" class="section level3" number="3.5.4">
<h3>
<span class="header-section-number">3.5.4</span> Predicting the group allocation of a given sample<a class="anchor" aria-label="anchor" href="#predicting-the-group-allocation-of-a-given-sample"><i class="fas fa-link"></i></a>
</h3>
<p>In probabilistic clustering the aim is to infer the latent states <span class="math inline">\(y_1, \ldots, y_n\)</span> for all observed samples <span class="math inline">\(\boldsymbol x_1, \ldots, \boldsymbol x_n\)</span>.</p>
<p>Assuming that the mixture model is known (either in advance or after fitting it) Bayes’ theorem allows predict the probability that an observation <span class="math inline">\(\boldsymbol x_i\)</span> falls in group <span class="math inline">\(k \in \{1, \ldots, K\}\)</span>:
<span class="math display">\[
q_i(k) = \text{Pr}(k | \boldsymbol x_i) = \frac{\pi_k f_k(\boldsymbol x_i ) }{ f(\boldsymbol x_i)}
\]</span>
Thus, for each of the <span class="math inline">\(n\)</span> samples we get a probability mass function over the
<span class="math inline">\(K\)</span> classes with <span class="math inline">\(\sum_{k=1}^K q_i(k)=1\)</span>.</p>
<p>The posterior probabilities in <span class="math inline">\(q_i(k)\)</span> provide a so-called <em>soft assignment</em> of the sample <span class="math inline">\(\boldsymbol x_i\)</span> to all classes rather than a 0/1 <em>hard assignment</em> to a specific class (as for example in the <span class="math inline">\(K\)</span>-means algorithm).</p>
<p>To obtain at a hard clustering and to infer the most probable latent state we select the class with the highest probability
<span class="math display">\[
y_i =\underset{k}{\arg \max}\,\,q_i(k)
\]</span></p>
<p>Thus, in probabilistic clustering we directly obtain an assessment of the uncertainty of the class assignment for a sample <span class="math inline">\(\boldsymbol x_i\)</span> (which is not the case in simple algorithmic clustering such <span class="math inline">\(K\)</span>-means). We can use this information to check whether there are several classes with equal or similar probability. This will be the case, e.g., if <span class="math inline">\(\boldsymbol x_i\)</span> lies near the boundary between two neighbouring classes.</p>
<p>Using the interactive Shiny app for the univariate normal component mixture (online at <a href="https://minerva.it.manchester.ac.uk/shiny/strimmer/mixture/" class="uri">https://minerva.it.manchester.ac.uk/shiny/strimmer/mixture/</a> ) you can explore the posterior probabilities of each class.</p>
</div>
</div>
<div id="joint-estimation-mixture-model-parameters-and-latent-states-using-the-em-algorithm" class="section level2" number="3.6">
<h2>
<span class="header-section-number">3.6</span> Joint estimation mixture model parameters and latent states using the EM algorithm<a class="anchor" aria-label="anchor" href="#joint-estimation-mixture-model-parameters-and-latent-states-using-the-em-algorithm"><i class="fas fa-link"></i></a>
</h2>
<div id="motivation" class="section level3" number="3.6.1">
<h3>
<span class="header-section-number">3.6.1</span> Motivation<a class="anchor" aria-label="anchor" href="#motivation"><i class="fas fa-link"></i></a>
</h3>
<p>As discussed above, the observed data log-likelihood can be difficult to maximise directly due to its form as a log marginal likelihood. Intriguingly, it is possible to optimise it indirectly using the complete data log-likelihood!</p>
<p>This is the idea behind the EM algorithm<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;Dempster, A. P, N. M. Laird and D. B. Rubin. 1977. Maximum likelihood from
incomplete data via the EM algorithm. JRSS B &lt;strong&gt;39&lt;/strong&gt;:1–38. &lt;a href="https://doi.org/10.1111/j.2517-6161.1977.tb01600.x" class="uri"&gt;https://doi.org/10.1111/j.2517-6161.1977.tb01600.x&lt;/a&gt;&lt;/p&gt;'><sup>10</sup></a> proposed by Arthur Dempster and others in 1977 which exploits the simplicity of the complete data likelihood
and to obtain estimates of <span class="math inline">\(\boldsymbol \theta\)</span> by imputing the missing group allocations
and then subsequently iteratively refining both the imputations and the estimates of <span class="math inline">\(\boldsymbol \theta\)</span>.</p>
<p>More precisely, in the EM (=expectation-maximisation) algorithm we alternate between</p>
<ol style="list-style-type: decimal">
<li>updating the soft allocations of each sample using the current estimate of the parameters <span class="math inline">\(\boldsymbol \theta\)</span> (obtained in step 2)</li>
<li>updating the parameter estimates by maximising the <em>expected</em> complete data log-likelihood. The expectation is taken with regard to the distribution over the latent states (obtained in step 1). Thus
the complete data log-likelihood is averaged over the soft class assignments.</li>
</ol>
</div>
<div id="the-em-algorithm" class="section level3" number="3.6.2">
<h3>
<span class="header-section-number">3.6.2</span> The EM algorithm<a class="anchor" aria-label="anchor" href="#the-em-algorithm"><i class="fas fa-link"></i></a>
</h3>
<p>Specifically, the EM algorithm proceeds as follows:</p>
<ol style="list-style-type: decimal">
<li>Initialisation:</li>
</ol>
<ul>
<li>Start with a guess of the parameters <span class="math inline">\(\hat{\boldsymbol \theta}^{(1)}\)</span>, then continue with “E” Step, Part A.</li>
<li>Alternatively, start with a guess of the soft allocations for each sample <span class="math inline">\(q_i(k)^{(1)}\)</span>, collected in the matrix <span class="math inline">\(\boldsymbol Q^{(1)}\)</span>, then continue with “E” Step, Part B.<br>
This may be derived from some prior information, e.g., from running <span class="math inline">\(K\)</span>-means. Caveat: some particular initialisations correspond to invariant states and hence should be avoided (see further below).</li>
</ul>
<ol start="2" style="list-style-type: decimal">
<li><strong>E “expectation” step</strong></li>
</ol>
<ul>
<li><p>Part A: Use Bayes’ theorem to compute new probabilities of allocation to class <span class="math inline">\(k\)</span> for all the samples <span class="math inline">\(\boldsymbol x_i\)</span>:
<span class="math display">\[
q_i(k)^{(b+1)} \leftarrow \frac{ \hat{\pi}_k^{(b)} f_k(\boldsymbol x_i | \hat{\boldsymbol \theta}^{(b)})    }{  f(\boldsymbol x_i |\hat{\boldsymbol \theta}^{(b)} )  }
\]</span>
Note that to obtain <span class="math inline">\(q_i(k)^{(b+1)}\)</span> the current estimate
<span class="math inline">\(\hat{\boldsymbol \theta}^{(b)}\)</span> of the parameters of the mixture model is required.</p></li>
<li><p>Part B: Construct the <em>expected</em> complete data log-likelihood function for <span class="math inline">\(\boldsymbol \theta\)</span> using the soft allocations <span class="math inline">\(q_i(k)^{(b+1)}\)</span>
collected in the matrix <span class="math inline">\(\boldsymbol Q^{(b+1)}\)</span>:
<span class="math display">\[
G(\boldsymbol \theta| \boldsymbol X, \boldsymbol Q^{(b+1)} ) = \sum_{i=1}^n \sum_{k=1}^K q_i(k)^{(b+1)}  \log \left( \pi_k f_k(\boldsymbol x_i) \right)
\]</span>
Note that in the case that the soft allocations <span class="math inline">\(\boldsymbol Q^{(b+1)}\)</span> turn into hard 0/1 allocations then
<span class="math inline">\(G(\boldsymbol \theta| \boldsymbol X, \boldsymbol Q^{(b+1)})\)</span> becomes equivalent to the complete data log-likelihood.</p></li>
</ul>
<ol start="3" style="list-style-type: decimal">
<li><p><strong>M “maximisation” step</strong> — Maximise the expected complete data log-likelihood to update the estimates of mixture model parameters:
<span class="math display">\[
\hat{\boldsymbol \theta}^{(b+1)} \leftarrow \arg \max_{\boldsymbol \theta}  G(\boldsymbol \theta| \boldsymbol X, \boldsymbol Q^{(b+1)} )
\]</span></p></li>
<li><p>Continue with 2) “E” Step until the series <span class="math inline">\(\hat{\boldsymbol \theta}^{(1)}, \hat{\boldsymbol \theta}^{(2)}, \hat{\boldsymbol \theta}^{(3)}, \ldots\)</span> has converged.</p></li>
</ol>
<p>Since maximisation of the expected complete data log-likelihood is typically much easier (and often also analytically tractable) the EM algorithm is often preferred over direct
maximisation of the observed data log-likelihood.</p>
<p>Note that to avoid singularities in the expected log-likelihood function we
may need to adopt regularisation (i.e. penalised maximum likelihood or Bayesian learning) for estimating the parameters in the M-step.</p>
</div>
<div id="em-algorithm-for-multivariate-normal-mixture-model" class="section level3" number="3.6.3">
<h3>
<span class="header-section-number">3.6.3</span> EM algorithm for multivariate normal mixture model<a class="anchor" aria-label="anchor" href="#em-algorithm-for-multivariate-normal-mixture-model"><i class="fas fa-link"></i></a>
</h3>
<p>For a Gaussian mixture model (GMM) both steps in the EM algorithm can be expressed analytically:</p>
<p><strong>E-step:</strong></p>
<p>Update the soft allocations:
<span class="math display">\[
q_i(k)^{(b+1)} = \frac{ \hat{\pi}_k^{(b)} N(\boldsymbol x_i | \hat{\boldsymbol \mu}_k^{(b)}, \hat{\boldsymbol \Sigma}_k^{(b)}) }{  \hat{f}^{(b)}(\boldsymbol x_i)  }
\]</span></p>
<p><strong>M-step:</strong></p>
<p>The number of samples assigned to class <span class="math inline">\(k\)</span> in the current step is
<span class="math display">\[
n_k^{(b+1)} = \sum_{i=1}^n q_i(k)^{(b+1)} 
\]</span>
Note this is not necessarily an integer because of the soft allocations of samples to groups!</p>
<p>The updated estimate of the group probabilities is
<span class="math display">\[
\hat{\pi}_k^{(b+1)} = \frac{n_k^{(b+1)}}{n}
\]</span>
The updated estimate of the mean is
<span class="math display">\[
\hat{\boldsymbol \mu}_k^{(b+1)} = \frac{1}{n_k^{(b+1)}} \sum_{i=1}^n q_i(k)^{(b+1)} \boldsymbol x_i
\]</span>
and the updated covariance estimate is
<span class="math display">\[
\hat{\boldsymbol \Sigma}_k^{(b+1)} =  \frac{1}{n_k^{(b+1)}} \sum_{i=1}^n q_i(k)^{(b+1)} \left( \boldsymbol x_i -\boldsymbol \mu_k^{(b+1)}\right)   \left( \boldsymbol x_i -\boldsymbol \mu_k^{(b+1)}\right)^T
\]</span></p>
<p>Note that if <span class="math inline">\(q_i(k)\)</span> is a hard allocation (so that for any <span class="math inline">\(i\)</span> only one class has weight 1 and all others weight 0) then all estimators above reduce to the usual empirical estimators.</p>
<p>In Worksheet 7 you can find a simple R implementation of the EM algorithm for
univariate normal mixtures.</p>
<p>Similar analytical expressions as in the normal case
can also be found in more general mixtures where the components
are exponential families.</p>
</div>
<div id="connection-with-k-means-clustering-method" class="section level3" number="3.6.4">
<h3>
<span class="header-section-number">3.6.4</span> Connection with <span class="math inline">\(K\)</span>-means clustering method<a class="anchor" aria-label="anchor" href="#connection-with-k-means-clustering-method"><i class="fas fa-link"></i></a>
</h3>
<p>The <span class="math inline">\(K\)</span>-means algorithm is very closely related to the EM algorithm and
probabilistic clustering with a specific Gaussian mixture models.</p>
<p>Specifically, we assume a simplified model where the probabilities <span class="math inline">\(\pi_k\)</span> of all classes are equal (i.e. <span class="math inline">\(\pi_k=\frac{1}{K}\)</span>) and where the covariances <span class="math inline">\(\boldsymbol \Sigma_k\)</span> are all of the same spherical form <span class="math inline">\(\sigma^2 \boldsymbol I\)</span>. Thus, the covariance does not depend on the group, there is no correlation between the variables and the variance of all variables is the same.</p>
<p>First, we consider the “E” step. Using the mixture model above
the soft assignment for the class allocation becomes
<span class="math display">\[
\log( q_i(k) ) = -\frac{1}{2 \sigma^2} (\boldsymbol x_i-\hat{\boldsymbol \mu}_k)^T (\boldsymbol x_i-\hat{\boldsymbol \mu}_k) +  \text{const} 
\]</span>
where <span class="math inline">\(\text{const}\)</span> does not depend on <span class="math inline">\(k\)</span>. This can turned into a hard class allocation by
<span class="math display">\[
\begin{split}
y_i &amp;= \underset{k}{\arg \max} \log( q_i(k) ) \\
          &amp; = \underset{k}{\arg \min}  (\boldsymbol x_i-\hat{\boldsymbol \mu}_k)^T (\boldsymbol x_i-\hat{\boldsymbol \mu}_k)\\
\end{split}
\]</span>
which is exactly the <span class="math inline">\(K\)</span>-means rule to allocate of samples to groups.</p>
<p>Second, in the “M” step we compute the parameters of the model. If the class allocations
are hard the expected log-likelihood becomes the observed data likelihood and the
MLE of the group mean is the average of samples in that group.</p>
<p>Thus, <span class="math inline">\(K\)</span>-means can be viewed as an EM type algorithm to provide hard classification
based on a simple restricted Gaussian mixture model.</p>
</div>
<div id="why-the-em-algorithm-works-an-entropy-point-of-view" class="section level3" number="3.6.5">
<h3>
<span class="header-section-number">3.6.5</span> Why the EM algorithm works — an entropy point of view<a class="anchor" aria-label="anchor" href="#why-the-em-algorithm-works-an-entropy-point-of-view"><i class="fas fa-link"></i></a>
</h3>
<p>The iterative (soft) imputation of the latent states in the EM algorithm is intuitive.
However, it is not immediately clear why the expected observed log-likelihood needs to be maximised
rather than, e.g., the observed log-likelihood with hard allocations. Furthermore,
we need to show that maximising the marginal likelihood and applying the
EM algorithm with Bayesian imputation of the latent states both lead to the same
fitted mixture model.</p>
<p>Intriguingly, the EM algorithm is easiest to understand from an entropy point of view,
considering the entropy foundations of maximum likelihood and Bayesian learning
— for details see part I and II of <a href="https://strimmerlab.github.io/publications/lecture-notes/MATH20802/">MATH20802 Statistical Methods</a>.</p>
<p>First, recall that the method of maximum likelihood results from minimising the
KL divergence
between an empirical distribution <span class="math inline">\(Q_{\boldsymbol x}\)</span> representing the observations <span class="math inline">\(\boldsymbol x_1, \ldots, \boldsymbol x_n\)</span> and the model family <span class="math inline">\(F_{\boldsymbol x}^{\boldsymbol \theta}\)</span>
with parameters <span class="math inline">\(\boldsymbol \theta\)</span>:
<span class="math display">\[
\hat{\boldsymbol \theta}^{ML} =  \underset{\boldsymbol \theta}{\arg \min}\,\, D_{\text{KL}}(Q_{\boldsymbol x}, F_{\boldsymbol x}^{\boldsymbol \theta}) 
\]</span>
The KL divergence decomposes into a cross-entropy and an entropy part
<span class="math display">\[
D_{\text{KL}}(Q_{\boldsymbol x}, F_{\boldsymbol \theta}) = H(Q_{\boldsymbol x}, F_{\boldsymbol x}^{\boldsymbol \theta})- H(Q_{\boldsymbol x})
\]</span>
hence minimising the KL divergence with regard to <span class="math inline">\(\boldsymbol \theta\)</span> is the same as maximising the function
<span class="math display">\[
\begin{split}
-n H(Q_{\boldsymbol x}, F_{\boldsymbol x}^{\boldsymbol \theta}) &amp;= n \text{E}_{Q_{\boldsymbol x}}( \log f(\boldsymbol x| \boldsymbol \theta)  ) \\
&amp;= \sum_{i=1}^n  \log f(\boldsymbol x_i | \boldsymbol \theta)\\
&amp;= \log L(\boldsymbol \theta| \boldsymbol X)\\
\end{split}
\]</span>
which is indeed the observed data log-likelihood for <span class="math inline">\(\boldsymbol \theta\)</span>.</p>
<p>Second, we recall the chain rule for the KL divergence. Specifically, the KL divergence for the
joint model forms an upper bound of the KL divergence for the marginal model:
<span class="math display">\[
\begin{split}
D_{\text{KL}}(Q_{\boldsymbol x,y} , F_{\boldsymbol x, y}^{\boldsymbol \theta}) &amp;= D_{\text{KL}}(Q_{\boldsymbol x} , F_{\boldsymbol x}^{\boldsymbol \theta}) + \underbrace{  D_{\text{KL}}(Q_{y| \boldsymbol x} , F_{y|\boldsymbol x}^{\boldsymbol \theta})   }_{\geq 0}\\
&amp;\geq D_{\text{KL}}(Q_{\boldsymbol x} , F_{\boldsymbol x}^{\boldsymbol \theta})
\end{split}
\]</span>
Unlike for <span class="math inline">\(\boldsymbol x\)</span> we do not have observations about <span class="math inline">\(y\)</span>. Nonetheless, we can model the joint distribution <span class="math inline">\(Q_{\boldsymbol x, y} =Q_{\boldsymbol x} Q_{y|\boldsymbol x}\)</span> by assuming a
distribution <span class="math inline">\(Q_{y|\boldsymbol x}\)</span> over the latent variable.</p>
<p>The EM algorithm arises from iteratively decreasing the joint KL divergence <span class="math inline">\(D_{\text{KL}}(Q_{\boldsymbol x} Q_{y|\boldsymbol x} , F_{\boldsymbol x, y}^{\boldsymbol \theta})\)</span> with regard to both <span class="math inline">\(Q_{y|\boldsymbol x}\)</span> and <span class="math inline">\(\boldsymbol \theta\)</span>:</p>
<ol style="list-style-type: decimal">
<li><p>“E” Step: While keeping <span class="math inline">\(\boldsymbol \theta\)</span> fixed we vary <span class="math inline">\(Q_{y|\boldsymbol x}\)</span> to minimise the joint KL divergence. The minimum is reached at <span class="math inline">\(D_{\text{KL}}(Q_{y| \boldsymbol x} , F_{y|\boldsymbol x}^{\boldsymbol \theta}) = 0\)</span>.
This is the case for <span class="math inline">\(Q_{y| \boldsymbol x} = F_{y|\boldsymbol x}^{\boldsymbol \theta}\)</span>, i.e. when the
latent distribution <span class="math inline">\(Q_{y| \boldsymbol x}\)</span> representing the soft allocations is computed
by conditioning, i.e. using Bayes’ theorem.</p></li>
<li><p>“M” Step: While keeping <span class="math inline">\(Q_{y| \boldsymbol x}\)</span> fixed the joint KL divergence is further minimised with regard to <span class="math inline">\(\boldsymbol \theta\)</span>. This is equivalent to maximising the
function <span class="math inline">\(\sum_{k=1}^K \sum_{i=1}^n q(k | \boldsymbol x_i) \log f(\boldsymbol x_i, k| \boldsymbol \theta)\)</span> which
is indeed the expected complete data log-likelihood.</p></li>
</ol>
<p>Note that in both steps the joint KL divergence always decreases and never increases. Furthermore, at the end of “E” step the joint KL divergence equals the marginal KL divergence. Thus, this procedure implicitly minimises the marginal KL divergence as well, and hence maximises the marginal log-likelihood.</p>
<p>Alternatively, using <span class="math inline">\(H( Q_{\boldsymbol x,y}) = H(Q_{\boldsymbol x}) + H(Q_{y| \boldsymbol x} )\)</span>
we can rewrite the above upper bound for the joint KL divergence as an equivalent lower
bound for <span class="math inline">\(n\)</span> times the negative marginal cross-entropy:
<span class="math display">\[
\begin{split}
- n H(Q_{\boldsymbol x}, F_{\boldsymbol x}^{\boldsymbol \theta}) &amp;= \underbrace{ -n  H(Q_{\boldsymbol x} Q_{y| \boldsymbol x} , F_{\boldsymbol x, y}^{\boldsymbol \theta})  + n H(Q_{y| \boldsymbol x} )}_{\text{lower bound, ELBO}}  + \underbrace{ n D_{\text{KL}}(Q_{y| \boldsymbol x} , F_{y|\boldsymbol x}^{\boldsymbol \theta})}_{\geq 0}\\ 
&amp; \geq {\cal F}\left( Q_{\boldsymbol x}, Q_{y| \boldsymbol x},  F_{\boldsymbol x, y}^{\boldsymbol \theta}\right)\\
\end{split}
\]</span>
The lower bound is known as the “ELBO”. The EM algorithm then arises by
maximising <span class="math inline">\(\cal F\)</span> with regard to <span class="math inline">\(Q_{y| \boldsymbol x}\)</span> (“E” step“) and <span class="math inline">\(\boldsymbol \theta\)</span> (”M" step).</p>
<p>The entropy interpretation of the EM algorithm is due to Csiszàr and Tusnàdy (1984)<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;Csiszàr, I., and G, Tusnàdy. 1984. Information geometry and alternating minimization procedures. In Dudewicz, E. J. et al. (eds.) Recent Results in Estimation Theory and Related Topics Statistics and Decisions, Supplement Issue No. 1.&lt;/p&gt;"><sup>11</sup></a> and the ELBO interpretation was introduced by Neal and Hinton (1998).<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;Neal, R. M., and G. Hinton. 1998. A view of the EM algorithm that justifies
incremental, sparse, and other variants. In Jordan, M.I. (eds.). Learning in Graphical Models. pp. 355–368. &lt;a href="https://doi.org/10.1007/978-94-011-5014-9_12" class="uri"&gt;https://doi.org/10.1007/978-94-011-5014-9_12&lt;/a&gt;&lt;/p&gt;'><sup>12</sup></a></p>
</div>
<div id="convergence-and-invariant-states" class="section level3" number="3.6.6">
<h3>
<span class="header-section-number">3.6.6</span> Convergence and invariant states<a class="anchor" aria-label="anchor" href="#convergence-and-invariant-states"><i class="fas fa-link"></i></a>
</h3>
<p>Under mild assumptions the EM algorithm is guaranteed to monotonically converge to local optima of the observed data log-likelihood.<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;Wu, C.F. 1983. On the convergence properties of the EM algorithm. The Annals of Statistics &lt;em&gt;11&lt;/em&gt;:95–103. &lt;a href="https://doi.org/10.1214/aos/1176346060" class="uri"&gt;https://doi.org/10.1214/aos/1176346060&lt;/a&gt;&lt;/p&gt;'><sup>13</sup></a> Thus the series <span class="math inline">\(\hat{\boldsymbol \theta}^{(1)}, \hat{\boldsymbol \theta}^{(2)}, \hat{\boldsymbol \theta}^{(3)}, \ldots\)</span> converges to the estimate <span class="math inline">\(\hat{\boldsymbol \theta}\)</span> found when maximising the observed data log-likelihood.
However, the speed of convergence in the EM algorithm can sometimes be slow, and there are also situations in which there is no convergence at all to <span class="math inline">\(\hat{\boldsymbol \theta}\)</span> because the EM algorithm remains in an invariant state.</p>
<p>An example of such an invariant state for a Gaussian mixture model is uniform initialisation of the latent variables <span class="math inline">\(q_i(k) = \frac{1}{K}\)</span>, where <span class="math inline">\(K\)</span> is the number of classes.<br>
With this we get in the M step <span class="math inline">\(n_k = \frac{n}{K}\)</span> and as parameter estimates
<span class="math display">\[
\hat{\pi}_k = \frac{1}{K}
\]</span>
<span class="math display">\[
\hat{\boldsymbol \mu}_k = \frac{1}{n} \sum_{i=1}^n \boldsymbol x_i = \bar{\boldsymbol x}
\]</span>
<span class="math display">\[
\hat{\boldsymbol \Sigma}_k = \frac{1}{n}  \sum_{i=1}^n ( \boldsymbol x_i -\bar{\boldsymbol x})   ( \boldsymbol x_i -\bar{\boldsymbol x})^T = \hat{\boldsymbol \Sigma}
\]</span>
Crucially, none of these actually depend on the group <span class="math inline">\(k\)</span>! Thus, in the E step when the next soft allocations are determined this leads to
<span class="math display">\[
q_i(k) = \frac{ \frac{1}{K} N(\boldsymbol x_i | \bar{\boldsymbol x}, \hat{\boldsymbol \Sigma} ) }{ \sum_{j=1}^K  \frac{1}{K} N(\boldsymbol x_i | \bar{\boldsymbol x}, \hat{\boldsymbol \Sigma} )  } = \frac{1}{K}
\]</span>
After one cycle in the EM algorithm we arrive at the same soft allocation that we started with, and the algorithm is trapped in an invariant state! Therefore uniform initialisation should clearly be avoided!</p>
</div>
</div>
<div id="application-of-gaussian-mixture-models" class="section level2" number="3.7">
<h2>
<span class="header-section-number">3.7</span> Application of Gaussian mixture models<a class="anchor" aria-label="anchor" href="#application-of-gaussian-mixture-models"><i class="fas fa-link"></i></a>
</h2>
<div id="choosing-the-number-of-classes" class="section level3" number="3.7.1">
<h3>
<span class="header-section-number">3.7.1</span> Choosing the number of classes<a class="anchor" aria-label="anchor" href="#choosing-the-number-of-classes"><i class="fas fa-link"></i></a>
</h3>
<p>In an application of a GMM we need to select a suitable value for <span class="math inline">\(K\)</span>, i.e. the number of classe.</p>
<p>Since GMMs operate in a likelihood framework we can use penalised likelihood model selection criteria to choose among different models (i.e. GMMs with different numbers of classes).</p>
<p>The most popular choices are AIC (Akaike Information Criterion) and BIC (Bayesian Information criterion) defined as follows:
<span class="math display">\[\text{AIC}= -2 \log L + 2 K \]</span>
<span class="math display">\[\text{BIC}= - 2 \log L +K \log(n)\]</span></p>
<p>In order to choose a suitable model we evaluate different models with different <span class="math inline">\(K\)</span> and then choose the model that minimises <span class="math inline">\(\text{AIC}\)</span> or <span class="math inline">\(\text{BIC}\)</span></p>
<p>Note that in both criteria more complex models with more parameters (in this case groups) are penalised over simpler models in order to prevent overfitting.</p>
<p>Another way of choosing optimal numbers of clusters is by cross-validation (see later chapter on supervised learning).</p>
</div>
<div id="application-of-gmms-to-iris-flower-data" class="section level3" number="3.7.2">
<h3>
<span class="header-section-number">3.7.2</span> Application of GMMs to Iris flower data<a class="anchor" aria-label="anchor" href="#application-of-gmms-to-iris-flower-data"><i class="fas fa-link"></i></a>
</h3>
<p>We now explore the application of Gaussian mixture models to the Iris flower data set we also investigated with PCA
and K-means.</p>
<p>First, we fit a GMM with 3 clusters, using the R software “mclust.”<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;L. Scrucca L. et. al. 2016. mclust 5: Clustering, classification and density estimation using Gaussian finite mixture models. The R Journal 8:205–233.
See &lt;a href="https://journal.r-project.org/archive/2016/RJ-2016-021/" class="uri"&gt;https://journal.r-project.org/archive/2016/RJ-2016-021/&lt;/a&gt; and &lt;a href="https://mclust-org.github.io/mclust/" class="uri"&gt;https://mclust-org.github.io/mclust/&lt;/a&gt;&lt;/p&gt;'><sup>14</sup></a></p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span><span class="op">(</span><span class="va">iris</span><span class="op">)</span>
<span class="va">X.iris</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/scale.html">scale</a></span><span class="op">(</span><span class="op">(</span><span class="va">iris</span><span class="op">[</span>, <span class="fl">1</span><span class="op">:</span><span class="fl">4</span><span class="op">]</span><span class="op">)</span>, scale<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span> <span class="co"># center and standardise</span>
<span class="va">L.iris</span> <span class="op">=</span> <span class="va">iris</span><span class="op">[</span>, <span class="fl">5</span><span class="op">]</span>

<span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="st"><a href="https://mclust-org.github.io/mclust/">"mclust"</a></span><span class="op">)</span>
<span class="va">gmm3</span> <span class="op">=</span> <span class="fu"><a href="https://mclust-org.github.io/mclust/reference/Mclust.html">Mclust</a></span><span class="op">(</span><span class="va">X.iris</span>, G<span class="op">=</span><span class="fl">3</span>, verbose<span class="op">=</span><span class="cn">FALSE</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">gmm3</span>, what<span class="op">=</span><span class="st">"classification"</span><span class="op">)</span></code></pre></div>
<div class="inline-figure"><img src="3-clustering-c_files/figure-html/unnamed-chunk-4-1.png" width="480"></div>
<p>The “mclust” software has used the following model when fitting the mixture:</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">gmm3</span><span class="op">$</span><span class="va">modelName</span></code></pre></div>
<pre><code>## [1] "VVV"</code></pre>
<p>Here “VVV” is the name used by the “mclust” software for a model
allowing for an individual
unrestricted covariance matrix <span class="math inline">\(\boldsymbol \Sigma_k\)</span> for each class <span class="math inline">\(k\)</span>.</p>
<p>This GMM has a substantially lower misclassification error compared to <span class="math inline">\(K\)</span>-means with the same number of clusters:</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/table.html">table</a></span><span class="op">(</span><span class="va">gmm3</span><span class="op">$</span><span class="va">classification</span>, <span class="va">L.iris</span><span class="op">)</span></code></pre></div>
<pre><code>##    L.iris
##     setosa versicolor virginica
##   1     50          0         0
##   2      0         45         0
##   3      0          5        50</code></pre>
<p>Note that in “mclust” the BIC criterion is defined with the opposite sign (<span class="math inline">\(\text{BIC}_{\text{mclust}} = 2 \log L -K \log(n)\)</span>), thus we need to find the <em>maximum</em> value rather than the smallest value.</p>
<p>If we compute BIC for various numbers of groups we find that the model with the best <span class="math inline">\(\text{BIC}_{\text{mclust}}\)</span> is a model with 2 clusters but the model with 3 cluster has nearly as good a BIC:</p>
<div class="inline-figure"><img src="3-clustering-c_files/figure-html/unnamed-chunk-7-1.png" width="672"></div>

</div>
</div>
</div>

  <div class="chapter-nav">
<div class="prev"><a href="transformations-and-dimension-reduction.html"><span class="header-section-number">2</span> Transformations and dimension reduction</a></div>
<div class="next"><a href="supervised-learning-and-classification.html"><span class="header-section-number">4</span> Supervised learning and classification</a></div>
</div></main><div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <nav id="toc" data-toggle="toc" aria-label="On this page"><h2>On this page</h2>
      <ul class="nav navbar-nav">
<li><a class="nav-link" href="#unsupervised-learning-and-clustering"><span class="header-section-number">3</span> Unsupervised learning and clustering</a></li>
<li>
<a class="nav-link" href="#challenges-in-unsupervised-learning"><span class="header-section-number">3.1</span> Challenges in unsupervised learning</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#objective"><span class="header-section-number">3.1.1</span> Objective</a></li>
<li><a class="nav-link" href="#questions-and-problems"><span class="header-section-number">3.1.2</span> Questions and problems</a></li>
<li><a class="nav-link" href="#why-is-clustering-difficult"><span class="header-section-number">3.1.3</span> Why is clustering difficult?</a></li>
<li><a class="nav-link" href="#common-types-of-clustering-methods"><span class="header-section-number">3.1.4</span> Common types of clustering methods</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#hierarchical-clustering"><span class="header-section-number">3.2</span> Hierarchical clustering</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#tree-like-structures"><span class="header-section-number">3.2.1</span> Tree-like structures</a></li>
<li><a class="nav-link" href="#agglomerative-hierarchical-clustering-algorithms"><span class="header-section-number">3.2.2</span> Agglomerative hierarchical clustering algorithms</a></li>
<li><a class="nav-link" href="#wards-clustering-method"><span class="header-section-number">3.2.3</span> Ward’s clustering method</a></li>
<li><a class="nav-link" href="#application-to-swiss-banknote-data-set"><span class="header-section-number">3.2.4</span> Application to Swiss banknote data set</a></li>
<li><a class="nav-link" href="#assessment-of-the-uncertainty-of-hierarchical-clusterings"><span class="header-section-number">3.2.5</span> Assessment of the uncertainty of hierarchical clusterings</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#k-means-clustering"><span class="header-section-number">3.3</span> \(K\)-means clustering</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#set-up"><span class="header-section-number">3.3.1</span> Set-up</a></li>
<li><a class="nav-link" href="#algorithm"><span class="header-section-number">3.3.2</span> Algorithm</a></li>
<li><a class="nav-link" href="#properties"><span class="header-section-number">3.3.3</span> Properties</a></li>
<li><a class="nav-link" href="#choosing-the-number-of-clusters"><span class="header-section-number">3.3.4</span> Choosing the number of clusters</a></li>
<li><a class="nav-link" href="#k-medoids-aka-pam"><span class="header-section-number">3.3.5</span> \(K\)-medoids aka PAM</a></li>
<li><a class="nav-link" href="#application-of-k-means-to-iris-data"><span class="header-section-number">3.3.6</span> Application of \(K\)-means to Iris data</a></li>
<li><a class="nav-link" href="#arbitrariness-of-cluster-labels-and-label-switching"><span class="header-section-number">3.3.7</span> Arbitrariness of cluster labels and label switching</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#mixture-models"><span class="header-section-number">3.4</span> Mixture models</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#finite-mixture-model"><span class="header-section-number">3.4.1</span> Finite mixture model</a></li>
<li><a class="nav-link" href="#total-mean-and-variance-of-mixture-model"><span class="header-section-number">3.4.2</span> Total mean and variance of mixture model</a></li>
<li><a class="nav-link" href="#total-variation"><span class="header-section-number">3.4.3</span> Total variation</a></li>
<li><a class="nav-link" href="#univariate-mixture"><span class="header-section-number">3.4.4</span> Univariate mixture</a></li>
<li><a class="nav-link" href="#example-of-mixtures"><span class="header-section-number">3.4.5</span> Example of mixtures</a></li>
<li><a class="nav-link" href="#sampling-from-a-mixture-model"><span class="header-section-number">3.4.6</span> Sampling from a mixture model</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#fitting-mixture-models-to-data-and-inferring-the-latent-states"><span class="header-section-number">3.5</span> Fitting mixture models to data and inferring the latent states</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#observed-and-latent-variables"><span class="header-section-number">3.5.1</span> Observed and latent variables</a></li>
<li><a class="nav-link" href="#complete-data-likelihood-and-observed-data-likelihood"><span class="header-section-number">3.5.2</span> Complete data likelihood and observed data likelihood</a></li>
<li><a class="nav-link" href="#fitting-the-mixture-model-to-the-observed-data"><span class="header-section-number">3.5.3</span> Fitting the mixture model to the observed data</a></li>
<li><a class="nav-link" href="#predicting-the-group-allocation-of-a-given-sample"><span class="header-section-number">3.5.4</span> Predicting the group allocation of a given sample</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#joint-estimation-mixture-model-parameters-and-latent-states-using-the-em-algorithm"><span class="header-section-number">3.6</span> Joint estimation mixture model parameters and latent states using the EM algorithm</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#motivation"><span class="header-section-number">3.6.1</span> Motivation</a></li>
<li><a class="nav-link" href="#the-em-algorithm"><span class="header-section-number">3.6.2</span> The EM algorithm</a></li>
<li><a class="nav-link" href="#em-algorithm-for-multivariate-normal-mixture-model"><span class="header-section-number">3.6.3</span> EM algorithm for multivariate normal mixture model</a></li>
<li><a class="nav-link" href="#connection-with-k-means-clustering-method"><span class="header-section-number">3.6.4</span> Connection with \(K\)-means clustering method</a></li>
<li><a class="nav-link" href="#why-the-em-algorithm-works-an-entropy-point-of-view"><span class="header-section-number">3.6.5</span> Why the EM algorithm works — an entropy point of view</a></li>
<li><a class="nav-link" href="#convergence-and-invariant-states"><span class="header-section-number">3.6.6</span> Convergence and invariant states</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#application-of-gaussian-mixture-models"><span class="header-section-number">3.7</span> Application of Gaussian mixture models</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#choosing-the-number-of-classes"><span class="header-section-number">3.7.1</span> Choosing the number of classes</a></li>
<li><a class="nav-link" href="#application-of-gmms-to-iris-flower-data"><span class="header-section-number">3.7.2</span> Application of GMMs to Iris flower data</a></li>
</ul>
</li>
</ul>

      <div class="book-extra">
        <ul class="list-unstyled">
          
        </ul>
</div>
    </nav>
</div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5"><div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong>Multivariate Statistics and Machine Learning</strong>" was written by Korbinian Strimmer. It was last built on 2 June 2022.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>This book was built by the <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer><!-- dynamically load mathjax for compatibility with self-contained --><script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script><script type="text/x-mathjax-config">const popovers = document.querySelectorAll('a.footnote-ref[data-toggle="popover"]');
for (let popover of popovers) {
  const div = document.createElement('div');
  div.setAttribute('style', 'position: absolute; top: 0, left:0; width:0, height:0, overflow: hidden; visibility: hidden;');
  div.innerHTML = popover.getAttribute('data-content');

  var has_math = div.querySelector("span.math");
  if (has_math) {
    document.body.appendChild(div);
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, div]);
    MathJax.Hub.Queue(function() {
      popover.setAttribute('data-content', div.innerHTML);
      document.body.removeChild(div);
    })
  }
}
</script>
</body>
</html>
